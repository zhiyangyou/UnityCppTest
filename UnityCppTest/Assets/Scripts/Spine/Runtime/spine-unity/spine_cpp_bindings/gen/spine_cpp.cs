// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace spine_cpp
{
    namespace Spine
    {
        public unsafe partial class DefaultSpineExtension : global::spine_cpp.Spine.SpineExtension, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineExtension;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0DefaultSpineExtension@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0DefaultSpineExtension@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new DefaultSpineExtension __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new DefaultSpineExtension(native.ToPointer(), skipVTables);
            }

            internal static new DefaultSpineExtension __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (DefaultSpineExtension)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new DefaultSpineExtension __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (DefaultSpineExtension)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static DefaultSpineExtension __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new DefaultSpineExtension(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.DefaultSpineExtension.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private DefaultSpineExtension(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected DefaultSpineExtension(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public DefaultSpineExtension()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.DefaultSpineExtension.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.DefaultSpineExtension");
            }

            public DefaultSpineExtension(global::spine_cpp.Spine.DefaultSpineExtension _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.DefaultSpineExtension.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.DefaultSpineExtension");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override __IntPtr Alloc(ulong size, string file, int line)
            {
                var ___AllocDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr_ulong_string8_int>(0, 1);
                var ___ret = ___AllocDelegate(__Instance, size, file, line);
                return ___ret;
            }

            public override __IntPtr Calloc(ulong size, string file, int line)
            {
                var ___CallocDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr_ulong_string8_int>(0, 2);
                var ___ret = ___CallocDelegate(__Instance, size, file, line);
                return ___ret;
            }

            public override __IntPtr Realloc(__IntPtr ptr, ulong size, string file, int line)
            {
                var ___ReallocDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr_ulong_string8_int>(0, 3);
                var ___ret = ___ReallocDelegate(__Instance, ptr, size, file, line);
                return ___ret;
            }

            public override void Free(__IntPtr mem, string file, int line)
            {
                var ___FreeDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_string8_int>(0, 4);
                ___FreeDelegate(__Instance, mem, file, line);
            }

            public override sbyte* _readFile(global::spine_cpp.Spine.String path, ref int length)
            {
                var ____readFileDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_sbytePtr___IntPtr___IntPtr_intPtr>(0, 5);
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = path.__Instance;
                fixed (int* __length1 = &length)
                {
                    var __arg1 = __length1;
                    var ___ret = ____readFileDelegate(__Instance, __arg0, __arg1);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // virtual ~DefaultSpineExtension()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.DefaultSpineExtension.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void *_alloc(size_t size, const char *file, int line) override
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr_ulong_string8_int _AllocDelegateInstance;

            private static __IntPtr _AllocDelegateHook(__IntPtr __instance, ulong size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line)
            {
                var __target = global::spine_cpp.Spine.DefaultSpineExtension.__GetInstance(__instance);
                var ___ret = __target.Alloc(size, file, line);
                return ___ret;
            }

            // void *_calloc(size_t size, const char *file, int line) override
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr_ulong_string8_int _CallocDelegateInstance;

            private static __IntPtr _CallocDelegateHook(__IntPtr __instance, ulong size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line)
            {
                var __target = global::spine_cpp.Spine.DefaultSpineExtension.__GetInstance(__instance);
                var ___ret = __target.Calloc(size, file, line);
                return ___ret;
            }

            // void *_realloc(void *ptr, size_t size, const char *file, int line) override
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr_ulong_string8_int _ReallocDelegateInstance;

            private static __IntPtr _ReallocDelegateHook(__IntPtr __instance, __IntPtr ptr, ulong size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line)
            {
                var __target = global::spine_cpp.Spine.DefaultSpineExtension.__GetInstance(__instance);
                var ___ret = __target.Realloc(ptr, size, file, line);
                return ___ret;
            }

            // void _free(void *mem, const char *file, int line) override
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_string8_int _FreeDelegateInstance;

            private static void _FreeDelegateHook(__IntPtr __instance, __IntPtr mem, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line)
            {
                var __target = global::spine_cpp.Spine.DefaultSpineExtension.__GetInstance(__instance);
                __target.Free(mem, file, line);
            }

            // char *_readFile(const String &path, int *length) override
            private static global::spine_cpp.Delegates.Func_sbytePtr___IntPtr___IntPtr_intPtr __readFileDelegateInstance;

            private static sbyte* __readFileDelegateHook(__IntPtr __instance, __IntPtr path, int* length)
            {
                var __target = global::spine_cpp.Spine.DefaultSpineExtension.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(path, false, skipVTables: true);
                var ___ret = __target._readFile(__result0, ref *length);
                return ___ret;
            }

            // void _beforeFree(void *ptr)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr _BeforeFreeDelegateInstance;

            private static void _BeforeFreeDelegateHook(__IntPtr __instance, __IntPtr ptr)
            {
                var __target = global::spine_cpp.Spine.DefaultSpineExtension.__GetInstance(__instance);
                __target.BeforeFree(ptr);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[7];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _AllocDelegateInstance += _AllocDelegateHook;
                    _CallocDelegateInstance += _CallocDelegateHook;
                    _ReallocDelegateInstance += _ReallocDelegateHook;
                    _FreeDelegateInstance += _FreeDelegateHook;
                    __readFileDelegateInstance += __readFileDelegateHook;
                    _BeforeFreeDelegateInstance += _BeforeFreeDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AllocDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CallocDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ReallocDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_FreeDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(__readFileDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_BeforeFreeDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 7, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 7, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                VTables.Methods[0] = new Delegate[7];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe abstract partial class SpineExtension : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_SpineExtension;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SpineExtension@spine@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SpineExtension@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?readFile@SpineExtension@spine@@SAPEADAEBVString@2@PEAH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern sbyte* ReadFile(__IntPtr path, int* length);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getInstance@SpineExtension@spine@@SAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetInstance();

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setInstance@SpineExtension@spine@@SAXPEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetInstance(__IntPtr inSpineExtension);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.SpineExtension> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.SpineExtension>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.Spine.SpineExtension managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.Spine.SpineExtension managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static SpineExtension __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SpineExtensionInternal(native.ToPointer(), skipVTables);
            }

            internal static SpineExtension __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SpineExtension)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static SpineExtension __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (SpineExtension)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static SpineExtension __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SpineExtensionInternal(native, skipVTables);
            }

            protected SpineExtension(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected SpineExtension()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SpineExtension.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SpineExtension");
            }

            protected SpineExtension(global::spine_cpp.Spine.SpineExtension _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SpineExtension.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SpineExtension");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Implement this function to use your own memory allocator</summary>
            public abstract __IntPtr Alloc(ulong size, string file, int line);

            public abstract __IntPtr Calloc(ulong size, string file, int line);

            public abstract __IntPtr Realloc(__IntPtr ptr, ulong size, string file, int line);

            /// <summary>If you provide a spineAllocFunc, you should also provide a spineFreeFunc</summary>
            public abstract void Free(__IntPtr mem, string file, int line);

            public abstract sbyte* _readFile(global::spine_cpp.Spine.String path, ref int length);

            public virtual void BeforeFree(__IntPtr ptr)
            {
                var ___BeforeFreeDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr>(0, 6);
                ___BeforeFreeDelegate(__Instance, ptr);
            }

            public static sbyte* ReadFile(global::spine_cpp.Spine.String path, ref int length)
            {
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = path.__Instance;
                fixed (int* __length1 = &length)
                {
                    var __arg1 = __length1;
                    var ___ret = __Internal.ReadFile(__arg0, __arg1);
                    return ___ret;
                }
            }

            public static global::spine_cpp.Spine.SpineExtension instance
            {
                get
                {
                    var ___ret = __Internal.GetInstance();
                    var __result0 = global::spine_cpp.Spine.SpineExtension.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetInstance(__arg0);
                }
            }

            #region Virtual table interop

            // virtual ~SpineExtension()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.SpineExtension.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void *_alloc(size_t size, const char *file, int line) = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr_ulong_string8_int _AllocDelegateInstance;

            private static __IntPtr _AllocDelegateHook(__IntPtr __instance, ulong size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line)
            {
                var __target = global::spine_cpp.Spine.SpineExtension.__GetInstance(__instance);
                var ___ret = __target.Alloc(size, file, line);
                return ___ret;
            }

            // void *_calloc(size_t size, const char *file, int line) = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr_ulong_string8_int _CallocDelegateInstance;

            private static __IntPtr _CallocDelegateHook(__IntPtr __instance, ulong size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line)
            {
                var __target = global::spine_cpp.Spine.SpineExtension.__GetInstance(__instance);
                var ___ret = __target.Calloc(size, file, line);
                return ___ret;
            }

            // void *_realloc(void *ptr, size_t size, const char *file, int line) = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr_ulong_string8_int _ReallocDelegateInstance;

            private static __IntPtr _ReallocDelegateHook(__IntPtr __instance, __IntPtr ptr, ulong size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line)
            {
                var __target = global::spine_cpp.Spine.SpineExtension.__GetInstance(__instance);
                var ___ret = __target.Realloc(ptr, size, file, line);
                return ___ret;
            }

            // void _free(void *mem, const char *file, int line) = 0
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_string8_int _FreeDelegateInstance;

            private static void _FreeDelegateHook(__IntPtr __instance, __IntPtr mem, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line)
            {
                var __target = global::spine_cpp.Spine.SpineExtension.__GetInstance(__instance);
                __target.Free(mem, file, line);
            }

            // char *_readFile(const String &path, int *length) = 0
            private static global::spine_cpp.Delegates.Func_sbytePtr___IntPtr___IntPtr_intPtr __readFileDelegateInstance;

            private static sbyte* __readFileDelegateHook(__IntPtr __instance, __IntPtr path, int* length)
            {
                var __target = global::spine_cpp.Spine.SpineExtension.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(path, false, skipVTables: true);
                var ___ret = __target._readFile(__result0, ref *length);
                return ___ret;
            }

            // void _beforeFree(void *ptr)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr _BeforeFreeDelegateInstance;

            private static void _BeforeFreeDelegateHook(__IntPtr __instance, __IntPtr ptr)
            {
                var __target = global::spine_cpp.Spine.SpineExtension.__GetInstance(__instance);
                __target.BeforeFree(ptr);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[7];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _AllocDelegateInstance += _AllocDelegateHook;
                    _CallocDelegateInstance += _CallocDelegateHook;
                    _ReallocDelegateInstance += _ReallocDelegateHook;
                    _FreeDelegateInstance += _FreeDelegateHook;
                    __readFileDelegateInstance += __readFileDelegateHook;
                    _BeforeFreeDelegateInstance += _BeforeFreeDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AllocDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CallocDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ReallocDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_FreeDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(__readFileDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_BeforeFreeDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 7, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 7, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                VTables.Methods[0] = new Delegate[7];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class SpineExtensionInternal : global::spine_cpp.Spine.SpineExtension, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal SpineExtensionInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal SpineExtensionInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Implement this function to use your own memory allocator</summary>
            public override __IntPtr Alloc(ulong size, string file, int line)
            {
                var ___AllocDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr_ulong_string8_int>(0, 1);
                var ___ret = ___AllocDelegate(__Instance, size, file, line);
                return ___ret;
            }

            public override __IntPtr Calloc(ulong size, string file, int line)
            {
                var ___CallocDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr_ulong_string8_int>(0, 2);
                var ___ret = ___CallocDelegate(__Instance, size, file, line);
                return ___ret;
            }

            public override __IntPtr Realloc(__IntPtr ptr, ulong size, string file, int line)
            {
                var ___ReallocDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr_ulong_string8_int>(0, 3);
                var ___ret = ___ReallocDelegate(__Instance, ptr, size, file, line);
                return ___ret;
            }

            /// <summary>If you provide a spineAllocFunc, you should also provide a spineFreeFunc</summary>
            public override void Free(__IntPtr mem, string file, int line)
            {
                var ___FreeDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_string8_int>(0, 4);
                ___FreeDelegate(__Instance, mem, file, line);
            }

            public override sbyte* _readFile(global::spine_cpp.Spine.String path, ref int length)
            {
                var ____readFileDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_sbytePtr___IntPtr___IntPtr_intPtr>(0, 5);
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = path.__Instance;
                fixed (int* __length1 = &length)
                {
                    var __arg1 = __length1;
                    var ___ret = ____readFileDelegate(__Instance, __arg0, __arg1);
                    return ___ret;
                }
            }
        }

        public unsafe partial class Extension
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getDefaultExtension@spine@@YAPEAVSpineExtension@1@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDefaultExtension();
            }

            public static global::spine_cpp.Spine.SpineExtension GetDefaultExtension()
            {
                var ___ret = __Internal.GetDefaultExtension();
                var __result0 = global::spine_cpp.Spine.SpineExtension.__GetOrCreateInstance(___ret, true);
                return __result0;
            }
        }
    }

    namespace Spine
    {
        public unsafe partial class SpineObject : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SpineObject@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SpineObject@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.SpineObject> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.SpineObject>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.Spine.SpineObject managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.Spine.SpineObject managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static SpineObject __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SpineObject(native.ToPointer(), skipVTables);
            }

            internal static SpineObject __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SpineObject)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static SpineObject __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (SpineObject)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static SpineObject __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SpineObject(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.SpineObject.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private SpineObject(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SpineObject(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            public SpineObject()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SpineObject.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SpineObject");
            }

            public SpineObject(global::spine_cpp.Spine.SpineObject _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SpineObject.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SpineObject");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // virtual ~SpineObject()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.SpineObject.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class String : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal ulong _length;
                internal __IntPtr _buffer;
                internal byte _tempowner;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0String@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0String@spine@@QEAA@PEBD_N1@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string chars, bool own, bool tofree);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0String@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0String@spine@@QEAA@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor_1(__IntPtr __instance, __IntPtr pOther);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?own@String@spine@@QEAAXAEBV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Own(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?own@String@spine@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Own(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string chars);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?unown@String@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Unown(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?append@String@spine@@QEAAAEAV12@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Append(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string chars);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?append@String@spine@@QEAAAEAV12@AEBV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Append(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?append@String@spine@@QEAAAEAV12@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Append_1(__IntPtr __instance, int other);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?append@String@spine@@QEAAAEAV12@M@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Append_2(__IntPtr __instance, float other);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?startsWith@String@spine@@QEAA_NAEBV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool StartsWith(__IntPtr __instance, __IntPtr needle);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??8spine@@YA_NAEBVString@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr a, __IntPtr b);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??9spine@@YA_NAEBVString@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr a, __IntPtr b);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?length@String@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Length(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?isEmpty@String@spine@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsEmpty(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@String@spine@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Buffer(__IntPtr __instance);
            }

            internal static new String __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new String(native.ToPointer(), skipVTables);
            }

            internal static new String __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (String)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new String __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (String)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static String __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new String(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.String.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private String(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected String(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public String()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.String.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.String");
            }

            public String(string chars, bool own, bool tofree)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.String.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, chars, own, tofree);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.String");
            }

            public String(global::spine_cpp.Spine.String other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.String.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.String");
            }

            public String(__IntPtr pOther)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.String.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor_1(__Instance, pOther);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.String");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Own(global::spine_cpp.Spine.String other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.Own(__Instance, __arg0);
            }

            public void Own(string chars)
            {
                __Internal.Own(__Instance, chars);
            }

            public void Unown()
            {
                __Internal.Unown(__Instance);
            }

            public global::spine_cpp.Spine.String Append(string chars)
            {
                var ___ret = __Internal.Append(__Instance, chars);
                var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.String Append(global::spine_cpp.Spine.String other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = __Internal.Append(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.String Append(int other)
            {
                var ___ret = __Internal.Append_1(__Instance, other);
                var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.String Append(float other)
            {
                var ___ret = __Internal.Append_2(__Instance, other);
                var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public bool StartsWith(global::spine_cpp.Spine.String needle)
            {
                if (ReferenceEquals(needle, null))
                    throw new global::System.ArgumentNullException("needle", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = needle.__Instance;
                var ___ret = __Internal.StartsWith(__Instance, __arg0);
                return ___ret;
            }

            public static implicit operator global::spine_cpp.Spine.String(__IntPtr pOther)
            {
                return new global::spine_cpp.Spine.String(pOther);
            }

            public static bool operator ==(global::spine_cpp.Spine.String a, global::spine_cpp.Spine.String b)
            {
                bool aNull = ReferenceEquals(a, null);
                bool bNull = ReferenceEquals(b, null);
                if (aNull || bNull)
                    return aNull && bNull;
                var __arg0 = a.__Instance;
                var __arg1 = b.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::spine_cpp.Spine.String;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::spine_cpp.Spine.String.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::spine_cpp.Spine.String a, global::spine_cpp.Spine.String b)
            {
                bool aNull = ReferenceEquals(a, null);
                bool bNull = ReferenceEquals(b, null);
                if (aNull || bNull)
                    return !(aNull && bNull);
                var __arg0 = a.__Instance;
                var __arg1 = b.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public ulong Length
            {
                get
                {
                    var ___ret = __Internal.Length(__Instance);
                    return ___ret;
                }
            }

            public bool IsEmpty
            {
                get
                {
                    var ___ret = __Internal.IsEmpty(__Instance);
                    return ___ret;
                }
            }

            public string Buffer
            {
                get
                {
                    var ___ret = __Internal.Buffer(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            #region Virtual table interop

            // ~String()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.String.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        namespace Vector
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public unsafe partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal ulong _size;
                internal ulong _capacity;
                internal __IntPtr _buffer;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@_J@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector__K(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@_J@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector__K(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@_J@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector__K(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@_J@spine@@QEAAX_KAEB_J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector__K(__IntPtr __instance, ulong newSize, long* defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@_J@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector__K(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@_J@spine@@QEAAXAEB_J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector__K(__IntPtr __instance, long* inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@_J@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector__K(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@_J@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector__K(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@_J@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector__K(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@_J@spine@@QEAAAEA_J_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long* OperatorSubscriptc__N_spine_S_Vector__K(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@_J@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector__K(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@_J@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector__K(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@_J@spine@@QEAAPEA_JXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long* Bufferc__N_spine_S_Vector__K(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@_J@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector__K(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@M@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector__f(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@M@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector__f(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@M@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector__f(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@M@spine@@QEAAX_KAEBM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector__f(__IntPtr __instance, ulong newSize, float* defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@M@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector__f(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@M@spine@@QEAAXAEBM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector__f(__IntPtr __instance, float* inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@M@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector__f(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@M@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector__f(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@M@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector__f(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@M@spine@@QEAAAEAM_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float* OperatorSubscriptc__N_spine_S_Vector__f(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@M@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector__f(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@M@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector__f(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@M@spine@@QEAAPEAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float* Bufferc__N_spine_S_Vector__f(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@M@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector__f(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVBoneData@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_BoneData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVBoneData@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_BoneData(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVBoneData@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_BoneData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVBoneData@spine@@@spine@@QEAAX_KAEBQEAVBoneData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_BoneData(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVBoneData@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_BoneData(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVBoneData@spine@@@spine@@QEAAXAEBQEAVBoneData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_BoneData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVBoneData@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_BoneData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVBoneData@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_BoneData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVBoneData@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_BoneData(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVBoneData@spine@@@spine@@QEAAAEAPEAVBoneData@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_BoneData(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVBoneData@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_BoneData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVBoneData@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_BoneData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVBoneData@spine@@@spine@@QEAAPEAPEAVBoneData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_BoneData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVBoneData@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_BoneData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVSlotData@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_SlotData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVSlotData@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_SlotData(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVSlotData@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_SlotData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVSlotData@spine@@@spine@@QEAAX_KAEBQEAVSlotData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_SlotData(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVSlotData@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_SlotData(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVSlotData@spine@@@spine@@QEAAXAEBQEAVSlotData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_SlotData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVSlotData@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_SlotData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVSlotData@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_SlotData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVSlotData@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_SlotData(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVSlotData@spine@@@spine@@QEAAAEAPEAVSlotData@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_SlotData(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVSlotData@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_SlotData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVSlotData@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_SlotData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVSlotData@spine@@@spine@@QEAAPEAPEAVSlotData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_SlotData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVSlotData@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_SlotData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVSkin@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_Skin(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVSkin@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_Skin(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVSkin@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_Skin(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVSkin@spine@@@spine@@QEAAX_KAEBQEAVSkin@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_Skin(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVSkin@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_Skin(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVSkin@spine@@@spine@@QEAAXAEBQEAVSkin@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_Skin(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVSkin@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_Skin(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVSkin@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Skin(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVSkin@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_Skin(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVSkin@spine@@@spine@@QEAAAEAPEAVSkin@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Skin(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVSkin@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_Skin(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVSkin@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_Skin(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVSkin@spine@@@spine@@QEAAPEAPEAVSkin@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_Skin(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVSkin@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_Skin(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@V?$Vector@USkinEntry@spine@@@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@V?$Vector@USkinEntry@spine@@@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@V?$Vector@USkinEntry@spine@@@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@V?$Vector@USkinEntry@spine@@@spine@@@spine@@QEAAX_KAEBV?$Vector@USkinEntry@spine@@@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@V?$Vector@USkinEntry@spine@@@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@V?$Vector@USkinEntry@spine@@@spine@@@spine@@QEAAXAEBV?$Vector@USkinEntry@spine@@@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@V?$Vector@USkinEntry@spine@@@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@V?$Vector@USkinEntry@spine@@@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@V?$Vector@USkinEntry@spine@@@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@V?$Vector@USkinEntry@spine@@@spine@@@spine@@QEAAAEAV?$Vector@USkinEntry@spine@@@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@V?$Vector@USkinEntry@spine@@@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@V?$Vector@USkinEntry@spine@@@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@V?$Vector@USkinEntry@spine@@@spine@@@spine@@QEAAPEAV?$Vector@USkinEntry@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@V?$Vector@USkinEntry@spine@@@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@USkinEntry@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@USkinEntry@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@USkinEntry@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@USkinEntry@spine@@@spine@@QEAAX_KAEBUSkinEntry@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@USkinEntry@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@USkinEntry@spine@@@spine@@QEAAXAEBUSkinEntry@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@USkinEntry@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@USkinEntry@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@USkinEntry@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@USkinEntry@spine@@@spine@@QEAAAEAUSkinEntry@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@USkinEntry@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@USkinEntry@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@USkinEntry@spine@@@spine@@QEAAPEAUSkinEntry@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@USkinEntry@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector____N_spine_S_SkinEntry(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVConstraintData@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_ConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVConstraintData@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_ConstraintData(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVConstraintData@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_ConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVConstraintData@spine@@@spine@@QEAAX_KAEBQEAVConstraintData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_ConstraintData(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVConstraintData@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_ConstraintData(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVConstraintData@spine@@@spine@@QEAAXAEBQEAVConstraintData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_ConstraintData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVConstraintData@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_ConstraintData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVConstraintData@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_ConstraintData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVConstraintData@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_ConstraintData(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVConstraintData@spine@@@spine@@QEAAAEAPEAVConstraintData@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_ConstraintData(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVConstraintData@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_ConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVConstraintData@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_ConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVConstraintData@spine@@@spine@@QEAAPEAPEAVConstraintData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_ConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVConstraintData@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_ConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@VString@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector____N_spine_S_String(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@VString@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector____N_spine_S_String(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@VString@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector____N_spine_S_String(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@VString@spine@@@spine@@QEAAX_KAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector____N_spine_S_String(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@VString@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector____N_spine_S_String(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@VString@spine@@@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector____N_spine_S_String(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@VString@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector____N_spine_S_String(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@VString@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector____N_spine_S_String(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@VString@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector____N_spine_S_String(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@VString@spine@@@spine@@QEAAAEAVString@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector____N_spine_S_String(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@VString@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector____N_spine_S_String(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@VString@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector____N_spine_S_String(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@VString@spine@@@spine@@QEAAPEAVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector____N_spine_S_String(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@VString@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector____N_spine_S_String(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVAttachment@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_Attachment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVAttachment@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_Attachment(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVAttachment@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_Attachment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVAttachment@spine@@@spine@@QEAAX_KAEBQEAVAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_Attachment(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVAttachment@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_Attachment(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVAttachment@spine@@@spine@@QEAAXAEBQEAVAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_Attachment(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVAttachment@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_Attachment(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVAttachment@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Attachment(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVAttachment@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_Attachment(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVAttachment@spine@@@spine@@QEAAAEAPEAVAttachment@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Attachment(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVAttachment@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_Attachment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVAttachment@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_Attachment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVAttachment@spine@@@spine@@QEAAPEAPEAVAttachment@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_Attachment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVAttachment@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_Attachment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVEventData@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_EventData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVEventData@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_EventData(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVEventData@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_EventData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVEventData@spine@@@spine@@QEAAX_KAEBQEAVEventData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_EventData(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVEventData@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_EventData(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVEventData@spine@@@spine@@QEAAXAEBQEAVEventData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_EventData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVEventData@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_EventData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVEventData@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_EventData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVEventData@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_EventData(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVEventData@spine@@@spine@@QEAAAEAPEAVEventData@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_EventData(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVEventData@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_EventData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVEventData@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_EventData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVEventData@spine@@@spine@@QEAAPEAPEAVEventData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_EventData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVEventData@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_EventData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVAnimation@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_Animation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVAnimation@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_Animation(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVAnimation@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_Animation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVAnimation@spine@@@spine@@QEAAX_KAEBQEAVAnimation@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_Animation(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVAnimation@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_Animation(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVAnimation@spine@@@spine@@QEAAXAEBQEAVAnimation@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_Animation(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVAnimation@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_Animation(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVAnimation@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Animation(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVAnimation@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_Animation(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVAnimation@spine@@@spine@@QEAAAEAPEAVAnimation@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Animation(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVAnimation@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_Animation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVAnimation@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_Animation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVAnimation@spine@@@spine@@QEAAPEAPEAVAnimation@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_Animation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVAnimation@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_Animation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVTimeline@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_Timeline(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVTimeline@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_Timeline(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVTimeline@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_Timeline(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVTimeline@spine@@@spine@@QEAAX_KAEBQEAVTimeline@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_Timeline(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVTimeline@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_Timeline(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVTimeline@spine@@@spine@@QEAAXAEBQEAVTimeline@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_Timeline(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVTimeline@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_Timeline(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVTimeline@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Timeline(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVTimeline@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_Timeline(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVTimeline@spine@@@spine@@QEAAAEAPEAVTimeline@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Timeline(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVTimeline@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_Timeline(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVTimeline@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_Timeline(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVTimeline@spine@@@spine@@QEAAPEAPEAVTimeline@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_Timeline(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVTimeline@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_Timeline(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVEvent@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_Event(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVEvent@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_Event(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVEvent@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_Event(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVEvent@spine@@@spine@@QEAAX_KAEBQEAVEvent@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_Event(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVEvent@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_Event(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVEvent@spine@@@spine@@QEAAXAEBQEAVEvent@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_Event(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVEvent@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_Event(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVEvent@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Event(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVEvent@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_Event(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVEvent@spine@@@spine@@QEAAAEAPEAVEvent@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Event(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVEvent@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_Event(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVEvent@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_Event(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVEvent@spine@@@spine@@QEAAPEAPEAVEvent@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_Event(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVEvent@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_Event(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVIkConstraintData@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVIkConstraintData@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVIkConstraintData@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVIkConstraintData@spine@@@spine@@QEAAX_KAEBQEAVIkConstraintData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_IkConstraintData(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVIkConstraintData@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVIkConstraintData@spine@@@spine@@QEAAXAEBQEAVIkConstraintData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVIkConstraintData@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVIkConstraintData@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVIkConstraintData@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVIkConstraintData@spine@@@spine@@QEAAAEAPEAVIkConstraintData@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVIkConstraintData@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVIkConstraintData@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_IkConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVIkConstraintData@spine@@@spine@@QEAAPEAPEAVIkConstraintData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVIkConstraintData@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVTransformConstraintData@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVTransformConstraintData@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVTransformConstraintData@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVTransformConstraintData@spine@@@spine@@QEAAX_KAEBQEAVTransformConstraintData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVTransformConstraintData@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVTransformConstraintData@spine@@@spine@@QEAAXAEBQEAVTransformConstraintData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVTransformConstraintData@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVTransformConstraintData@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVTransformConstraintData@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVTransformConstraintData@spine@@@spine@@QEAAAEAPEAVTransformConstraintData@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVTransformConstraintData@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVTransformConstraintData@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVTransformConstraintData@spine@@@spine@@QEAAPEAPEAVTransformConstraintData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVTransformConstraintData@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVPathConstraintData@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVPathConstraintData@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVPathConstraintData@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVPathConstraintData@spine@@@spine@@QEAAX_KAEBQEAVPathConstraintData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_PathConstraintData(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVPathConstraintData@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVPathConstraintData@spine@@@spine@@QEAAXAEBQEAVPathConstraintData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVPathConstraintData@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVPathConstraintData@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVPathConstraintData@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVPathConstraintData@spine@@@spine@@QEAAAEAPEAVPathConstraintData@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVPathConstraintData@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVPathConstraintData@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_PathConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVPathConstraintData@spine@@@spine@@QEAAPEAPEAVPathConstraintData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVPathConstraintData@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAD@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector___C(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAD@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector___C(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAD@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector___C(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAD@spine@@QEAAX_KAEBQEAD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector___C(__IntPtr __instance, ulong newSize, sbyte** defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAD@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector___C(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAD@spine@@QEAAXAEBQEAD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector___C(__IntPtr __instance, sbyte** inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAD@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector___C(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAD@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector___C(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAD@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector___C(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAD@spine@@QEAAAEAPEAD_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern sbyte** OperatorSubscriptc__N_spine_S_Vector___C(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAD@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector___C(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAD@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector___C(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAD@spine@@QEAAPEAPEADXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern sbyte** Bufferc__N_spine_S_Vector___C(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAD@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector___C(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVBone@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_Bone(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVBone@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_Bone(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVBone@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_Bone(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVBone@spine@@@spine@@QEAAX_KAEBQEAVBone@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_Bone(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVBone@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_Bone(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVBone@spine@@@spine@@QEAAXAEBQEAVBone@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_Bone(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVBone@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_Bone(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVBone@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Bone(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVBone@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_Bone(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVBone@spine@@@spine@@QEAAAEAPEAVBone@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Bone(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVBone@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_Bone(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVBone@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_Bone(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVBone@spine@@@spine@@QEAAPEAPEAVBone@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_Bone(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVBone@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_Bone(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVSlot@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_Slot(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVSlot@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_Slot(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVSlot@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_Slot(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVSlot@spine@@@spine@@QEAAX_KAEBQEAVSlot@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_Slot(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVSlot@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_Slot(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVSlot@spine@@@spine@@QEAAXAEBQEAVSlot@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_Slot(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVSlot@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_Slot(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVSlot@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Slot(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVSlot@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_Slot(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVSlot@spine@@@spine@@QEAAAEAPEAVSlot@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Slot(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVSlot@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_Slot(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVSlot@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_Slot(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVSlot@spine@@@spine@@QEAAPEAPEAVSlot@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_Slot(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVSlot@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_Slot(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVIkConstraint@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_IkConstraint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVIkConstraint@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_IkConstraint(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVIkConstraint@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_IkConstraint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVIkConstraint@spine@@@spine@@QEAAX_KAEBQEAVIkConstraint@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_IkConstraint(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVIkConstraint@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_IkConstraint(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVIkConstraint@spine@@@spine@@QEAAXAEBQEAVIkConstraint@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_IkConstraint(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVIkConstraint@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_IkConstraint(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVIkConstraint@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_IkConstraint(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVIkConstraint@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_IkConstraint(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVIkConstraint@spine@@@spine@@QEAAAEAPEAVIkConstraint@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_IkConstraint(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVIkConstraint@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_IkConstraint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVIkConstraint@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_IkConstraint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVIkConstraint@spine@@@spine@@QEAAPEAPEAVIkConstraint@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_IkConstraint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVIkConstraint@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_IkConstraint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVTransformConstraint@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVTransformConstraint@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVTransformConstraint@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVTransformConstraint@spine@@@spine@@QEAAX_KAEBQEAVTransformConstraint@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_TransformConstraint(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVTransformConstraint@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVTransformConstraint@spine@@@spine@@QEAAXAEBQEAVTransformConstraint@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVTransformConstraint@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVTransformConstraint@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVTransformConstraint@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVTransformConstraint@spine@@@spine@@QEAAAEAPEAVTransformConstraint@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVTransformConstraint@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVTransformConstraint@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_TransformConstraint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVTransformConstraint@spine@@@spine@@QEAAPEAPEAVTransformConstraint@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVTransformConstraint@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVPathConstraint@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_PathConstraint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVPathConstraint@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_PathConstraint(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVPathConstraint@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_PathConstraint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVPathConstraint@spine@@@spine@@QEAAX_KAEBQEAVPathConstraint@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_PathConstraint(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVPathConstraint@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_PathConstraint(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVPathConstraint@spine@@@spine@@QEAAXAEBQEAVPathConstraint@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_PathConstraint(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVPathConstraint@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_PathConstraint(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVPathConstraint@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_PathConstraint(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVPathConstraint@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_PathConstraint(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVPathConstraint@spine@@@spine@@QEAAAEAPEAVPathConstraint@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_PathConstraint(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVPathConstraint@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_PathConstraint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVPathConstraint@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_PathConstraint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVPathConstraint@spine@@@spine@@QEAAPEAPEAVPathConstraint@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_PathConstraint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVPathConstraint@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_PathConstraint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVUpdatable@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_Updatable(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVUpdatable@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_Updatable(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVUpdatable@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_Updatable(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVUpdatable@spine@@@spine@@QEAAX_KAEBQEAVUpdatable@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_Updatable(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVUpdatable@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_Updatable(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVUpdatable@spine@@@spine@@QEAAXAEBQEAVUpdatable@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_Updatable(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVUpdatable@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_Updatable(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVUpdatable@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Updatable(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVUpdatable@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_Updatable(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVUpdatable@spine@@@spine@@QEAAAEAPEAVUpdatable@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Updatable(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVUpdatable@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_Updatable(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVUpdatable@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_Updatable(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVUpdatable@spine@@@spine@@QEAAPEAPEAVUpdatable@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_Updatable(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVUpdatable@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_Updatable(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@H@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector__I(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@H@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector__I(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@H@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector__I(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@H@spine@@QEAAX_KAEBH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector__I(__IntPtr __instance, ulong newSize, int* defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@H@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector__I(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@H@spine@@QEAAXAEBH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector__I(__IntPtr __instance, int* inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@H@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector__I(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@H@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector__I(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@H@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector__I(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@H@spine@@QEAAAEAH_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int* OperatorSubscriptc__N_spine_S_Vector__I(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@H@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector__I(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@H@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector__I(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@H@spine@@QEAAPEAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int* Bufferc__N_spine_S_Vector__I(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@H@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector__I(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVTrackEntry@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_TrackEntry(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVTrackEntry@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_TrackEntry(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVTrackEntry@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_TrackEntry(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVTrackEntry@spine@@@spine@@QEAAX_KAEBQEAVTrackEntry@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_TrackEntry(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVTrackEntry@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_TrackEntry(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVTrackEntry@spine@@@spine@@QEAAXAEBQEAVTrackEntry@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_TrackEntry(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVTrackEntry@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_TrackEntry(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVTrackEntry@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_TrackEntry(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVTrackEntry@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_TrackEntry(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVTrackEntry@spine@@@spine@@QEAAAEAPEAVTrackEntry@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_TrackEntry(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVTrackEntry@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_TrackEntry(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVTrackEntry@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_TrackEntry(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVTrackEntry@spine@@@spine@@QEAAPEAPEAVTrackEntry@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_TrackEntry(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVTrackEntry@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_TrackEntry(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVAtlasPage@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_AtlasPage(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVAtlasPage@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_AtlasPage(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVAtlasPage@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_AtlasPage(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVAtlasPage@spine@@@spine@@QEAAX_KAEBQEAVAtlasPage@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_AtlasPage(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVAtlasPage@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_AtlasPage(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVAtlasPage@spine@@@spine@@QEAAXAEBQEAVAtlasPage@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_AtlasPage(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVAtlasPage@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_AtlasPage(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVAtlasPage@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_AtlasPage(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVAtlasPage@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_AtlasPage(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVAtlasPage@spine@@@spine@@QEAAAEAPEAVAtlasPage@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_AtlasPage(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVAtlasPage@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_AtlasPage(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVAtlasPage@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_AtlasPage(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVAtlasPage@spine@@@spine@@QEAAPEAPEAVAtlasPage@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_AtlasPage(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVAtlasPage@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_AtlasPage(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVAtlasRegion@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVAtlasRegion@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVAtlasRegion@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVAtlasRegion@spine@@@spine@@QEAAX_KAEBQEAVAtlasRegion@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_AtlasRegion(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVAtlasRegion@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVAtlasRegion@spine@@@spine@@QEAAXAEBQEAVAtlasRegion@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVAtlasRegion@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVAtlasRegion@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVAtlasRegion@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVAtlasRegion@spine@@@spine@@QEAAAEAPEAVAtlasRegion@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVAtlasRegion@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVAtlasRegion@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_AtlasRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVAtlasRegion@spine@@@spine@@QEAAPEAPEAVAtlasRegion@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVAtlasRegion@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVTextureRegion@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_TextureRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVTextureRegion@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_TextureRegion(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVTextureRegion@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_TextureRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVTextureRegion@spine@@@spine@@QEAAX_KAEBQEAVTextureRegion@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_TextureRegion(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVTextureRegion@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_TextureRegion(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVTextureRegion@spine@@@spine@@QEAAXAEBQEAVTextureRegion@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_TextureRegion(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVTextureRegion@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_TextureRegion(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVTextureRegion@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_TextureRegion(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVTextureRegion@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_TextureRegion(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVTextureRegion@spine@@@spine@@QEAAAEAPEAVTextureRegion@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_TextureRegion(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVTextureRegion@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_TextureRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVTextureRegion@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_TextureRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVTextureRegion@spine@@@spine@@QEAAPEAPEAVTextureRegion@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_TextureRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVTextureRegion@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_TextureRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@G@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector__s(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@G@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector__s(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@G@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector__s(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@G@spine@@QEAAX_KAEBG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector__s(__IntPtr __instance, ulong newSize, ushort* defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@G@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector__s(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@G@spine@@QEAAXAEBG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector__s(__IntPtr __instance, ushort* inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@G@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector__s(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@G@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector__s(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@G@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector__s(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@G@spine@@QEAAAEAG_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort* OperatorSubscriptc__N_spine_S_Vector__s(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@G@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector__s(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@G@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector__s(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@G@spine@@QEAAPEAGXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort* Bufferc__N_spine_S_Vector__s(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@G@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector__s(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@V?$Vector@M@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector____N_spine_S_Vector__f(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@V?$Vector@M@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector____N_spine_S_Vector__f(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@V?$Vector@M@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector____N_spine_S_Vector__f(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@V?$Vector@M@spine@@@spine@@QEAAX_KAEBV?$Vector@M@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector____N_spine_S_Vector__f(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@V?$Vector@M@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector____N_spine_S_Vector__f(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@V?$Vector@M@spine@@@spine@@QEAAXAEBV?$Vector@M@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector____N_spine_S_Vector__f(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@V?$Vector@M@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector____N_spine_S_Vector__f(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@V?$Vector@M@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector____N_spine_S_Vector__f(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@V?$Vector@M@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector____N_spine_S_Vector__f(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@V?$Vector@M@spine@@@spine@@QEAAAEAV?$Vector@M@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector____N_spine_S_Vector__f(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@V?$Vector@M@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector____N_spine_S_Vector__f(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@V?$Vector@M@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector____N_spine_S_Vector__f(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@V?$Vector@M@spine@@@spine@@QEAAPEAV?$Vector@M@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector____N_spine_S_Vector__f(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@V?$Vector@M@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector____N_spine_S_Vector__f(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@V?$Vector@H@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector____N_spine_S_Vector__I(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@V?$Vector@H@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector____N_spine_S_Vector__I(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@V?$Vector@H@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector____N_spine_S_Vector__I(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@V?$Vector@H@spine@@@spine@@QEAAX_KAEBV?$Vector@H@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector____N_spine_S_Vector__I(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@V?$Vector@H@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector____N_spine_S_Vector__I(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@V?$Vector@H@spine@@@spine@@QEAAXAEBV?$Vector@H@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector____N_spine_S_Vector__I(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@V?$Vector@H@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector____N_spine_S_Vector__I(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@V?$Vector@H@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector____N_spine_S_Vector__I(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@V?$Vector@H@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector____N_spine_S_Vector__I(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@V?$Vector@H@spine@@@spine@@QEAAAEAV?$Vector@H@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector____N_spine_S_Vector__I(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@V?$Vector@H@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector____N_spine_S_Vector__I(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@V?$Vector@H@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector____N_spine_S_Vector__I(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@V?$Vector@H@spine@@@spine@@QEAAPEAV?$Vector@H@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector____N_spine_S_Vector__I(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@V?$Vector@H@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector____N_spine_S_Vector__I(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVLinkedMesh@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVLinkedMesh@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVLinkedMesh@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVLinkedMesh@spine@@@spine@@QEAAX_KAEBQEAVLinkedMesh@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_LinkedMesh(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVLinkedMesh@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVLinkedMesh@spine@@@spine@@QEAAXAEBQEAVLinkedMesh@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVLinkedMesh@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVLinkedMesh@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVLinkedMesh@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVLinkedMesh@spine@@@spine@@QEAAAEAPEAVLinkedMesh@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVLinkedMesh@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVLinkedMesh@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_LinkedMesh(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVLinkedMesh@spine@@@spine@@QEAAPEAPEAVLinkedMesh@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVLinkedMesh@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVPolygon@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_Polygon(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVPolygon@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_Polygon(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVPolygon@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_Polygon(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVPolygon@spine@@@spine@@QEAAX_KAEBQEAVPolygon@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_Polygon(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVPolygon@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_Polygon(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVPolygon@spine@@@spine@@QEAAXAEBQEAVPolygon@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_Polygon(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVPolygon@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_Polygon(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVPolygon@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Polygon(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVPolygon@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_Polygon(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVPolygon@spine@@@spine@@QEAAAEAPEAVPolygon@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Polygon(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVPolygon@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_Polygon(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVPolygon@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_Polygon(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVPolygon@spine@@@spine@@QEAAPEAPEAVPolygon@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_Polygon(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVPolygon@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_Polygon(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVBoundingBoxAttachment@spine@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAVBoundingBoxAttachment@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAVBoundingBoxAttachment@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAVBoundingBoxAttachment@spine@@@spine@@QEAAX_KAEBQEAVBoundingBoxAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAVBoundingBoxAttachment@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAVBoundingBoxAttachment@spine@@@spine@@QEAAXAEBQEAVBoundingBoxAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAVBoundingBoxAttachment@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAVBoundingBoxAttachment@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAVBoundingBoxAttachment@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAVBoundingBoxAttachment@spine@@@spine@@QEAAAEAPEAVBoundingBoxAttachment@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAVBoundingBoxAttachment@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAVBoundingBoxAttachment@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAVBoundingBoxAttachment@spine@@@spine@@QEAAPEAPEAVBoundingBoxAttachment@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAVBoundingBoxAttachment@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAV?$Vector@M@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_Vector__f(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAV?$Vector@M@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clear1c__N_spine_S_Vector_____N_spine_S_Vector__f(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAV?$Vector@M@spine@@@spine@@QEAAX_KAEBQEAV?$Vector@M@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_Vector__f(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAV?$Vector@M@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacity1c__N_spine_S_Vector_____N_spine_S_Vector__f(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAV?$Vector@M@spine@@@spine@@QEAAXAEBQEAV?$Vector@M@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_Vector__f(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAV?$Vector@M@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_Vector__f(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAV?$Vector@M@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Vector__f(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAV?$Vector@M@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAt1c__N_spine_S_Vector_____N_spine_S_Vector__f(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAV?$Vector@M@spine@@@spine@@QEAAAEAPEAV?$Vector@M@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Vector__f(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAV?$Vector@M@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_Vector__f(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAV?$Vector@M@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_Vector__f(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAV?$Vector@M@spine@@@spine@@QEAAPEAPEAV?$Vector@M@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_Vector__f(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAV?$Vector@M@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_Vector__f(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@PEAV?$Vector@H@spine@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector_____N_spine_S_Vector__I(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@PEAV?$Vector@H@spine@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clear1c__N_spine_S_Vector_____N_spine_S_Vector__I(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@PEAV?$Vector@H@spine@@@spine@@QEAAX_KAEBQEAV?$Vector@H@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector_____N_spine_S_Vector__I(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@PEAV?$Vector@H@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacity1c__N_spine_S_Vector_____N_spine_S_Vector__I(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@PEAV?$Vector@H@spine@@@spine@@QEAAXAEBQEAV?$Vector@H@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector_____N_spine_S_Vector__I(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@PEAV?$Vector@H@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector_____N_spine_S_Vector__I(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@PEAV?$Vector@H@spine@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Vector__I(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@PEAV?$Vector@H@spine@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAt1c__N_spine_S_Vector_____N_spine_S_Vector__I(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@PEAV?$Vector@H@spine@@@spine@@QEAAAEAPEAV?$Vector@H@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Vector__I(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@PEAV?$Vector@H@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector_____N_spine_S_Vector__I(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@PEAV?$Vector@H@spine@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector_____N_spine_S_Vector__I(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@PEAV?$Vector@H@spine@@@spine@@QEAAPEAPEAV?$Vector@H@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector_____N_spine_S_Vector__I(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@PEAV?$Vector@H@spine@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector_____N_spine_S_Vector__I(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@_N@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector__b(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@_N@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector__b(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@_N@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector__b(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@_N@spine@@QEAAX_KAEB_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector__b(__IntPtr __instance, ulong newSize, bool* defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@_N@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector__b(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@_N@spine@@QEAAXAEB_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector__b(__IntPtr __instance, bool* inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@_N@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector__b(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@_N@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector__b(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@_N@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector__b(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@_N@spine@@QEAAAEA_N_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern bool* OperatorSubscriptc__N_spine_S_Vector__b(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@_N@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector__b(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@_N@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector__b(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@_N@spine@@QEAAPEA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern bool* Bufferc__N_spine_S_Vector__b(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@_N@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector__b(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@USubmeshInstruction@SpineUnity@@@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0?$Vector@USubmeshInstruction@SpineUnity@@@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__IntPtr __instance, __IntPtr inVector);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@?$Vector@USubmeshInstruction@SpineUnity@@@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSize@?$Vector@USubmeshInstruction@SpineUnity@@@spine@@QEAAX_KAEBUSubmeshInstruction@SpineUnity@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSizec__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__IntPtr __instance, ulong newSize, __IntPtr defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?ensureCapacity@?$Vector@USubmeshInstruction@SpineUnity@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnsureCapacityc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__IntPtr __instance, ulong newCapacity);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@?$Vector@USubmeshInstruction@SpineUnity@@@spine@@QEAAXAEBUSubmeshInstruction@SpineUnity@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Addc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAll@?$Vector@USubmeshInstruction@SpineUnity@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAllc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearAndAddAll@?$Vector@USubmeshInstruction@SpineUnity@@@spine@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAndAddAllc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAt@?$Vector@USubmeshInstruction@SpineUnity@@@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAtc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??A?$Vector@USubmeshInstruction@SpineUnity@@@spine@@QEAAAEAUSubmeshInstruction@SpineUnity@@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscriptc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__IntPtr __instance, ulong inIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCapacity@?$Vector@USubmeshInstruction@SpineUnity@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetCapacityc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?size@?$Vector@USubmeshInstruction@SpineUnity@@@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Sizec__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?buffer@?$Vector@USubmeshInstruction@SpineUnity@@@spine@@QEAAPEAUSubmeshInstruction@SpineUnity@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bufferc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?voidPBuffer@?$Vector@USubmeshInstruction@SpineUnity@@@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr VoidPBufferc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__IntPtr __instance);
            }
        }

        public unsafe partial class Vector<T> : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            internal static new Vector<T> __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Vector<T>(native.ToPointer(), skipVTables);
            }

            internal static new Vector<T> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Vector<T>)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Vector<T> __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Vector<T>)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Vector<T> __CreateInstance(global::spine_cpp.Spine.Vector.__Internal native, bool skipVTables = false)
            {
                return new Vector<T>(native, skipVTables);
            }

            private static void* __CopyValue(global::spine_cpp.Spine.Vector.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector__K(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Vector(global::spine_cpp.Spine.Vector.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Vector(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Vector()
                : this((void*) null)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(long)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector__K(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(float)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector__f(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoneData)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_BoneData(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SlotData)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_SlotData(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Skin)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_Skin(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SkinEntry)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector____N_spine_S_SkinEntry(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.ConstraintData)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_ConstraintData(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.String)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector____N_spine_S_String(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Attachment)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_Attachment(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.EventData)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_EventData(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Animation)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_Animation(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Timeline)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_Timeline(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Event)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_Event(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraintData)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraintData)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraintData)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.FullName == "System.IntPtr")
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector___C(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Bone)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_Bone(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Slot)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_Slot(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraint)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_IkConstraint(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraint)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraint)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_PathConstraint(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Updatable)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_Updatable(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector__I(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TrackEntry)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_TrackEntry(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasPage)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_AtlasPage(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasRegion)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TextureRegion)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_TextureRegion(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(ushort)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector__s(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector____N_spine_S_Vector__f(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector____N_spine_S_Vector__I(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.LinkedMesh)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Polygon)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_Polygon(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoundingBoxAttachment)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Vector<float>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Vector<int>>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector__b(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.SpineUnity.SubmeshInstruction)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::spine_cpp.Spine.Vector.__Internal.ctorc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::spine_cpp.Spine.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <long>, <float>, <global::spine_cpp.Spine.BoneData>, <global::spine_cpp.Spine.SlotData>, <global::spine_cpp.Spine.Skin>, <global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>>, <global::spine_cpp.Spine.SkinEntry>, <global::spine_cpp.Spine.ConstraintData>, <global::spine_cpp.Spine.String>, <global::spine_cpp.Spine.Attachment>, <global::spine_cpp.Spine.EventData>, <global::spine_cpp.Spine.Animation>, <global::spine_cpp.Spine.Timeline>, <global::spine_cpp.Spine.Event>, <global::spine_cpp.Spine.IkConstraintData>, <global::spine_cpp.Spine.TransformConstraintData>, <global::spine_cpp.Spine.PathConstraintData>, <CppSharp.Runtime.Pointer<sbyte>>, <global::spine_cpp.Spine.Bone>, <global::spine_cpp.Spine.Slot>, <global::spine_cpp.Spine.IkConstraint>, <global::spine_cpp.Spine.TransformConstraint>, <global::spine_cpp.Spine.PathConstraint>, <global::spine_cpp.Spine.Updatable>, <int>, <global::spine_cpp.Spine.TrackEntry>, <global::spine_cpp.Spine.EventQueueEntry>, <global::spine_cpp.Spine.AtlasPage>, <global::spine_cpp.Spine.AtlasRegion>, <global::spine_cpp.Spine.TextureRegion>, <ushort>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <global::spine_cpp.Spine.LinkedMesh>, <global::spine_cpp.Spine.Polygon>, <global::spine_cpp.Spine.BoundingBoxAttachment>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <bool>, <global::spine_cpp.SpineUnity.SubmeshInstruction>.");
            }

            public Vector(global::spine_cpp.Spine.Vector<T> inVector)
                : this((void*) null)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(long)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector__K(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(float)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector__f(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoneData)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_BoneData(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SlotData)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_SlotData(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Skin)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_Skin(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SkinEntry)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector____N_spine_S_SkinEntry(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.ConstraintData)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_ConstraintData(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.String)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector____N_spine_S_String(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Attachment)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_Attachment(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.EventData)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_EventData(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Animation)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_Animation(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Timeline)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_Timeline(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Event)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_Event(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraintData)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraintData)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraintData)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.FullName == "System.IntPtr")
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector___C(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Bone)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_Bone(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Slot)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_Slot(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraint)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_IkConstraint(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraint)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraint)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_PathConstraint(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Updatable)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_Updatable(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector__I(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TrackEntry)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_TrackEntry(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasPage)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_AtlasPage(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasRegion)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TextureRegion)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_TextureRegion(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(ushort)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector__s(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector____N_spine_S_Vector__f(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector____N_spine_S_Vector__I(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.LinkedMesh)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Polygon)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_Polygon(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoundingBoxAttachment)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_Vector__f(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector_____N_spine_S_Vector__I(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector__b(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.SpineUnity.SubmeshInstruction)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vector.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(inVector, null))
                        throw new global::System.ArgumentNullException("inVector", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inVector.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Vector");
                    return;
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::spine_cpp.Spine.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <long>, <float>, <global::spine_cpp.Spine.BoneData>, <global::spine_cpp.Spine.SlotData>, <global::spine_cpp.Spine.Skin>, <global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>>, <global::spine_cpp.Spine.SkinEntry>, <global::spine_cpp.Spine.ConstraintData>, <global::spine_cpp.Spine.String>, <global::spine_cpp.Spine.Attachment>, <global::spine_cpp.Spine.EventData>, <global::spine_cpp.Spine.Animation>, <global::spine_cpp.Spine.Timeline>, <global::spine_cpp.Spine.Event>, <global::spine_cpp.Spine.IkConstraintData>, <global::spine_cpp.Spine.TransformConstraintData>, <global::spine_cpp.Spine.PathConstraintData>, <CppSharp.Runtime.Pointer<sbyte>>, <global::spine_cpp.Spine.Bone>, <global::spine_cpp.Spine.Slot>, <global::spine_cpp.Spine.IkConstraint>, <global::spine_cpp.Spine.TransformConstraint>, <global::spine_cpp.Spine.PathConstraint>, <global::spine_cpp.Spine.Updatable>, <int>, <global::spine_cpp.Spine.TrackEntry>, <global::spine_cpp.Spine.EventQueueEntry>, <global::spine_cpp.Spine.AtlasPage>, <global::spine_cpp.Spine.AtlasRegion>, <global::spine_cpp.Spine.TextureRegion>, <ushort>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <global::spine_cpp.Spine.LinkedMesh>, <global::spine_cpp.Spine.Polygon>, <global::spine_cpp.Spine.BoundingBoxAttachment>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <bool>, <global::spine_cpp.SpineUnity.SubmeshInstruction>.");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(long)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(float)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 1);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoneData)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 2);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SlotData)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 3);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Skin)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 4);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 5);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SkinEntry)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 6);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.ConstraintData)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 7);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.String)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 8);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Attachment)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 9);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.EventData)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 10);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Animation)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 11);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Timeline)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 12);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Event)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 13);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraintData)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 14);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraintData)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 15);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraintData)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 16);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.FullName == "System.IntPtr")
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 17);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Bone)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 18);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Slot)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 19);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraint)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 20);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraint)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 21);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraint)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 22);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Updatable)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 23);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 25);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TrackEntry)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 26);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasPage)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 28);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasRegion)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 29);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TextureRegion)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 30);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(ushort)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 31);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 32);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 33);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.LinkedMesh)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 34);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Polygon)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 35);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoundingBoxAttachment)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 36);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 37);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 38);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 39);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.SpineUnity.SubmeshInstruction)))
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0, 40);
                        ___dtorDelegate(__Instance, 0);
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::spine_cpp.Spine.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <long>, <float>, <global::spine_cpp.Spine.BoneData>, <global::spine_cpp.Spine.SlotData>, <global::spine_cpp.Spine.Skin>, <global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>>, <global::spine_cpp.Spine.SkinEntry>, <global::spine_cpp.Spine.ConstraintData>, <global::spine_cpp.Spine.String>, <global::spine_cpp.Spine.Attachment>, <global::spine_cpp.Spine.EventData>, <global::spine_cpp.Spine.Animation>, <global::spine_cpp.Spine.Timeline>, <global::spine_cpp.Spine.Event>, <global::spine_cpp.Spine.IkConstraintData>, <global::spine_cpp.Spine.TransformConstraintData>, <global::spine_cpp.Spine.PathConstraintData>, <CppSharp.Runtime.Pointer<sbyte>>, <global::spine_cpp.Spine.Bone>, <global::spine_cpp.Spine.Slot>, <global::spine_cpp.Spine.IkConstraint>, <global::spine_cpp.Spine.TransformConstraint>, <global::spine_cpp.Spine.PathConstraint>, <global::spine_cpp.Spine.Updatable>, <int>, <global::spine_cpp.Spine.TrackEntry>, <global::spine_cpp.Spine.EventQueueEntry>, <global::spine_cpp.Spine.AtlasPage>, <global::spine_cpp.Spine.AtlasRegion>, <global::spine_cpp.Spine.TextureRegion>, <ushort>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <global::spine_cpp.Spine.LinkedMesh>, <global::spine_cpp.Spine.Polygon>, <global::spine_cpp.Spine.BoundingBoxAttachment>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <bool>, <global::spine_cpp.SpineUnity.SubmeshInstruction>.");
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Clear()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(long)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector__K(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(float)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector__f(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoneData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_BoneData(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SlotData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_SlotData(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Skin)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_Skin(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SkinEntry)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector____N_spine_S_SkinEntry(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.ConstraintData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_ConstraintData(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.String)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector____N_spine_S_String(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Attachment)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_Attachment(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.EventData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_EventData(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Animation)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_Animation(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Timeline)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_Timeline(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Event)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_Event(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraintData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraintData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraintData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__Instance);
                    return;
                }
                if (__T.FullName == "System.IntPtr")
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector___C(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Bone)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_Bone(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Slot)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_Slot(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraint)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_IkConstraint(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraint)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraint)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_PathConstraint(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Updatable)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_Updatable(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector__I(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TrackEntry)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_TrackEntry(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasPage)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_AtlasPage(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasRegion)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TextureRegion)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_TextureRegion(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(ushort)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector__s(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector____N_spine_S_Vector__f(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector____N_spine_S_Vector__I(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.LinkedMesh)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Polygon)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_Polygon(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoundingBoxAttachment)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clear1c__N_spine_S_Vector_____N_spine_S_Vector__f(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clear1c__N_spine_S_Vector_____N_spine_S_Vector__I(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector__b(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.SpineUnity.SubmeshInstruction)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.Clearc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__Instance);
                    return;
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::spine_cpp.Spine.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <long>, <float>, <global::spine_cpp.Spine.BoneData>, <global::spine_cpp.Spine.SlotData>, <global::spine_cpp.Spine.Skin>, <global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>>, <global::spine_cpp.Spine.SkinEntry>, <global::spine_cpp.Spine.ConstraintData>, <global::spine_cpp.Spine.String>, <global::spine_cpp.Spine.Attachment>, <global::spine_cpp.Spine.EventData>, <global::spine_cpp.Spine.Animation>, <global::spine_cpp.Spine.Timeline>, <global::spine_cpp.Spine.Event>, <global::spine_cpp.Spine.IkConstraintData>, <global::spine_cpp.Spine.TransformConstraintData>, <global::spine_cpp.Spine.PathConstraintData>, <CppSharp.Runtime.Pointer<sbyte>>, <global::spine_cpp.Spine.Bone>, <global::spine_cpp.Spine.Slot>, <global::spine_cpp.Spine.IkConstraint>, <global::spine_cpp.Spine.TransformConstraint>, <global::spine_cpp.Spine.PathConstraint>, <global::spine_cpp.Spine.Updatable>, <int>, <global::spine_cpp.Spine.TrackEntry>, <global::spine_cpp.Spine.EventQueueEntry>, <global::spine_cpp.Spine.AtlasPage>, <global::spine_cpp.Spine.AtlasRegion>, <global::spine_cpp.Spine.TextureRegion>, <ushort>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <global::spine_cpp.Spine.LinkedMesh>, <global::spine_cpp.Spine.Polygon>, <global::spine_cpp.Spine.BoundingBoxAttachment>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <bool>, <global::spine_cpp.SpineUnity.SubmeshInstruction>.");
            }

            public void EnsureCapacity(ulong newCapacity)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(long)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector__K(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(float)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector__f(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoneData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_BoneData(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SlotData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_SlotData(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Skin)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_Skin(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SkinEntry)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector____N_spine_S_SkinEntry(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.ConstraintData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_ConstraintData(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.String)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector____N_spine_S_String(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Attachment)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_Attachment(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.EventData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_EventData(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Animation)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_Animation(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Timeline)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_Timeline(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Event)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_Event(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraintData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraintData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraintData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__Instance, newCapacity);
                    return;
                }
                if (__T.FullName == "System.IntPtr")
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector___C(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Bone)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_Bone(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Slot)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_Slot(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraint)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_IkConstraint(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraint)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraint)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_PathConstraint(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Updatable)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_Updatable(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector__I(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TrackEntry)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_TrackEntry(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasPage)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_AtlasPage(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasRegion)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TextureRegion)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_TextureRegion(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(ushort)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector__s(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector____N_spine_S_Vector__f(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector____N_spine_S_Vector__I(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.LinkedMesh)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Polygon)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_Polygon(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoundingBoxAttachment)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacity1c__N_spine_S_Vector_____N_spine_S_Vector__f(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacity1c__N_spine_S_Vector_____N_spine_S_Vector__I(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector__b(__Instance, newCapacity);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.SpineUnity.SubmeshInstruction)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.EnsureCapacityc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__Instance, newCapacity);
                    return;
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::spine_cpp.Spine.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <long>, <float>, <global::spine_cpp.Spine.BoneData>, <global::spine_cpp.Spine.SlotData>, <global::spine_cpp.Spine.Skin>, <global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>>, <global::spine_cpp.Spine.SkinEntry>, <global::spine_cpp.Spine.ConstraintData>, <global::spine_cpp.Spine.String>, <global::spine_cpp.Spine.Attachment>, <global::spine_cpp.Spine.EventData>, <global::spine_cpp.Spine.Animation>, <global::spine_cpp.Spine.Timeline>, <global::spine_cpp.Spine.Event>, <global::spine_cpp.Spine.IkConstraintData>, <global::spine_cpp.Spine.TransformConstraintData>, <global::spine_cpp.Spine.PathConstraintData>, <CppSharp.Runtime.Pointer<sbyte>>, <global::spine_cpp.Spine.Bone>, <global::spine_cpp.Spine.Slot>, <global::spine_cpp.Spine.IkConstraint>, <global::spine_cpp.Spine.TransformConstraint>, <global::spine_cpp.Spine.PathConstraint>, <global::spine_cpp.Spine.Updatable>, <int>, <global::spine_cpp.Spine.TrackEntry>, <global::spine_cpp.Spine.EventQueueEntry>, <global::spine_cpp.Spine.AtlasPage>, <global::spine_cpp.Spine.AtlasRegion>, <global::spine_cpp.Spine.TextureRegion>, <ushort>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <global::spine_cpp.Spine.LinkedMesh>, <global::spine_cpp.Spine.Polygon>, <global::spine_cpp.Spine.BoundingBoxAttachment>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <bool>, <global::spine_cpp.SpineUnity.SubmeshInstruction>.");
            }

            public void AddAll(global::spine_cpp.Spine.Vector<T> inValue)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(long)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector__K(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(float)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector__f(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoneData)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_BoneData(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SlotData)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_SlotData(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Skin)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_Skin(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SkinEntry)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector____N_spine_S_SkinEntry(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.ConstraintData)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_ConstraintData(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.String)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector____N_spine_S_String(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Attachment)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_Attachment(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.EventData)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_EventData(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Animation)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_Animation(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Timeline)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_Timeline(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Event)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_Event(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraintData)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraintData)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraintData)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__Instance, __arg0);
                    return;
                }
                if (__T.FullName == "System.IntPtr")
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector___C(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Bone)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_Bone(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Slot)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_Slot(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraint)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_IkConstraint(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraint)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraint)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_PathConstraint(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Updatable)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_Updatable(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector__I(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TrackEntry)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_TrackEntry(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasPage)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_AtlasPage(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasRegion)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TextureRegion)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_TextureRegion(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(ushort)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector__s(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector____N_spine_S_Vector__f(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector____N_spine_S_Vector__I(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.LinkedMesh)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Polygon)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_Polygon(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoundingBoxAttachment)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_Vector__f(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector_____N_spine_S_Vector__I(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector__b(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.SpineUnity.SubmeshInstruction)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.AddAllc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__Instance, __arg0);
                    return;
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::spine_cpp.Spine.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <long>, <float>, <global::spine_cpp.Spine.BoneData>, <global::spine_cpp.Spine.SlotData>, <global::spine_cpp.Spine.Skin>, <global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>>, <global::spine_cpp.Spine.SkinEntry>, <global::spine_cpp.Spine.ConstraintData>, <global::spine_cpp.Spine.String>, <global::spine_cpp.Spine.Attachment>, <global::spine_cpp.Spine.EventData>, <global::spine_cpp.Spine.Animation>, <global::spine_cpp.Spine.Timeline>, <global::spine_cpp.Spine.Event>, <global::spine_cpp.Spine.IkConstraintData>, <global::spine_cpp.Spine.TransformConstraintData>, <global::spine_cpp.Spine.PathConstraintData>, <CppSharp.Runtime.Pointer<sbyte>>, <global::spine_cpp.Spine.Bone>, <global::spine_cpp.Spine.Slot>, <global::spine_cpp.Spine.IkConstraint>, <global::spine_cpp.Spine.TransformConstraint>, <global::spine_cpp.Spine.PathConstraint>, <global::spine_cpp.Spine.Updatable>, <int>, <global::spine_cpp.Spine.TrackEntry>, <global::spine_cpp.Spine.EventQueueEntry>, <global::spine_cpp.Spine.AtlasPage>, <global::spine_cpp.Spine.AtlasRegion>, <global::spine_cpp.Spine.TextureRegion>, <ushort>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <global::spine_cpp.Spine.LinkedMesh>, <global::spine_cpp.Spine.Polygon>, <global::spine_cpp.Spine.BoundingBoxAttachment>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <bool>, <global::spine_cpp.SpineUnity.SubmeshInstruction>.");
            }

            public void ClearAndAddAll(global::spine_cpp.Spine.Vector<T> inValue)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(long)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector__K(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(float)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector__f(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoneData)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_BoneData(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SlotData)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_SlotData(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Skin)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Skin(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SkinEntry)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector____N_spine_S_SkinEntry(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.ConstraintData)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_ConstraintData(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.String)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector____N_spine_S_String(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Attachment)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Attachment(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.EventData)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_EventData(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Animation)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Animation(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Timeline)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Timeline(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Event)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Event(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraintData)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraintData)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraintData)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__Instance, __arg0);
                    return;
                }
                if (__T.FullName == "System.IntPtr")
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector___C(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Bone)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Bone(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Slot)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Slot(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraint)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_IkConstraint(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraint)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraint)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_PathConstraint(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Updatable)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Updatable(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector__I(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TrackEntry)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_TrackEntry(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasPage)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_AtlasPage(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasRegion)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TextureRegion)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_TextureRegion(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(ushort)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector__s(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector____N_spine_S_Vector__f(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector____N_spine_S_Vector__I(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.LinkedMesh)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Polygon)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Polygon(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoundingBoxAttachment)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Vector__f(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector_____N_spine_S_Vector__I(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector__b(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.SpineUnity.SubmeshInstruction)))
                {
                    if (ReferenceEquals(inValue, null))
                        throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = inValue.__Instance;
                    global::spine_cpp.Spine.Vector.__Internal.ClearAndAddAllc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__Instance, __arg0);
                    return;
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::spine_cpp.Spine.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <long>, <float>, <global::spine_cpp.Spine.BoneData>, <global::spine_cpp.Spine.SlotData>, <global::spine_cpp.Spine.Skin>, <global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>>, <global::spine_cpp.Spine.SkinEntry>, <global::spine_cpp.Spine.ConstraintData>, <global::spine_cpp.Spine.String>, <global::spine_cpp.Spine.Attachment>, <global::spine_cpp.Spine.EventData>, <global::spine_cpp.Spine.Animation>, <global::spine_cpp.Spine.Timeline>, <global::spine_cpp.Spine.Event>, <global::spine_cpp.Spine.IkConstraintData>, <global::spine_cpp.Spine.TransformConstraintData>, <global::spine_cpp.Spine.PathConstraintData>, <CppSharp.Runtime.Pointer<sbyte>>, <global::spine_cpp.Spine.Bone>, <global::spine_cpp.Spine.Slot>, <global::spine_cpp.Spine.IkConstraint>, <global::spine_cpp.Spine.TransformConstraint>, <global::spine_cpp.Spine.PathConstraint>, <global::spine_cpp.Spine.Updatable>, <int>, <global::spine_cpp.Spine.TrackEntry>, <global::spine_cpp.Spine.EventQueueEntry>, <global::spine_cpp.Spine.AtlasPage>, <global::spine_cpp.Spine.AtlasRegion>, <global::spine_cpp.Spine.TextureRegion>, <ushort>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <global::spine_cpp.Spine.LinkedMesh>, <global::spine_cpp.Spine.Polygon>, <global::spine_cpp.Spine.BoundingBoxAttachment>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <bool>, <global::spine_cpp.SpineUnity.SubmeshInstruction>.");
            }

            public void RemoveAt(ulong inIndex)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(long)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector__K(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(float)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector__f(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoneData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_BoneData(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SlotData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_SlotData(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Skin)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_Skin(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SkinEntry)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector____N_spine_S_SkinEntry(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.ConstraintData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_ConstraintData(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.String)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector____N_spine_S_String(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Attachment)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_Attachment(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.EventData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_EventData(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Animation)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_Animation(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Timeline)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_Timeline(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Event)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_Event(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraintData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraintData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraintData)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__Instance, inIndex);
                    return;
                }
                if (__T.FullName == "System.IntPtr")
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector___C(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Bone)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_Bone(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Slot)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_Slot(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraint)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_IkConstraint(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraint)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraint)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_PathConstraint(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Updatable)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_Updatable(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector__I(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TrackEntry)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_TrackEntry(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasPage)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_AtlasPage(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasRegion)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TextureRegion)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_TextureRegion(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(ushort)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector__s(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector____N_spine_S_Vector__f(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector____N_spine_S_Vector__I(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.LinkedMesh)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Polygon)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_Polygon(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoundingBoxAttachment)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAt1c__N_spine_S_Vector_____N_spine_S_Vector__f(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAt1c__N_spine_S_Vector_____N_spine_S_Vector__I(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector__b(__Instance, inIndex);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::spine_cpp.SpineUnity.SubmeshInstruction)))
                {
                    global::spine_cpp.Spine.Vector.__Internal.RemoveAtc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__Instance, inIndex);
                    return;
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::spine_cpp.Spine.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <long>, <float>, <global::spine_cpp.Spine.BoneData>, <global::spine_cpp.Spine.SlotData>, <global::spine_cpp.Spine.Skin>, <global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>>, <global::spine_cpp.Spine.SkinEntry>, <global::spine_cpp.Spine.ConstraintData>, <global::spine_cpp.Spine.String>, <global::spine_cpp.Spine.Attachment>, <global::spine_cpp.Spine.EventData>, <global::spine_cpp.Spine.Animation>, <global::spine_cpp.Spine.Timeline>, <global::spine_cpp.Spine.Event>, <global::spine_cpp.Spine.IkConstraintData>, <global::spine_cpp.Spine.TransformConstraintData>, <global::spine_cpp.Spine.PathConstraintData>, <CppSharp.Runtime.Pointer<sbyte>>, <global::spine_cpp.Spine.Bone>, <global::spine_cpp.Spine.Slot>, <global::spine_cpp.Spine.IkConstraint>, <global::spine_cpp.Spine.TransformConstraint>, <global::spine_cpp.Spine.PathConstraint>, <global::spine_cpp.Spine.Updatable>, <int>, <global::spine_cpp.Spine.TrackEntry>, <global::spine_cpp.Spine.EventQueueEntry>, <global::spine_cpp.Spine.AtlasPage>, <global::spine_cpp.Spine.AtlasRegion>, <global::spine_cpp.Spine.TextureRegion>, <ushort>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <global::spine_cpp.Spine.LinkedMesh>, <global::spine_cpp.Spine.Polygon>, <global::spine_cpp.Spine.BoundingBoxAttachment>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <bool>, <global::spine_cpp.SpineUnity.SubmeshInstruction>.");
            }

            public T this[ulong inIndex]
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(long)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector__K(__Instance, inIndex);
                        return (T) (object) *___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(float)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector__f(__Instance, inIndex);
                        return (T) (object) *___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoneData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_BoneData(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.BoneData.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SlotData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_SlotData(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.SlotData.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Skin)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Skin(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__Instance, inIndex);
                        var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>.__GetOrCreateInstance(___ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SkinEntry)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector____N_spine_S_SkinEntry(__Instance, inIndex);
                        var __result0 = global::spine_cpp.Spine.SkinEntry.__GetOrCreateInstance(___ret, false);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.ConstraintData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_ConstraintData(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.ConstraintData.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.String)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector____N_spine_S_String(__Instance, inIndex);
                        var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Attachment)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Attachment(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.EventData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_EventData(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.EventData.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Animation)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Animation(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.Animation.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Timeline)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Timeline(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.Timeline.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Event)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Event(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.Event.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraintData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.IkConstraintData.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraintData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.TransformConstraintData.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraintData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.PathConstraintData.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.FullName == "System.IntPtr")
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector___C(__Instance, inIndex);
                        return (T) (object) (__IntPtr) ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Bone)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Bone(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.Bone.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Slot)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Slot(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraint)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_IkConstraint(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.IkConstraint.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraint)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.TransformConstraint.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraint)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_PathConstraint(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.PathConstraint.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Updatable)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Updatable(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.Updatable.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector__I(__Instance, inIndex);
                        return (T) (object) *___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TrackEntry)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_TrackEntry(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasPage)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_AtlasPage(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.AtlasPage.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasRegion)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.AtlasRegion.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TextureRegion)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_TextureRegion(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.TextureRegion.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(ushort)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector__s(__Instance, inIndex);
                        return (T) (object) *___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector____N_spine_S_Vector__f(__Instance, inIndex);
                        var __result0 = global::spine_cpp.Spine.Vector<float>.__GetOrCreateInstance(___ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector____N_spine_S_Vector__I(__Instance, inIndex);
                        var __result0 = global::spine_cpp.Spine.Vector<int>.__GetOrCreateInstance(___ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.LinkedMesh)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.LinkedMesh.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Polygon)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Polygon(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.Polygon.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoundingBoxAttachment)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.BoundingBoxAttachment.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Vector__f(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.Vector<float>.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Vector__I(__Instance, inIndex);
                        __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                        var __result0 = global::spine_cpp.Spine.Vector<int>.__GetOrCreateInstance(_____ret, true);
                        return (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector__b(__Instance, inIndex);
                        return (T) (object) *___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.SpineUnity.SubmeshInstruction)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__Instance, inIndex);
                        var __result0 = global::spine_cpp.SpineUnity.SubmeshInstruction.__GetOrCreateInstance(___ret, false);
                        return (T) (object) __result0;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::spine_cpp.Spine.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <long>, <float>, <global::spine_cpp.Spine.BoneData>, <global::spine_cpp.Spine.SlotData>, <global::spine_cpp.Spine.Skin>, <global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>>, <global::spine_cpp.Spine.SkinEntry>, <global::spine_cpp.Spine.ConstraintData>, <global::spine_cpp.Spine.String>, <global::spine_cpp.Spine.Attachment>, <global::spine_cpp.Spine.EventData>, <global::spine_cpp.Spine.Animation>, <global::spine_cpp.Spine.Timeline>, <global::spine_cpp.Spine.Event>, <global::spine_cpp.Spine.IkConstraintData>, <global::spine_cpp.Spine.TransformConstraintData>, <global::spine_cpp.Spine.PathConstraintData>, <CppSharp.Runtime.Pointer<sbyte>>, <global::spine_cpp.Spine.Bone>, <global::spine_cpp.Spine.Slot>, <global::spine_cpp.Spine.IkConstraint>, <global::spine_cpp.Spine.TransformConstraint>, <global::spine_cpp.Spine.PathConstraint>, <global::spine_cpp.Spine.Updatable>, <int>, <global::spine_cpp.Spine.TrackEntry>, <global::spine_cpp.Spine.EventQueueEntry>, <global::spine_cpp.Spine.AtlasPage>, <global::spine_cpp.Spine.AtlasRegion>, <global::spine_cpp.Spine.TextureRegion>, <ushort>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <global::spine_cpp.Spine.LinkedMesh>, <global::spine_cpp.Spine.Polygon>, <global::spine_cpp.Spine.BoundingBoxAttachment>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <bool>, <global::spine_cpp.SpineUnity.SubmeshInstruction>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(long)))
                    {
                        *global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector__K(__Instance, inIndex) = (long) (object) value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(float)))
                    {
                        *global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector__f(__Instance, inIndex) = (float) (object) value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoneData)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_BoneData(__Instance, inIndex) = ((global::spine_cpp.Spine.BoneData) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.BoneData) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SlotData)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_SlotData(__Instance, inIndex) = ((global::spine_cpp.Spine.SlotData) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.SlotData) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Skin)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Skin(__Instance, inIndex) = ((global::spine_cpp.Spine.Skin) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.Skin) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector____N_spine_S_SkinEntry(global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__Instance, inIndex), ((global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>) (object) value).__Instance);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SkinEntry)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        global::spine_cpp.Spine.SkinEntry.__Internal.cctor(global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector____N_spine_S_SkinEntry(__Instance, inIndex), ((global::spine_cpp.Spine.SkinEntry) (object) value).__Instance);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.ConstraintData)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_ConstraintData(__Instance, inIndex) = ((global::spine_cpp.Spine.ConstraintData) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.ConstraintData) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.String)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        global::spine_cpp.Spine.String.__Internal.cctor(global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector____N_spine_S_String(__Instance, inIndex), ((global::spine_cpp.Spine.String) (object) value).__Instance);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Attachment)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Attachment(__Instance, inIndex) = ((global::spine_cpp.Spine.Attachment) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.Attachment) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.EventData)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_EventData(__Instance, inIndex) = ((global::spine_cpp.Spine.EventData) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.EventData) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Animation)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Animation(__Instance, inIndex) = ((global::spine_cpp.Spine.Animation) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.Animation) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Timeline)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Timeline(__Instance, inIndex) = ((global::spine_cpp.Spine.Timeline) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.Timeline) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Event)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Event(__Instance, inIndex) = ((global::spine_cpp.Spine.Event) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.Event) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraintData)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__Instance, inIndex) = ((global::spine_cpp.Spine.IkConstraintData) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.IkConstraintData) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraintData)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__Instance, inIndex) = ((global::spine_cpp.Spine.TransformConstraintData) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.TransformConstraintData) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraintData)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__Instance, inIndex) = ((global::spine_cpp.Spine.PathConstraintData) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.PathConstraintData) (object) value).__Instance;
                        return;
                    }
                    if (__T.FullName == "System.IntPtr")
                    {
                        *(sbyte**) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector___C(__Instance, inIndex) = (sbyte*) (__IntPtr) (object) value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Bone)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Bone(__Instance, inIndex) = ((global::spine_cpp.Spine.Bone) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.Bone) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Slot)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Slot(__Instance, inIndex) = ((global::spine_cpp.Spine.Slot) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.Slot) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraint)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_IkConstraint(__Instance, inIndex) = ((global::spine_cpp.Spine.IkConstraint) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.IkConstraint) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraint)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__Instance, inIndex) = ((global::spine_cpp.Spine.TransformConstraint) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.TransformConstraint) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraint)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_PathConstraint(__Instance, inIndex) = ((global::spine_cpp.Spine.PathConstraint) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.PathConstraint) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Updatable)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Updatable(__Instance, inIndex) = ((global::spine_cpp.Spine.Updatable) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.Updatable) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        *global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector__I(__Instance, inIndex) = (int) (object) value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TrackEntry)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_TrackEntry(__Instance, inIndex) = ((global::spine_cpp.Spine.TrackEntry) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.TrackEntry) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasPage)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_AtlasPage(__Instance, inIndex) = ((global::spine_cpp.Spine.AtlasPage) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.AtlasPage) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasRegion)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__Instance, inIndex) = ((global::spine_cpp.Spine.AtlasRegion) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.AtlasRegion) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TextureRegion)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_TextureRegion(__Instance, inIndex) = ((global::spine_cpp.Spine.TextureRegion) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.TextureRegion) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(ushort)))
                    {
                        *global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector__s(__Instance, inIndex) = (ushort) (object) value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector__f(global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector____N_spine_S_Vector__f(__Instance, inIndex), ((global::spine_cpp.Spine.Vector<float>) (object) value).__Instance);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        global::spine_cpp.Spine.Vector.__Internal.cctorc__N_spine_S_Vector__I(global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector____N_spine_S_Vector__I(__Instance, inIndex), ((global::spine_cpp.Spine.Vector<int>) (object) value).__Instance);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.LinkedMesh)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__Instance, inIndex) = ((global::spine_cpp.Spine.LinkedMesh) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.LinkedMesh) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Polygon)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Polygon(__Instance, inIndex) = ((global::spine_cpp.Spine.Polygon) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.Polygon) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoundingBoxAttachment)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__Instance, inIndex) = ((global::spine_cpp.Spine.BoundingBoxAttachment) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.BoundingBoxAttachment) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Vector__f(__Instance, inIndex) = ((global::spine_cpp.Spine.Vector<float>) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.Vector<float>) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                    {
                        *(__IntPtr*) global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector_____N_spine_S_Vector__I(__Instance, inIndex) = ((global::spine_cpp.Spine.Vector<int>) (object) value) is null ? __IntPtr.Zero : ((global::spine_cpp.Spine.Vector<int>) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        *global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector__b(__Instance, inIndex) = (bool) (object) value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.SpineUnity.SubmeshInstruction)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        global::spine_cpp.SpineUnity.SubmeshInstruction.__Internal.cctor(global::spine_cpp.Spine.Vector.__Internal.OperatorSubscriptc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__Instance, inIndex), ((global::spine_cpp.SpineUnity.SubmeshInstruction) (object) value).__Instance);
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::spine_cpp.Spine.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <long>, <float>, <global::spine_cpp.Spine.BoneData>, <global::spine_cpp.Spine.SlotData>, <global::spine_cpp.Spine.Skin>, <global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>>, <global::spine_cpp.Spine.SkinEntry>, <global::spine_cpp.Spine.ConstraintData>, <global::spine_cpp.Spine.String>, <global::spine_cpp.Spine.Attachment>, <global::spine_cpp.Spine.EventData>, <global::spine_cpp.Spine.Animation>, <global::spine_cpp.Spine.Timeline>, <global::spine_cpp.Spine.Event>, <global::spine_cpp.Spine.IkConstraintData>, <global::spine_cpp.Spine.TransformConstraintData>, <global::spine_cpp.Spine.PathConstraintData>, <CppSharp.Runtime.Pointer<sbyte>>, <global::spine_cpp.Spine.Bone>, <global::spine_cpp.Spine.Slot>, <global::spine_cpp.Spine.IkConstraint>, <global::spine_cpp.Spine.TransformConstraint>, <global::spine_cpp.Spine.PathConstraint>, <global::spine_cpp.Spine.Updatable>, <int>, <global::spine_cpp.Spine.TrackEntry>, <global::spine_cpp.Spine.EventQueueEntry>, <global::spine_cpp.Spine.AtlasPage>, <global::spine_cpp.Spine.AtlasRegion>, <global::spine_cpp.Spine.TextureRegion>, <ushort>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <global::spine_cpp.Spine.LinkedMesh>, <global::spine_cpp.Spine.Polygon>, <global::spine_cpp.Spine.BoundingBoxAttachment>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <bool>, <global::spine_cpp.SpineUnity.SubmeshInstruction>.");
                }
            }

            public ulong Capacity
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(long)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector__K(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(float)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector__f(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoneData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_BoneData(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SlotData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_SlotData(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Skin)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_Skin(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SkinEntry)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector____N_spine_S_SkinEntry(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.ConstraintData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_ConstraintData(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.String)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector____N_spine_S_String(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Attachment)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_Attachment(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.EventData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_EventData(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Animation)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_Animation(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Timeline)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_Timeline(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Event)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_Event(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraintData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraintData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraintData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__Instance);
                        return ___ret;
                    }
                    if (__T.FullName == "System.IntPtr")
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector___C(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Bone)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_Bone(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Slot)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_Slot(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraint)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_IkConstraint(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraint)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraint)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_PathConstraint(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Updatable)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_Updatable(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector__I(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TrackEntry)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_TrackEntry(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasPage)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_AtlasPage(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasRegion)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TextureRegion)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_TextureRegion(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(ushort)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector__s(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector____N_spine_S_Vector__f(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector____N_spine_S_Vector__I(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.LinkedMesh)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Polygon)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_Polygon(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoundingBoxAttachment)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_Vector__f(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector_____N_spine_S_Vector__I(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector__b(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.SpineUnity.SubmeshInstruction)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.GetCapacityc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__Instance);
                        return ___ret;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::spine_cpp.Spine.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <long>, <float>, <global::spine_cpp.Spine.BoneData>, <global::spine_cpp.Spine.SlotData>, <global::spine_cpp.Spine.Skin>, <global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>>, <global::spine_cpp.Spine.SkinEntry>, <global::spine_cpp.Spine.ConstraintData>, <global::spine_cpp.Spine.String>, <global::spine_cpp.Spine.Attachment>, <global::spine_cpp.Spine.EventData>, <global::spine_cpp.Spine.Animation>, <global::spine_cpp.Spine.Timeline>, <global::spine_cpp.Spine.Event>, <global::spine_cpp.Spine.IkConstraintData>, <global::spine_cpp.Spine.TransformConstraintData>, <global::spine_cpp.Spine.PathConstraintData>, <CppSharp.Runtime.Pointer<sbyte>>, <global::spine_cpp.Spine.Bone>, <global::spine_cpp.Spine.Slot>, <global::spine_cpp.Spine.IkConstraint>, <global::spine_cpp.Spine.TransformConstraint>, <global::spine_cpp.Spine.PathConstraint>, <global::spine_cpp.Spine.Updatable>, <int>, <global::spine_cpp.Spine.TrackEntry>, <global::spine_cpp.Spine.EventQueueEntry>, <global::spine_cpp.Spine.AtlasPage>, <global::spine_cpp.Spine.AtlasRegion>, <global::spine_cpp.Spine.TextureRegion>, <ushort>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <global::spine_cpp.Spine.LinkedMesh>, <global::spine_cpp.Spine.Polygon>, <global::spine_cpp.Spine.BoundingBoxAttachment>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <bool>, <global::spine_cpp.SpineUnity.SubmeshInstruction>.");
                }
            }

            public ulong Size
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(long)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector__K(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(float)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector__f(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoneData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_BoneData(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SlotData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_SlotData(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Skin)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_Skin(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SkinEntry)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector____N_spine_S_SkinEntry(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.ConstraintData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_ConstraintData(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.String)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector____N_spine_S_String(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Attachment)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_Attachment(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.EventData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_EventData(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Animation)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_Animation(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Timeline)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_Timeline(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Event)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_Event(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraintData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_IkConstraintData(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraintData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraintData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_PathConstraintData(__Instance);
                        return ___ret;
                    }
                    if (__T.FullName == "System.IntPtr")
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector___C(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Bone)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_Bone(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Slot)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_Slot(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraint)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_IkConstraint(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraint)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_TransformConstraint(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraint)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_PathConstraint(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Updatable)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_Updatable(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector__I(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TrackEntry)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_TrackEntry(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasPage)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_AtlasPage(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasRegion)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_AtlasRegion(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TextureRegion)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_TextureRegion(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(ushort)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector__s(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector____N_spine_S_Vector__f(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector____N_spine_S_Vector__I(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.LinkedMesh)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_LinkedMesh(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Polygon)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_Polygon(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoundingBoxAttachment)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_Vector__f(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector_____N_spine_S_Vector__I(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector__b(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.SpineUnity.SubmeshInstruction)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.Sizec__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__Instance);
                        return ___ret;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::spine_cpp.Spine.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <long>, <float>, <global::spine_cpp.Spine.BoneData>, <global::spine_cpp.Spine.SlotData>, <global::spine_cpp.Spine.Skin>, <global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>>, <global::spine_cpp.Spine.SkinEntry>, <global::spine_cpp.Spine.ConstraintData>, <global::spine_cpp.Spine.String>, <global::spine_cpp.Spine.Attachment>, <global::spine_cpp.Spine.EventData>, <global::spine_cpp.Spine.Animation>, <global::spine_cpp.Spine.Timeline>, <global::spine_cpp.Spine.Event>, <global::spine_cpp.Spine.IkConstraintData>, <global::spine_cpp.Spine.TransformConstraintData>, <global::spine_cpp.Spine.PathConstraintData>, <CppSharp.Runtime.Pointer<sbyte>>, <global::spine_cpp.Spine.Bone>, <global::spine_cpp.Spine.Slot>, <global::spine_cpp.Spine.IkConstraint>, <global::spine_cpp.Spine.TransformConstraint>, <global::spine_cpp.Spine.PathConstraint>, <global::spine_cpp.Spine.Updatable>, <int>, <global::spine_cpp.Spine.TrackEntry>, <global::spine_cpp.Spine.EventQueueEntry>, <global::spine_cpp.Spine.AtlasPage>, <global::spine_cpp.Spine.AtlasRegion>, <global::spine_cpp.Spine.TextureRegion>, <ushort>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <global::spine_cpp.Spine.LinkedMesh>, <global::spine_cpp.Spine.Polygon>, <global::spine_cpp.Spine.BoundingBoxAttachment>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <bool>, <global::spine_cpp.SpineUnity.SubmeshInstruction>.");
                }
            }

            public __IntPtr VoidPBuffer
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(long)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector__K(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(float)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector__f(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoneData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_BoneData(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SlotData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_SlotData(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Skin)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_Skin(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector____N_spine_S_Vector____N_spine_S_SkinEntry(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.SkinEntry)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector____N_spine_S_SkinEntry(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.ConstraintData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_ConstraintData(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.String)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector____N_spine_S_String(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Attachment)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_Attachment(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.EventData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_EventData(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Animation)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_Animation(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Timeline)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_Timeline(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Event)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_Event(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraintData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_IkConstraintData(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraintData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_TransformConstraintData(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraintData)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_PathConstraintData(__Instance);
                        return ___ret;
                    }
                    if (__T.FullName == "System.IntPtr")
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector___C(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Bone)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_Bone(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Slot)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_Slot(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.IkConstraint)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_IkConstraint(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TransformConstraint)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_TransformConstraint(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.PathConstraint)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_PathConstraint(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Updatable)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_Updatable(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector__I(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TrackEntry)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_TrackEntry(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasPage)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_AtlasPage(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.AtlasRegion)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_AtlasRegion(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.TextureRegion)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_TextureRegion(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(ushort)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector__s(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector____N_spine_S_Vector__f(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector____N_spine_S_Vector__I(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.LinkedMesh)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_LinkedMesh(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Polygon)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_Polygon(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.BoundingBoxAttachment)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_BoundingBoxAttachment(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<float>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_Vector__f(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.Spine.Vector<int>)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector_____N_spine_S_Vector__I(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector__b(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::spine_cpp.SpineUnity.SubmeshInstruction)))
                    {
                        var ___ret = global::spine_cpp.Spine.Vector.__Internal.VoidPBufferc__N_spine_S_Vector____N_SpineUnity_S_SubmeshInstruction(__Instance);
                        return ___ret;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::spine_cpp.Spine.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <long>, <float>, <global::spine_cpp.Spine.BoneData>, <global::spine_cpp.Spine.SlotData>, <global::spine_cpp.Spine.Skin>, <global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>>, <global::spine_cpp.Spine.SkinEntry>, <global::spine_cpp.Spine.ConstraintData>, <global::spine_cpp.Spine.String>, <global::spine_cpp.Spine.Attachment>, <global::spine_cpp.Spine.EventData>, <global::spine_cpp.Spine.Animation>, <global::spine_cpp.Spine.Timeline>, <global::spine_cpp.Spine.Event>, <global::spine_cpp.Spine.IkConstraintData>, <global::spine_cpp.Spine.TransformConstraintData>, <global::spine_cpp.Spine.PathConstraintData>, <CppSharp.Runtime.Pointer<sbyte>>, <global::spine_cpp.Spine.Bone>, <global::spine_cpp.Spine.Slot>, <global::spine_cpp.Spine.IkConstraint>, <global::spine_cpp.Spine.TransformConstraint>, <global::spine_cpp.Spine.PathConstraint>, <global::spine_cpp.Spine.Updatable>, <int>, <global::spine_cpp.Spine.TrackEntry>, <global::spine_cpp.Spine.EventQueueEntry>, <global::spine_cpp.Spine.AtlasPage>, <global::spine_cpp.Spine.AtlasRegion>, <global::spine_cpp.Spine.TextureRegion>, <ushort>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <global::spine_cpp.Spine.LinkedMesh>, <global::spine_cpp.Spine.Polygon>, <global::spine_cpp.Spine.BoundingBoxAttachment>, <global::spine_cpp.Spine.Vector<float>>, <global::spine_cpp.Spine.Vector<int>>, <bool>, <global::spine_cpp.SpineUnity.SubmeshInstruction>.");
                }
            }

            #region Virtual table interop

            // ~Vector()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Vector<T>.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe static partial class VectorExtensions
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@_J@spine@@QEAA_NAEB_J@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains(__IntPtr __instance, long* inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@_J@spine@@QEAAHAEB_J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf(__IntPtr __instance, long* inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@M@spine@@QEAA_NAEBM@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_1(__IntPtr __instance, float* inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@M@spine@@QEAAHAEBM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_1(__IntPtr __instance, float* inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVBoneData@spine@@@spine@@QEAA_NAEBQEAVBoneData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVBoneData@spine@@@spine@@QEAAHAEBQEAVBoneData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVSlotData@spine@@@spine@@QEAA_NAEBQEAVSlotData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_1(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVSlotData@spine@@@spine@@QEAAHAEBQEAVSlotData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_1(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVSkin@spine@@@spine@@QEAA_NAEBQEAVSkin@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_2(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVSkin@spine@@@spine@@QEAAHAEBQEAVSkin@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_2(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVConstraintData@spine@@@spine@@QEAA_NAEBQEAVConstraintData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_3(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVConstraintData@spine@@@spine@@QEAAHAEBQEAVConstraintData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_3(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@VString@spine@@@spine@@QEAA_NAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_4(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@VString@spine@@@spine@@QEAAHAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_4(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVAttachment@spine@@@spine@@QEAA_NAEBQEAVAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_5(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVAttachment@spine@@@spine@@QEAAHAEBQEAVAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_5(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVEventData@spine@@@spine@@QEAA_NAEBQEAVEventData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_6(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVEventData@spine@@@spine@@QEAAHAEBQEAVEventData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_6(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVAnimation@spine@@@spine@@QEAA_NAEBQEAVAnimation@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_7(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVAnimation@spine@@@spine@@QEAAHAEBQEAVAnimation@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_7(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVTimeline@spine@@@spine@@QEAA_NAEBQEAVTimeline@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_8(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVTimeline@spine@@@spine@@QEAAHAEBQEAVTimeline@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_8(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVEvent@spine@@@spine@@QEAA_NAEBQEAVEvent@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_9(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVEvent@spine@@@spine@@QEAAHAEBQEAVEvent@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_9(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVIkConstraintData@spine@@@spine@@QEAA_NAEBQEAVIkConstraintData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_10(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVIkConstraintData@spine@@@spine@@QEAAHAEBQEAVIkConstraintData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_10(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVTransformConstraintData@spine@@@spine@@QEAA_NAEBQEAVTransformConstraintData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_11(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVTransformConstraintData@spine@@@spine@@QEAAHAEBQEAVTransformConstraintData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_11(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVPathConstraintData@spine@@@spine@@QEAA_NAEBQEAVPathConstraintData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_12(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVPathConstraintData@spine@@@spine@@QEAAHAEBQEAVPathConstraintData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_12(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAD@spine@@QEAA_NAEBQEAD@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_13(__IntPtr __instance, sbyte** inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAD@spine@@QEAAHAEBQEAD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_13(__IntPtr __instance, sbyte** inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVBone@spine@@@spine@@QEAA_NAEBQEAVBone@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_14(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVBone@spine@@@spine@@QEAAHAEBQEAVBone@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_14(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVSlot@spine@@@spine@@QEAA_NAEBQEAVSlot@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_15(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVSlot@spine@@@spine@@QEAAHAEBQEAVSlot@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_15(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVIkConstraint@spine@@@spine@@QEAA_NAEBQEAVIkConstraint@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_16(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVIkConstraint@spine@@@spine@@QEAAHAEBQEAVIkConstraint@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_16(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVTransformConstraint@spine@@@spine@@QEAA_NAEBQEAVTransformConstraint@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_17(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVTransformConstraint@spine@@@spine@@QEAAHAEBQEAVTransformConstraint@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_17(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVPathConstraint@spine@@@spine@@QEAA_NAEBQEAVPathConstraint@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_18(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVPathConstraint@spine@@@spine@@QEAAHAEBQEAVPathConstraint@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_18(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVUpdatable@spine@@@spine@@QEAA_NAEBQEAVUpdatable@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_19(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVUpdatable@spine@@@spine@@QEAAHAEBQEAVUpdatable@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_19(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@H@spine@@QEAA_NAEBH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_2(__IntPtr __instance, int* inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@H@spine@@QEAAHAEBH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_2(__IntPtr __instance, int* inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVTrackEntry@spine@@@spine@@QEAA_NAEBQEAVTrackEntry@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_20(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVTrackEntry@spine@@@spine@@QEAAHAEBQEAVTrackEntry@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_20(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVAtlasPage@spine@@@spine@@QEAA_NAEBQEAVAtlasPage@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_21(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVAtlasPage@spine@@@spine@@QEAAHAEBQEAVAtlasPage@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_21(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVAtlasRegion@spine@@@spine@@QEAA_NAEBQEAVAtlasRegion@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_22(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVAtlasRegion@spine@@@spine@@QEAAHAEBQEAVAtlasRegion@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_22(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVTextureRegion@spine@@@spine@@QEAA_NAEBQEAVTextureRegion@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_23(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVTextureRegion@spine@@@spine@@QEAAHAEBQEAVTextureRegion@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_23(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@G@spine@@QEAA_NAEBG@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_3(__IntPtr __instance, ushort* inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@G@spine@@QEAAHAEBG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_3(__IntPtr __instance, ushort* inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVLinkedMesh@spine@@@spine@@QEAA_NAEBQEAVLinkedMesh@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_24(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVLinkedMesh@spine@@@spine@@QEAAHAEBQEAVLinkedMesh@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_24(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVPolygon@spine@@@spine@@QEAA_NAEBQEAVPolygon@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_25(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVPolygon@spine@@@spine@@QEAAHAEBQEAVPolygon@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_25(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAVBoundingBoxAttachment@spine@@@spine@@QEAA_NAEBQEAVBoundingBoxAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_26(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAVBoundingBoxAttachment@spine@@@spine@@QEAAHAEBQEAVBoundingBoxAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_26(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAV?$Vector@M@spine@@@spine@@QEAA_NAEBQEAV?$Vector@M@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_27(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAV?$Vector@M@spine@@@spine@@QEAAHAEBQEAV?$Vector@M@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_27(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@PEAV?$Vector@H@spine@@@spine@@QEAA_NAEBQEAV?$Vector@H@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_28(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@PEAV?$Vector@H@spine@@@spine@@QEAAHAEBQEAV?$Vector@H@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_28(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?contains@?$Vector@_N@spine@@QEAA_NAEB_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Contains_4(__IntPtr __instance, bool* inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?indexOf@?$Vector@_N@spine@@QEAAHAEB_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int IndexOf_4(__IntPtr __instance, bool* inValue);
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<long> @this, long inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var __arg1 = &inValue;
                var ___ret = __Internal.Contains(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<long> @this, long inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var __arg1 = &inValue;
                var ___ret = __Internal.IndexOf(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<float> @this, float inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var __arg1 = &inValue;
                var ___ret = __Internal.Contains_1(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<float> @this, float inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var __arg1 = &inValue;
                var ___ret = __Internal.IndexOf_1(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.BoneData> @this, global::spine_cpp.Spine.BoneData inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.BoneData> @this, global::spine_cpp.Spine.BoneData inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SlotData> @this, global::spine_cpp.Spine.SlotData inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_1(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SlotData> @this, global::spine_cpp.Spine.SlotData inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_1(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Skin> @this, global::spine_cpp.Spine.Skin inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_2(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Skin> @this, global::spine_cpp.Spine.Skin inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_2(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.ConstraintData> @this, global::spine_cpp.Spine.ConstraintData inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_3(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.ConstraintData> @this, global::spine_cpp.Spine.ConstraintData inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_3(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.String> @this, global::spine_cpp.Spine.String inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = inValue.__Instance;
                var ___ret = __Internal.Contains_4(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.String> @this, global::spine_cpp.Spine.String inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = inValue.__Instance;
                var ___ret = __Internal.IndexOf_4(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Attachment> @this, global::spine_cpp.Spine.Attachment inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_5(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Attachment> @this, global::spine_cpp.Spine.Attachment inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_5(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.EventData> @this, global::spine_cpp.Spine.EventData inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_6(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.EventData> @this, global::spine_cpp.Spine.EventData inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_6(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Animation> @this, global::spine_cpp.Spine.Animation inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_7(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Animation> @this, global::spine_cpp.Spine.Animation inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_7(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Timeline> @this, global::spine_cpp.Spine.Timeline inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_8(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Timeline> @this, global::spine_cpp.Spine.Timeline inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_8(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> @this, global::spine_cpp.Spine.Event inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_9(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> @this, global::spine_cpp.Spine.Event inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_9(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.IkConstraintData> @this, global::spine_cpp.Spine.IkConstraintData inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_10(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.IkConstraintData> @this, global::spine_cpp.Spine.IkConstraintData inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_10(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.TransformConstraintData> @this, global::spine_cpp.Spine.TransformConstraintData inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_11(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.TransformConstraintData> @this, global::spine_cpp.Spine.TransformConstraintData inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_11(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.PathConstraintData> @this, global::spine_cpp.Spine.PathConstraintData inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_12(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.PathConstraintData> @this, global::spine_cpp.Spine.PathConstraintData inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_12(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<CppSharp.Runtime.Pointer<sbyte>> @this, sbyte* inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var __arg1 = &inValue;
                var ___ret = __Internal.Contains_13(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<CppSharp.Runtime.Pointer<sbyte>> @this, sbyte* inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var __arg1 = &inValue;
                var ___ret = __Internal.IndexOf_13(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Bone> @this, global::spine_cpp.Spine.Bone inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_14(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Bone> @this, global::spine_cpp.Spine.Bone inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_14(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Slot> @this, global::spine_cpp.Spine.Slot inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_15(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Slot> @this, global::spine_cpp.Spine.Slot inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_15(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.IkConstraint> @this, global::spine_cpp.Spine.IkConstraint inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_16(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.IkConstraint> @this, global::spine_cpp.Spine.IkConstraint inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_16(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.TransformConstraint> @this, global::spine_cpp.Spine.TransformConstraint inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_17(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.TransformConstraint> @this, global::spine_cpp.Spine.TransformConstraint inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_17(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.PathConstraint> @this, global::spine_cpp.Spine.PathConstraint inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_18(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.PathConstraint> @this, global::spine_cpp.Spine.PathConstraint inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_18(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Updatable> @this, global::spine_cpp.Spine.Updatable inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_19(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Updatable> @this, global::spine_cpp.Spine.Updatable inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_19(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<int> @this, int inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var __arg1 = &inValue;
                var ___ret = __Internal.Contains_2(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<int> @this, int inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var __arg1 = &inValue;
                var ___ret = __Internal.IndexOf_2(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.TrackEntry> @this, global::spine_cpp.Spine.TrackEntry inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_20(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.TrackEntry> @this, global::spine_cpp.Spine.TrackEntry inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_20(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.AtlasPage> @this, global::spine_cpp.Spine.AtlasPage inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_21(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.AtlasPage> @this, global::spine_cpp.Spine.AtlasPage inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_21(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.AtlasRegion> @this, global::spine_cpp.Spine.AtlasRegion inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_22(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.AtlasRegion> @this, global::spine_cpp.Spine.AtlasRegion inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_22(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.TextureRegion> @this, global::spine_cpp.Spine.TextureRegion inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_23(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.TextureRegion> @this, global::spine_cpp.Spine.TextureRegion inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_23(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<ushort> @this, ushort inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var __arg1 = &inValue;
                var ___ret = __Internal.Contains_3(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<ushort> @this, ushort inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var __arg1 = &inValue;
                var ___ret = __Internal.IndexOf_3(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.LinkedMesh> @this, global::spine_cpp.Spine.LinkedMesh inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_24(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.LinkedMesh> @this, global::spine_cpp.Spine.LinkedMesh inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_24(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Polygon> @this, global::spine_cpp.Spine.Polygon inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_25(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Polygon> @this, global::spine_cpp.Spine.Polygon inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_25(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.BoundingBoxAttachment> @this, global::spine_cpp.Spine.BoundingBoxAttachment inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_26(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.BoundingBoxAttachment> @this, global::spine_cpp.Spine.BoundingBoxAttachment inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_26(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Vector<float>> @this, global::spine_cpp.Spine.Vector<float> inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_27(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Vector<float>> @this, global::spine_cpp.Spine.Vector<float> inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_27(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Vector<int>> @this, global::spine_cpp.Spine.Vector<int> inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.Contains_28(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Vector<int>> @this, global::spine_cpp.Spine.Vector<int> inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                if (ReferenceEquals(inValue, null))
                    throw new global::System.ArgumentNullException("inValue", "Cannot be null because it is a C++ reference (&).");
                var ____arg1 = inValue.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.IndexOf_28(__arg0, __arg1);
                return ___ret;
            }

            public static bool Contains(this global::spine_cpp.Spine.Vector<bool> @this, bool inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var __arg1 = &inValue;
                var ___ret = __Internal.Contains_4(__arg0, __arg1);
                return ___ret;
            }

            public static int IndexOf(this global::spine_cpp.Spine.Vector<bool> @this, bool inValue)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var __arg1 = &inValue;
                var ___ret = __Internal.IndexOf_4(__arg0, __arg1);
                return ___ret;
            }
        }
    }

    namespace Spine
    {
        namespace HashMap
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public unsafe partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _head;
                internal ulong _size;
            }

            namespace Entry
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public unsafe partial struct __Internalc__N_spine_S_HashMap__K_b
                {
                    internal __IntPtr vfptr_SpineObject;
                    internal long _key;
                    internal byte _value;
                    internal __IntPtr next;
                    internal __IntPtr prev;
                }

                [StructLayout(LayoutKind.Sequential, Size = 56)]
                public unsafe partial struct __Internalc__N_spine_S_HashMap____N_spine_S_AnimationStateData_S_AnimationPair_f
                {
                    internal __IntPtr vfptr_SpineObject;
                    internal global::spine_cpp.Spine.AnimationStateData.AnimationPair.__Internal _key;
                    internal float _value;
                    internal __IntPtr next;
                    internal __IntPtr prev;
                }
            }

        }
    }

    namespace Spine
    {
        public unsafe partial class Animation : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 104)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _timelines;
                internal global::spine_cpp.Spine.HashMap.__Internal _timelineIds;
                internal float _duration;
                internal global::spine_cpp.Spine.String.__Internal _name;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Animation@spine@@QEAA@AEBVString@1@AEAV?$Vector@PEAVTimeline@spine@@@1@M@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name, __IntPtr timelines, float duration);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Animation@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?apply@Animation@spine@@QEAAXAEAVSkeleton@2@MM_NPEAV?$Vector@PEAVEvent@spine@@@2@MW4MixBlend@2@W4MixDirection@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Apply(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, bool loop, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?hasTimeline@Animation@spine@@QEAA_NAEAV?$Vector@_J@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasTimeline(__IntPtr __instance, __IntPtr ids);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?search@Animation@spine@@SAHAEAV?$Vector@M@2@M@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Search(__IntPtr values, float target);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?search@Animation@spine@@SAHAEAV?$Vector@M@2@MH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Search(__IntPtr values, float target, int step);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getName@Animation@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTimelines@Animation@spine@@QEAAAEAV?$Vector@PEAVTimeline@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTimelines(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getDuration@Animation@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetDuration(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setDuration@Animation@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDuration(__IntPtr __instance, float inValue);
            }

            internal static new Animation __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Animation(native.ToPointer(), skipVTables);
            }

            internal static new Animation __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Animation)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Animation __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Animation)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Animation __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Animation(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Animation.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Animation(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Animation(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Animation(global::spine_cpp.Spine.String name, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Timeline> timelines, float duration)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Animation.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                if (ReferenceEquals(timelines, null))
                    throw new global::System.ArgumentNullException("timelines", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = timelines.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1, duration);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Animation");
            }

            public Animation(global::spine_cpp.Spine.Animation _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Animation.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Animation");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Applies all the animation's timelines to the specified skeleton.</para>
            /// <para>See also Timeline::apply(Skeleton&amp;, float, float, Vector, float, MixPose, MixDirection)</para>
            /// </summary>
            public void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, bool loop, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg4 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                __Internal.Apply(__Instance, __arg0, lastTime, time, loop, __arg4, alpha, blend, direction);
            }

            public bool HasTimeline(global::spine_cpp.Spine.Vector<long> ids)
            {
                if (ReferenceEquals(ids, null))
                    throw new global::System.ArgumentNullException("ids", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = ids.__Instance;
                var ___ret = __Internal.HasTimeline(__Instance, __arg0);
                return ___ret;
            }

            /// <param name="target">After the first and before the last entry.</param>
            public static int Search(global::spine_cpp.Spine.Vector<float> values, float target)
            {
                if (ReferenceEquals(values, null))
                    throw new global::System.ArgumentNullException("values", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = values.__Instance;
                var ___ret = __Internal.Search(__arg0, target);
                return ___ret;
            }

            public static int Search(global::spine_cpp.Spine.Vector<float> values, float target, int step)
            {
                if (ReferenceEquals(values, null))
                    throw new global::System.ArgumentNullException("values", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = values.__Instance;
                var ___ret = __Internal.Search(__arg0, target, step);
                return ___ret;
            }

            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Timeline> Timelines
            {
                get
                {
                    var ___ret = __Internal.GetTimelines(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Timeline>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public float Duration
            {
                get
                {
                    var ___ret = __Internal.GetDuration(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetDuration(__Instance, value);
                }
            }

            #region Virtual table interop

            // ~Animation()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Animation.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        namespace Pool
        {
            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public unsafe partial struct __Internalc__N_spine_S_Pool____N_spine_S_TrackEntry
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _objects;
            }

            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public unsafe partial struct __Internalc__N_spine_S_Pool____N_spine_S_Polygon
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _objects;
            }

            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public unsafe partial struct __Internalc__N_spine_S_Pool____N_spine_S_Vector__f
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _objects;
            }

            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public unsafe partial struct __Internalc__N_spine_S_Pool____N_spine_S_Vector__I
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _objects;
            }
        }
    }

    namespace Spine
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void DisposeRendererObject(__IntPtr rendererObject);

        public unsafe partial interface IHasRendererObject : IDisposable
        {
            void SetRendererObject(__IntPtr rendererObject, global::spine_cpp.Spine.DisposeRendererObject dispose);

            __IntPtr __Instance { get; }

            __IntPtr __PointerToHasRendererObject { get; }

            __IntPtr RendererObject { get; }
        }

        public unsafe partial class HasRendererObject : global::spine_cpp.Spine.IHasRendererObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_HasRendererObject;
                internal __IntPtr _rendererObject;
                internal __IntPtr _dispose;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0HasRendererObject@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0HasRendererObject@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setRendererObject@HasRendererObject@spine@@QEAAXPEAXP6AX0@Z@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRendererObject(__IntPtr __instance, __IntPtr rendererObject, __IntPtr dispose);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getRendererObject@HasRendererObject@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRendererObject(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.IHasRendererObject> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.IHasRendererObject>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.Spine.IHasRendererObject managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.Spine.IHasRendererObject managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static HasRendererObject __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new HasRendererObject(native.ToPointer(), skipVTables);
            }

            internal static HasRendererObject __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (HasRendererObject)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static HasRendererObject __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (HasRendererObject)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static HasRendererObject __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new HasRendererObject(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.HasRendererObject.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private HasRendererObject(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected HasRendererObject(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            public HasRendererObject()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.HasRendererObject.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.HasRendererObject");
            }

            public HasRendererObject(global::spine_cpp.Spine.IHasRendererObject _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.HasRendererObject.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__PointerToHasRendererObject;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.HasRendererObject");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void SetRendererObject(__IntPtr rendererObject, global::spine_cpp.Spine.DisposeRendererObject dispose)
            {
                var __arg1 = dispose == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(dispose);
                __Internal.SetRendererObject(__Instance, rendererObject, __arg1);
            }

            public __IntPtr __PointerToHasRendererObject
            {
                get
                {
                    return __Instance + 0;
                }
            }

            public __IntPtr RendererObject
            {
                get
                {
                    var ___ret = __Internal.GetRendererObject(__Instance);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // virtual ~HasRendererObject()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.HasRendererObject.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class Color : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal float r;
                internal float g;
                internal float b;
                internal float a;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Color@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Color@spine@@QEAA@MMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, float r, float g, float b, float a);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Color@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?set@Color@spine@@QEAAAEAV12@MMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Set(__IntPtr __instance, float _r, float _g, float _b, float _a);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?set@Color@spine@@QEAAAEAV12@MMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Set(__IntPtr __instance, float _r, float _g, float _b);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?set@Color@spine@@QEAAAEAV12@AEBV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Set(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@Color@spine@@QEAAAEAV12@MMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Add(__IntPtr __instance, float _r, float _g, float _b, float _a);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@Color@spine@@QEAAAEAV12@MMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Add(__IntPtr __instance, float _r, float _g, float _b);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?add@Color@spine@@QEAAAEAV12@AEBV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Add(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clamp@Color@spine@@QEAAAEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Clamp(__IntPtr __instance);
            }

            internal static new Color __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Color(native.ToPointer(), skipVTables);
            }

            internal static new Color __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Color)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Color __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Color)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Color __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Color(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Color.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Color(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Color(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Color()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Color.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Color");
            }

            public Color(float r, float g, float b, float a)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Color.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, r, g, b, a);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Color");
            }

            public Color(global::spine_cpp.Spine.Color _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Color.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Color");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::spine_cpp.Spine.Color Set(float _r, float _g, float _b, float _a)
            {
                var ___ret = __Internal.Set(__Instance, _r, _g, _b, _a);
                var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.Color Set(float _r, float _g, float _b)
            {
                var ___ret = __Internal.Set(__Instance, _r, _g, _b);
                var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.Color Set(global::spine_cpp.Spine.Color other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = __Internal.Set(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.Color Add(float _r, float _g, float _b, float _a)
            {
                var ___ret = __Internal.Add(__Instance, _r, _g, _b, _a);
                var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.Color Add(float _r, float _g, float _b)
            {
                var ___ret = __Internal.Add(__Instance, _r, _g, _b);
                var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.Color Add(global::spine_cpp.Spine.Color other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = __Internal.Add(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public float R
            {
                get
                {
                    return ((__Internal*)__Instance)->r;
                }

                set
                {
                    ((__Internal*)__Instance)->r = value;
                }
            }

            public float G
            {
                get
                {
                    return ((__Internal*)__Instance)->g;
                }

                set
                {
                    ((__Internal*)__Instance)->g = value;
                }
            }

            public float B
            {
                get
                {
                    return ((__Internal*)__Instance)->b;
                }

                set
                {
                    ((__Internal*)__Instance)->b = value;
                }
            }

            public float A
            {
                get
                {
                    return ((__Internal*)__Instance)->a;
                }

                set
                {
                    ((__Internal*)__Instance)->a = value;
                }
            }

            public global::spine_cpp.Spine.Color Clamp
            {
                get
                {
                    var ___ret = __Internal.Clamp(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // Color
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Color.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class Slot : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 136)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _data;
                internal __IntPtr _bone;
                internal __IntPtr _skeleton;
                internal global::spine_cpp.Spine.Color.__Internal _color;
                internal global::spine_cpp.Spine.Color.__Internal _darkColor;
                internal byte _hasDarkColor;
                internal __IntPtr _attachment;
                internal int _attachmentState;
                internal int _sequenceIndex;
                internal global::spine_cpp.Spine.Vector.__Internal _deform;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Slot@spine@@QEAA@AEAVSlotData@1@AEAVBone@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr data, __IntPtr bone);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Slot@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setToSetupPose@Slot@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetToSetupPose(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getData@Slot@spine@@QEAAAEAVSlotData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBone@Slot@spine@@QEAAAEAVBone@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBone(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSkeleton@Slot@spine@@QEAAAEAVSkeleton@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSkeleton(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getColor@Slot@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getDarkColor@Slot@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDarkColor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?hasDarkColor@Slot@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasDarkColor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAttachment@Slot@spine@@QEAAPEAVAttachment@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAttachment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAttachment@Slot@spine@@QEAAXPEAVAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAttachment(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAttachmentState@Slot@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetAttachmentState(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAttachmentState@Slot@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAttachmentState(__IntPtr __instance, int state);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getDeform@Slot@spine@@QEAAAEAV?$Vector@M@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDeform(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSequenceIndex@Slot@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetSequenceIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSequenceIndex@Slot@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSequenceIndex(__IntPtr __instance, int index);
            }

            internal static new Slot __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Slot(native.ToPointer(), skipVTables);
            }

            internal static new Slot __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Slot)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Slot __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Slot)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Slot __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Slot(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Slot.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Slot(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Slot(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Slot(global::spine_cpp.Spine.SlotData data, global::spine_cpp.Spine.Bone bone)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Slot.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(data, null))
                    throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = data.__Instance;
                if (ReferenceEquals(bone, null))
                    throw new global::System.ArgumentNullException("bone", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = bone.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Slot");
            }

            public Slot(global::spine_cpp.Spine.Slot _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Slot.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Slot");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void SetToSetupPose()
            {
                __Internal.SetToSetupPose(__Instance);
            }

            public global::spine_cpp.Spine.SlotData Data
            {
                get
                {
                    var ___ret = __Internal.GetData(__Instance);
                    var __result0 = global::spine_cpp.Spine.SlotData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Bone Bone
            {
                get
                {
                    var ___ret = __Internal.GetBone(__Instance);
                    var __result0 = global::spine_cpp.Spine.Bone.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Skeleton Skeleton
            {
                get
                {
                    var ___ret = __Internal.GetSkeleton(__Instance);
                    var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Color DarkColor
            {
                get
                {
                    var ___ret = __Internal.GetDarkColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public bool HasDarkColor
            {
                get
                {
                    var ___ret = __Internal.HasDarkColor(__Instance);
                    return ___ret;
                }
            }

            /// <summary>May be NULL.</summary>
            public global::spine_cpp.Spine.Attachment Attachment
            {
                get
                {
                    var ___ret = __Internal.GetAttachment(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetAttachment(__Instance, __arg0);
                }
            }

            public int AttachmentState
            {
                get
                {
                    var ___ret = __Internal.GetAttachmentState(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAttachmentState(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.Vector<float> Deform
            {
                get
                {
                    var ___ret = __Internal.GetDeform(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<float>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public int SequenceIndex
            {
                get
                {
                    var ___ret = __Internal.GetSequenceIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSequenceIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // Slot
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Slot.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public enum EventType
        {
            EventTypeStart = 0,
            EventTypeInterrupt = 1,
            EventTypeEnd = 2,
            EventTypeComplete = 3,
            EventTypeDispose = 4,
            EventTypeEvent = 5
        }

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void AnimationStateListener(__IntPtr state, global::spine_cpp.Spine.EventType type, __IntPtr entry, __IntPtr @event);

        /// <summary>Abstract class to inherit from to create a callback object</summary>
        public unsafe abstract partial class AnimationStateListenerObject : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_AnimationStateListenerObject;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AnimationStateListenerObject@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AnimationStateListenerObject@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.AnimationStateListenerObject> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.AnimationStateListenerObject>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.Spine.AnimationStateListenerObject managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.Spine.AnimationStateListenerObject managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static AnimationStateListenerObject __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AnimationStateListenerObjectInternal(native.ToPointer(), skipVTables);
            }

            internal static AnimationStateListenerObject __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AnimationStateListenerObject)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static AnimationStateListenerObject __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AnimationStateListenerObject)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AnimationStateListenerObject __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AnimationStateListenerObjectInternal(native, skipVTables);
            }

            protected AnimationStateListenerObject(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected AnimationStateListenerObject()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AnimationStateListenerObject.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AnimationStateListenerObject");
            }

            protected AnimationStateListenerObject(global::spine_cpp.Spine.AnimationStateListenerObject _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AnimationStateListenerObject.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AnimationStateListenerObject");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>The callback function to be called</summary>
            public abstract void Callback(global::spine_cpp.Spine.AnimationState state, global::spine_cpp.Spine.EventType type, global::spine_cpp.Spine.TrackEntry entry, global::spine_cpp.Spine.Event @event);

            #region Virtual table interop

            // virtual ~AnimationStateListenerObject()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.AnimationStateListenerObject.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void callback(AnimationState *state, EventType type, TrackEntry *entry, Event *event) = 0
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_spine_cpp_spine_EventType___IntPtr___IntPtr _CallbackDelegateInstance;

            private static void _CallbackDelegateHook(__IntPtr __instance, __IntPtr state, global::spine_cpp.Spine.EventType type, __IntPtr entry, __IntPtr @event)
            {
                var __target = global::spine_cpp.Spine.AnimationStateListenerObject.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.AnimationState.__GetOrCreateInstance(state, false, skipVTables: true);
                var __result2 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(entry, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Event.__GetOrCreateInstance(@event, false, skipVTables: true);
                __target.Callback(__result0, type, __result2, __result3);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _CallbackDelegateInstance += _CallbackDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CallbackDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>State for the playback of an animation</summary>
        public unsafe partial class TrackEntry : global::spine_cpp.Spine.SpineObject, global::spine_cpp.Spine.IHasRendererObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 272)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr vfptr_HasRendererObject;
                internal __IntPtr _rendererObject;
                internal __IntPtr _dispose;
                internal __IntPtr _animation;
                internal __IntPtr _previous;
                internal __IntPtr _next;
                internal __IntPtr _mixingFrom;
                internal __IntPtr _mixingTo;
                internal int _trackIndex;
                internal byte _loop;
                internal byte _holdPrevious;
                internal byte _reverse;
                internal byte _shortestRotation;
                internal float _eventThreshold;
                internal float _attachmentThreshold;
                internal float _drawOrderThreshold;
                internal float _animationStart;
                internal float _animationEnd;
                internal float _animationLast;
                internal float _nextAnimationLast;
                internal float _delay;
                internal float _trackTime;
                internal float _trackLast;
                internal float _nextTrackLast;
                internal float _trackEnd;
                internal float _timeScale;
                internal float _alpha;
                internal float _mixTime;
                internal float _mixDuration;
                internal float _interruptAlpha;
                internal float _totalAlpha;
                internal global::spine_cpp.Spine.MixBlend _mixBlend;
                internal global::spine_cpp.Spine.Vector.__Internal _timelineMode;
                internal global::spine_cpp.Spine.Vector.__Internal _timelineHoldMix;
                internal global::spine_cpp.Spine.Vector.__Internal _timelinesRotation;
                internal __IntPtr _listener;
                internal __IntPtr _listenerObject;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0TrackEntry@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0TrackEntry@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?resetRotationDirections@TrackEntry@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ResetRotationDirections(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setListener@TrackEntry@spine@@QEAAXP6AXPEAVAnimationState@2@W4EventType@2@PEAV12@PEAVEvent@2@@Z@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetListener(__IntPtr __instance, __IntPtr listener);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setListener@TrackEntry@spine@@QEAAXPEAVAnimationStateListenerObject@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetListener_1(__IntPtr __instance, __IntPtr listener);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setRendererObject@HasRendererObject@spine@@QEAAXPEAXP6AX0@Z@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRendererObject(__IntPtr __instance, __IntPtr rendererObject, __IntPtr dispose);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTrackIndex@TrackEntry@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetTrackIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAnimation@TrackEntry@spine@@QEAAPEAVAnimation@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAnimation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getPrevious@TrackEntry@spine@@QEAAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetPrevious(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getLoop@TrackEntry@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetLoop(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setLoop@TrackEntry@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetLoop(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getHoldPrevious@TrackEntry@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetHoldPrevious(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setHoldPrevious@TrackEntry@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHoldPrevious(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getReverse@TrackEntry@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetReverse(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setReverse@TrackEntry@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetReverse(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getShortestRotation@TrackEntry@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetShortestRotation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setShortestRotation@TrackEntry@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetShortestRotation(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getDelay@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetDelay(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setDelay@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDelay(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTrackTime@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetTrackTime(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setTrackTime@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTrackTime(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTrackEnd@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetTrackEnd(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setTrackEnd@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTrackEnd(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAnimationStart@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAnimationStart(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAnimationStart@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAnimationStart(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAnimationEnd@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAnimationEnd(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAnimationEnd@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAnimationEnd(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAnimationLast@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAnimationLast(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAnimationLast@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAnimationLast(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAnimationTime@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAnimationTime(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTimeScale@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetTimeScale(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setTimeScale@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTimeScale(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAlpha@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAlpha(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAlpha@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAlpha(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getEventThreshold@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetEventThreshold(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setEventThreshold@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetEventThreshold(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAttachmentThreshold@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAttachmentThreshold(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAttachmentThreshold@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAttachmentThreshold(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getDrawOrderThreshold@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetDrawOrderThreshold(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setDrawOrderThreshold@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDrawOrderThreshold(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getNext@TrackEntry@spine@@QEAAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetNext(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?isComplete@TrackEntry@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsComplete(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixTime@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixTime(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixTime@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixTime(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixDuration@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixDuration(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixDuration@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixDuration(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixBlend@TrackEntry@spine@@QEAA?AW4MixBlend@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::spine_cpp.Spine.MixBlend GetMixBlend(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixBlend@TrackEntry@spine@@QEAAXW4MixBlend@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixBlend(__IntPtr __instance, global::spine_cpp.Spine.MixBlend blend);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixingFrom@TrackEntry@spine@@QEAAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetMixingFrom(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixingTo@TrackEntry@spine@@QEAAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetMixingTo(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTrackComplete@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetTrackComplete(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getRendererObject@HasRendererObject@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRendererObject(__IntPtr __instance);
            }

            internal static new TrackEntry __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TrackEntry(native.ToPointer(), skipVTables);
            }

            internal static new TrackEntry __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TrackEntry)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new TrackEntry __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (TrackEntry)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static TrackEntry __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TrackEntry(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.TrackEntry.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private TrackEntry(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TrackEntry(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public TrackEntry()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TrackEntry.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TrackEntry");
            }

            public TrackEntry(global::spine_cpp.Spine.TrackEntry _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TrackEntry.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TrackEntry");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                *(IntPtr*)(__Instance + 8) = __VTables.Tables[1];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the</para>
            /// <para>long way around when using alpha and starting animations on other tracks.</para>
            /// </summary>
            /// <remarks>
            /// <para>Mixing involves finding a rotation between two others, which has two possible solutions: the short way or the long way around.</para>
            /// <para>The two rotations likely change over time, so which direction is the short or long way also changes.</para>
            /// <para>If the short way was always chosen, bones would flip to the other side when that direction became the long way.</para>
            /// <para>TrackEntry chooses the short way the first time it is applied and remembers that direction.</para>
            /// </remarks>
            public void ResetRotationDirections()
            {
                __Internal.ResetRotationDirections(__Instance);
            }

            public void SetListener(global::spine_cpp.Spine.AnimationStateListener listener)
            {
                var __arg0 = listener == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(listener);
                __Internal.SetListener(__Instance, __arg0);
            }

            public void SetListener(global::spine_cpp.Spine.AnimationStateListenerObject listener)
            {
                var __arg0 = listener is null ? __IntPtr.Zero : listener.__Instance;
                __Internal.SetListener_1(__Instance, __arg0);
            }

            public void SetRendererObject(__IntPtr rendererObject, global::spine_cpp.Spine.DisposeRendererObject dispose)
            {
                var __arg1 = dispose == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(dispose);
                __Internal.SetRendererObject(__Instance + 8, rendererObject, __arg1);
            }

            public __IntPtr __PointerToHasRendererObject
            {
                get
                {
                    return __Instance + 8;
                }
            }

            /// <summary>The index of the track where this entry is either current or queued.</summary>
            public int TrackIndex
            {
                get
                {
                    var ___ret = __Internal.GetTrackIndex(__Instance);
                    return ___ret;
                }
            }

            /// <summary>The animation to apply for this track entry.</summary>
            public global::spine_cpp.Spine.Animation Animation
            {
                get
                {
                    var ___ret = __Internal.GetAnimation(__Instance);
                    var __result0 = global::spine_cpp.Spine.Animation.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.TrackEntry Previous
            {
                get
                {
                    var ___ret = __Internal.GetPrevious(__Instance);
                    var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>If true, the animation will repeat. If false, it will not, instead its last frame is applied if played beyond its duration.</summary>
            public bool Loop
            {
                get
                {
                    var ___ret = __Internal.GetLoop(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetLoop(__Instance, value);
                }
            }

            /// <summary>
            /// <para>If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead</para>
            /// <para>of being mixed out.</para>
            /// </summary>
            /// <remarks>
            /// <para>When mixing between animations that key the same property, if a lower track also keys that property then the value will</para>
            /// <para>briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%</para>
            /// <para>while the second animation mixes from 0% to 100%. Setting holdPrevious to true applies the first animation</para>
            /// <para>at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which</para>
            /// <para>keys the property, only when a higher track also keys the property.</para>
            /// <para>Snapping will occur if holdPrevious is true and this animation does not key all the same properties as the</para>
            /// <para>previous animation.</para>
            /// </remarks>
            public bool HoldPrevious
            {
                get
                {
                    var ___ret = __Internal.GetHoldPrevious(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHoldPrevious(__Instance, value);
                }
            }

            public bool Reverse
            {
                get
                {
                    var ___ret = __Internal.GetReverse(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetReverse(__Instance, value);
                }
            }

            public bool ShortestRotation
            {
                get
                {
                    var ___ret = __Internal.GetShortestRotation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetShortestRotation(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Seconds to postpone playing the animation. When a track entry is the current track entry, delay postpones incrementing</para>
            /// <para>the track time. When a track entry is queued, delay is the time from the start of the previous animation to when the</para>
            /// <para>track entry will become the current track entry.</para>
            /// </summary>
            public float Delay
            {
                get
                {
                    var ___ret = __Internal.GetDelay(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetDelay(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Current time in seconds this track entry has been the current track entry. The track time determines</para>
            /// <para>TrackEntry.AnimationTime. The track time can be set to start the animation at a time other than 0, without affecting looping.</para>
            /// </summary>
            public float TrackTime
            {
                get
                {
                    var ___ret = __Internal.GetTrackTime(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetTrackTime(__Instance, value);
                }
            }

            /// <summary>
            /// <para>The track time in seconds when this animation will be removed from the track. Defaults to the animation duration for</para>
            /// <para>non-looping animations and to int.MaxValue for looping animations. If the track end time is reached and no</para>
            /// <para>other animations are queued for playback, and mixing from any previous animations is complete, properties keyed by the animation,</para>
            /// <para>are set to the setup pose and the track is cleared.</para>
            /// </summary>
            /// <remarks>
            /// <para>It may be desired to use AnimationState.addEmptyAnimation(int, float, float) to mix the properties back to the</para>
            /// <para>setup pose over time, rather than have it happen instantly.</para>
            /// </remarks>
            public float TrackEnd
            {
                get
                {
                    var ___ret = __Internal.GetTrackEnd(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetTrackEnd(__Instance, value);
                }
            }

            /// <summary>Seconds when this animation starts, both initially and after looping. Defaults to 0.</summary>
            /// <remarks>
            /// <para>When changing the animation start time, it often makes sense to set TrackEntry.AnimationLast to the same value to</para>
            /// <para>prevent timeline keys before the start time from triggering.</para>
            /// </remarks>
            public float AnimationStart
            {
                get
                {
                    var ___ret = __Internal.GetAnimationStart(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAnimationStart(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will</para>
            /// <para>loop back to TrackEntry.AnimationStart at this time. Defaults to the animation duration.</para>
            /// </summary>
            public float AnimationEnd
            {
                get
                {
                    var ___ret = __Internal.GetAnimationEnd(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAnimationEnd(__Instance, value);
                }
            }

            /// <summary>
            /// <para>The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this</para>
            /// <para>animation is applied, event timelines will fire all events between the animation last time (exclusive) and animation time</para>
            /// <para>(inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation is applied.</para>
            /// </summary>
            public float AnimationLast
            {
                get
                {
                    var ___ret = __Internal.GetAnimationLast(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAnimationLast(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Uses TrackEntry.TrackTime to compute the animation time between TrackEntry.AnimationStart. and</para>
            /// <para>TrackEntry.AnimationEnd. When the track time is 0, the animation time is equal to the animation start time.</para>
            /// </summary>
            public float AnimationTime
            {
                get
                {
                    var ___ret = __Internal.GetAnimationTime(__Instance);
                    return ___ret;
                }
            }

            /// <summary>
            /// <para>Multiplier for the delta time when the animation state is updated, causing time for this animation to play slower or</para>
            /// <para>faster. Defaults to 1.</para>
            /// </summary>
            public float TimeScale
            {
                get
                {
                    var ___ret = __Internal.GetTimeScale(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetTimeScale(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Values less than 1 mix this animation with the last skeleton pose. Defaults to 1, which overwrites the last skeleton pose with</para>
            /// <para>this animation.</para>
            /// </summary>
            /// <remarks>
            /// <para>Typically track 0 is used to completely pose the skeleton, then alpha can be used on higher tracks. It doesn't make sense</para>
            /// <para>to use alpha on track 0 if the skeleton pose is from the last frame render.</para>
            /// </remarks>
            public float Alpha
            {
                get
                {
                    var ___ret = __Internal.GetAlpha(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAlpha(__Instance, value);
                }
            }

            /// <summary>
            /// <para>When the mix percentage (mix time / mix duration) is less than the event threshold, event timelines for the animation</para>
            /// <para>being mixed out will be applied. Defaults to 0, so event timelines are not applied for an animation being mixed out.</para>
            /// </summary>
            public float EventThreshold
            {
                get
                {
                    var ___ret = __Internal.GetEventThreshold(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetEventThreshold(__Instance, value);
                }
            }

            /// <summary>
            /// <para>When the mix percentage (mix time / mix duration) is less than the attachment threshold, attachment timelines for the</para>
            /// <para>animation being mixed out will be applied. Defaults to 0, so attachment timelines are not applied for an animation being</para>
            /// <para>mixed out.</para>
            /// </summary>
            public float AttachmentThreshold
            {
                get
                {
                    var ___ret = __Internal.GetAttachmentThreshold(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAttachmentThreshold(__Instance, value);
                }
            }

            /// <summary>
            /// <para>When the mix percentage (mix time / mix duration) is less than the draw order threshold, draw order timelines for the</para>
            /// <para>animation being mixed out will be applied. Defaults to 0, so draw order timelines are not applied for an animation being</para>
            /// <para>mixed out.</para>
            /// </summary>
            public float DrawOrderThreshold
            {
                get
                {
                    var ___ret = __Internal.GetDrawOrderThreshold(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetDrawOrderThreshold(__Instance, value);
                }
            }

            /// <summary>The animation queued to start after this animation, or NULL.</summary>
            public global::spine_cpp.Spine.TrackEntry Next
            {
                get
                {
                    var ___ret = __Internal.GetNext(__Instance);
                    var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>Returns true if at least one loop has been completed.</summary>
            public bool IsComplete
            {
                get
                {
                    var ___ret = __Internal.IsComplete(__Instance);
                    return ___ret;
                }
            }

            /// <summary>
            /// <para>Seconds from 0 to the mix duration when mixing from the previous animation to this animation. May be slightly more than</para>
            /// <para>TrackEntry.MixDuration when the mix is complete.</para>
            /// </summary>
            public float MixTime
            {
                get
                {
                    var ___ret = __Internal.GetMixTime(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixTime(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Seconds for mixing from the previous animation to this animation. Defaults to the value provided by</para>
            /// <para>AnimationStateData based on the animation before this animation (if any).</para>
            /// </summary>
            /// <remarks>
            /// <para>The mix duration can be set manually rather than use the value from AnimationStateData.GetMix.</para>
            /// <para>In that case, the mixDuration must be set before AnimationState.update(float) is next called.</para>
            /// <para>When using AnimationState::addAnimation(int, Animation, bool, float) with a delay</para>
            /// <para>less than or equal to 0, note the Delay is set using the mix duration from the AnimationStateData</para>
            /// </remarks>
            public float MixDuration
            {
                get
                {
                    var ___ret = __Internal.GetMixDuration(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixDuration(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.MixBlend MixBlend
            {
                get
                {
                    var ___ret = __Internal.GetMixBlend(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixBlend(__Instance, value);
                }
            }

            /// <summary>
            /// <para>The track entry for the previous animation when mixing from the previous animation to this animation, or NULL if no</para>
            /// <para>mixing is currently occuring. When mixing from multiple animations, MixingFrom makes up a double linked list with MixingTo.</para>
            /// </summary>
            public global::spine_cpp.Spine.TrackEntry MixingFrom
            {
                get
                {
                    var ___ret = __Internal.GetMixingFrom(__Instance);
                    var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>
            /// <para>The track entry for the next animation when mixing from this animation, or NULL if no mixing is currently occuring.</para>
            /// <para>When mixing from multiple animations, MixingTo makes up a double linked list with MixingFrom.</para>
            /// </summary>
            public global::spine_cpp.Spine.TrackEntry MixingTo
            {
                get
                {
                    var ___ret = __Internal.GetMixingTo(__Instance);
                    var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public float TrackComplete
            {
                get
                {
                    var ___ret = __Internal.GetTrackComplete(__Instance);
                    return ___ret;
                }
            }

            public __IntPtr RendererObject
            {
                get
                {
                    var ___ret = __Internal.GetRendererObject(__Instance + 8);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // virtual ~TrackEntry()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.TrackEntry.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[2];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[2];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0), *(IntPtr*)(instance + 8) };
                                VTables.Methods = new Delegate[2][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTablesDtorOnly[1] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 8, 1, 0);
                                ManagedVTablesDtorOnly[1][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                                ManagedVTables[1] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 8, 1, 0);
                                ManagedVTables[1][0] = Thunks[0];
                                VTables.Methods[1] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        *(IntPtr**)(instance + 8) = ManagedVTablesDtorOnly[1];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        *(IntPtr**)(instance + 8) = ManagedVTables[1];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0), *(IntPtr*)(__Instance + 8) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class EventQueueEntry : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.EventType _type;
                internal __IntPtr _entry;
                internal __IntPtr _event;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0EventQueueEntry@spine@@QEAA@W4EventType@1@PEAVTrackEntry@1@PEAVEvent@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, global::spine_cpp.Spine.EventType eventType, __IntPtr trackEntry, __IntPtr @event);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0EventQueueEntry@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new EventQueueEntry __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new EventQueueEntry(native.ToPointer(), skipVTables);
            }

            internal static new EventQueueEntry __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (EventQueueEntry)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new EventQueueEntry __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (EventQueueEntry)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static EventQueueEntry __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new EventQueueEntry(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.EventQueueEntry.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private EventQueueEntry(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected EventQueueEntry(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public EventQueueEntry(global::spine_cpp.Spine.EventType eventType, global::spine_cpp.Spine.TrackEntry trackEntry, global::spine_cpp.Spine.Event @event)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.EventQueueEntry.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg1 = trackEntry is null ? __IntPtr.Zero : trackEntry.__Instance;
                var __arg2 = @event is null ? __IntPtr.Zero : @event.__Instance;
                __Internal.ctor(__Instance, eventType, __arg1, __arg2);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.EventQueueEntry");
            }

            public EventQueueEntry(global::spine_cpp.Spine.EventQueueEntry _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.EventQueueEntry.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.EventQueueEntry");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::spine_cpp.Spine.EventType Type
            {
                get
                {
                    return ((__Internal*)__Instance)->_type;
                }

                set
                {
                    ((__Internal*)__Instance)->_type = value;
                }
            }

            public global::spine_cpp.Spine.TrackEntry Entry
            {
                get
                {
                    var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(((__Internal*)__Instance)->_entry, true);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->_entry = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            public global::spine_cpp.Spine.Event Event
            {
                get
                {
                    var __result0 = global::spine_cpp.Spine.Event.__GetOrCreateInstance(((__Internal*)__Instance)->_event, true);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->_event = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            #region Virtual table interop

            // EventQueueEntry
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.EventQueueEntry.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class EventQueue : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 56)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _eventQueueEntries;
                internal __IntPtr _state;
                internal byte _drainDisabled;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0EventQueue@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new EventQueue __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new EventQueue(native.ToPointer(), skipVTables);
            }

            internal static new EventQueue __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (EventQueue)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new EventQueue __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (EventQueue)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static EventQueue __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new EventQueue(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.EventQueue.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private EventQueue(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected EventQueue(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public EventQueue(global::spine_cpp.Spine.EventQueue _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.EventQueue.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.EventQueue");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~EventQueue()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.EventQueue.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class AnimationState : global::spine_cpp.Spine.SpineObject, global::spine_cpp.Spine.IHasRendererObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 216)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr vfptr_HasRendererObject;
                internal __IntPtr _rendererObject;
                internal __IntPtr _dispose;
                internal __IntPtr _data;
                internal global::spine_cpp.Spine.Pool.__Internalc__N_spine_S_Pool____N_spine_S_TrackEntry _trackEntryPool;
                internal global::spine_cpp.Spine.Vector.__Internal _tracks;
                internal global::spine_cpp.Spine.Vector.__Internal _events;
                internal __IntPtr _queue;
                internal global::spine_cpp.Spine.HashMap.__Internal _propertyIDs;
                internal byte _animationsChanged;
                internal __IntPtr _listener;
                internal __IntPtr _listenerObject;
                internal int _unkeyedState;
                internal float _timeScale;
                internal byte _manualTrackEntryDisposal;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AnimationState@spine@@QEAA@PEAVAnimationStateData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr data);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AnimationState@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?update@AnimationState@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Update(__IntPtr __instance, float delta);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?apply@AnimationState@spine@@QEAA_NAEAVSkeleton@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Apply(__IntPtr __instance, __IntPtr skeleton);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearTracks@AnimationState@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearTracks(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clearTrack@AnimationState@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearTrack(__IntPtr __instance, ulong trackIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAnimation@AnimationState@spine@@QEAAPEAVTrackEntry@2@_KAEBVString@2@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr SetAnimation(__IntPtr __instance, ulong trackIndex, __IntPtr animationName, bool loop);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAnimation@AnimationState@spine@@QEAAPEAVTrackEntry@2@_KPEAVAnimation@2@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr SetAnimation_1(__IntPtr __instance, ulong trackIndex, __IntPtr animation, bool loop);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAnimation@AnimationState@spine@@QEAAPEAVTrackEntry@2@_KAEBVString@2@_NM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr AddAnimation(__IntPtr __instance, ulong trackIndex, __IntPtr animationName, bool loop, float delay);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addAnimation@AnimationState@spine@@QEAAPEAVTrackEntry@2@_KPEAVAnimation@2@_NM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr AddAnimation_1(__IntPtr __instance, ulong trackIndex, __IntPtr animation, bool loop, float delay);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setEmptyAnimation@AnimationState@spine@@QEAAPEAVTrackEntry@2@_KM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr SetEmptyAnimation(__IntPtr __instance, ulong trackIndex, float mixDuration);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addEmptyAnimation@AnimationState@spine@@QEAAPEAVTrackEntry@2@_KMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr AddEmptyAnimation(__IntPtr __instance, ulong trackIndex, float mixDuration, float delay);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setEmptyAnimations@AnimationState@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetEmptyAnimations(__IntPtr __instance, float mixDuration);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCurrent@AnimationState@spine@@QEAAPEAVTrackEntry@2@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetCurrent(__IntPtr __instance, ulong trackIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setListener@AnimationState@spine@@QEAAXP6AXPEAV12@W4EventType@2@PEAVTrackEntry@2@PEAVEvent@2@@Z@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetListener(__IntPtr __instance, __IntPtr listener);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setListener@AnimationState@spine@@QEAAXPEAVAnimationStateListenerObject@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetListener_1(__IntPtr __instance, __IntPtr listener);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?disableQueue@AnimationState@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DisableQueue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?enableQueue@AnimationState@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnableQueue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?disposeTrackEntry@AnimationState@spine@@QEAAXPEAVTrackEntry@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DisposeTrackEntry(__IntPtr __instance, __IntPtr entry);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setRendererObject@HasRendererObject@spine@@QEAAXPEAXP6AX0@Z@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRendererObject(__IntPtr __instance, __IntPtr rendererObject, __IntPtr dispose);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getData@AnimationState@spine@@QEAAPEAVAnimationStateData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTracks@AnimationState@spine@@QEAAAEAV?$Vector@PEAVTrackEntry@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTracks(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTimeScale@AnimationState@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetTimeScale(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setTimeScale@AnimationState@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTimeScale(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getManualTrackEntryDisposal@AnimationState@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetManualTrackEntryDisposal(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setManualTrackEntryDisposal@AnimationState@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetManualTrackEntryDisposal(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getRendererObject@HasRendererObject@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRendererObject(__IntPtr __instance);
            }

            internal static new AnimationState __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AnimationState(native.ToPointer(), skipVTables);
            }

            internal static new AnimationState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AnimationState)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new AnimationState __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AnimationState)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AnimationState __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AnimationState(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.AnimationState.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private AnimationState(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected AnimationState(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public AnimationState(global::spine_cpp.Spine.AnimationStateData data)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AnimationState.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = data is null ? __IntPtr.Zero : data.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AnimationState");
            }

            public AnimationState(global::spine_cpp.Spine.AnimationState _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AnimationState.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AnimationState");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                *(IntPtr*)(__Instance + 8) = __VTables.Tables[1];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Increments the track entry times, setting queued animations as current if needed</summary>
            /// <param name="delta">delta time</param>
            public void Update(float delta)
            {
                __Internal.Update(__Instance, delta);
            }

            /// <summary>
            /// <para>Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the</para>
            /// <para>animation state can be applied to multiple skeletons to pose them identically.</para>
            /// </summary>
            public bool Apply(global::spine_cpp.Spine.Skeleton skeleton)
            {
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var ___ret = __Internal.Apply(__Instance, __arg0);
                return ___ret;
            }

            /// <summary>
            /// <para>Removes all animations from all tracks, leaving skeletons in their previous pose.</para>
            /// <para>It may be desired to use AnimationState.setEmptyAnimations(float) to mix the skeletons back to the setup pose,</para>
            /// <para>rather than leaving them in their previous pose.</para>
            /// </summary>
            public void ClearTracks()
            {
                __Internal.ClearTracks(__Instance);
            }

            /// <summary>
            /// <para>Removes all animations from the tracks, leaving skeletons in their previous pose.</para>
            /// <para>It may be desired to use AnimationState.setEmptyAnimations(float) to mix the skeletons back to the setup pose,</para>
            /// <para>rather than leaving them in their previous pose.</para>
            /// </summary>
            public void ClearTrack(ulong trackIndex)
            {
                __Internal.ClearTrack(__Instance, trackIndex);
            }

            /// <summary>Sets an animation by name. setAnimation(int, Animation, bool)</summary>
            public global::spine_cpp.Spine.TrackEntry SetAnimation(ulong trackIndex, global::spine_cpp.Spine.String animationName, bool loop)
            {
                if (ReferenceEquals(animationName, null))
                    throw new global::System.ArgumentNullException("animationName", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = animationName.__Instance;
                var ___ret = __Internal.SetAnimation(__Instance, trackIndex, __arg1, loop);
                var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Sets the current animation for a track, discarding any queued animations.</summary>
            /// <param name="loop">
            /// <para>If true, the animation will repeat.</para>
            /// <para>If false, it will not, instead its last frame is applied if played beyond its duration.</para>
            /// <para>In either case TrackEntry.TrackEnd determines when the track is cleared.</para>
            /// </param>
            /// <returns>
            /// <para>A track entry to allow further customization of animation playback. References to the track entry must not be kept</para>
            /// <para>after AnimationState.Dispose.</para>
            /// </returns>
            public global::spine_cpp.Spine.TrackEntry SetAnimation(ulong trackIndex, global::spine_cpp.Spine.Animation animation, bool loop)
            {
                var __arg1 = animation is null ? __IntPtr.Zero : animation.__Instance;
                var ___ret = __Internal.SetAnimation_1(__Instance, trackIndex, __arg1, loop);
                var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>
            /// <para>Queues an animation by name.</para>
            /// <para>addAnimation(int, Animation, bool, float)</para>
            /// </summary>
            public global::spine_cpp.Spine.TrackEntry AddAnimation(ulong trackIndex, global::spine_cpp.Spine.String animationName, bool loop, float delay)
            {
                if (ReferenceEquals(animationName, null))
                    throw new global::System.ArgumentNullException("animationName", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = animationName.__Instance;
                var ___ret = __Internal.AddAnimation(__Instance, trackIndex, __arg1, loop, delay);
                var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>
            /// <para>Adds an animation to be played delay seconds after the current or last queued animation</para>
            /// <para>for a track. If the track is empty, it is equivalent to calling setAnimation.</para>
            /// </summary>
            /// <param name="delay">
            /// <para>Seconds to begin this animation after the start of the previous animation. May be&lt;= 0 to use the animation</para>
            /// <para>duration of the previous track minus any mix duration plus the negative delay.</para>
            /// </param>
            /// <returns>
            /// <para>A track entry to allow further customization of animation playback. References to the track entry must not be kept</para>
            /// <para>after AnimationState.Dispose</para>
            /// </returns>
            public global::spine_cpp.Spine.TrackEntry AddAnimation(ulong trackIndex, global::spine_cpp.Spine.Animation animation, bool loop, float delay)
            {
                var __arg1 = animation is null ? __IntPtr.Zero : animation.__Instance;
                var ___ret = __Internal.AddAnimation_1(__Instance, trackIndex, __arg1, loop, delay);
                var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Sets an empty animation for a track, discarding any queued animations, and mixes to it over the specified mix duration.</summary>
            public global::spine_cpp.Spine.TrackEntry SetEmptyAnimation(ulong trackIndex, float mixDuration)
            {
                var ___ret = __Internal.SetEmptyAnimation(__Instance, trackIndex, mixDuration);
                var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>
            /// <para>Adds an empty animation to be played after the current or last queued animation for a track, and mixes to it over the</para>
            /// <para>specified mix duration.</para>
            /// </summary>
            /// <param name="trackIndex">Track number.</param>
            /// <param name="mixDuration">Mix duration.</param>
            /// <param name="delay">
            /// <para>Seconds to begin this animation after the start of the previous animation. May be&lt;= 0 to use the animation</para>
            /// <para>duration of the previous track minus any mix duration plus the negative delay.</para>
            /// </param>
            /// <returns>A track entry to allow further customization of animation playback. References to the track entry must not be kept after AnimationState.Dispose.</returns>
            public global::spine_cpp.Spine.TrackEntry AddEmptyAnimation(ulong trackIndex, float mixDuration, float delay)
            {
                var ___ret = __Internal.AddEmptyAnimation(__Instance, trackIndex, mixDuration, delay);
                var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix duration.</summary>
            public void SetEmptyAnimations(float mixDuration)
            {
                __Internal.SetEmptyAnimations(__Instance, mixDuration);
            }

            /// <returns>The track entry for the animation currently playing on the track, or NULL if no animation is currently playing.</returns>
            public global::spine_cpp.Spine.TrackEntry GetCurrent(ulong trackIndex)
            {
                var ___ret = __Internal.GetCurrent(__Instance, trackIndex);
                var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public void SetListener(global::spine_cpp.Spine.AnimationStateListener listener)
            {
                var __arg0 = listener == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(listener);
                __Internal.SetListener(__Instance, __arg0);
            }

            public void SetListener(global::spine_cpp.Spine.AnimationStateListenerObject listener)
            {
                var __arg0 = listener is null ? __IntPtr.Zero : listener.__Instance;
                __Internal.SetListener_1(__Instance, __arg0);
            }

            public void DisableQueue()
            {
                __Internal.DisableQueue(__Instance);
            }

            public void EnableQueue()
            {
                __Internal.EnableQueue(__Instance);
            }

            public void DisposeTrackEntry(global::spine_cpp.Spine.TrackEntry entry)
            {
                var __arg0 = entry is null ? __IntPtr.Zero : entry.__Instance;
                __Internal.DisposeTrackEntry(__Instance, __arg0);
            }

            public static explicit operator global::spine_cpp.Spine.AnimationState(global::spine_cpp.Spine.AnimationStateData data)
            {
                return new global::spine_cpp.Spine.AnimationState(data);
            }

            public void SetRendererObject(__IntPtr rendererObject, global::spine_cpp.Spine.DisposeRendererObject dispose)
            {
                var __arg1 = dispose == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(dispose);
                __Internal.SetRendererObject(__Instance + 8, rendererObject, __arg1);
            }

            public __IntPtr __PointerToHasRendererObject
            {
                get
                {
                    return __Instance + 8;
                }
            }

            public global::spine_cpp.Spine.AnimationStateData Data
            {
                get
                {
                    var ___ret = __Internal.GetData(__Instance);
                    var __result0 = global::spine_cpp.Spine.AnimationStateData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>A list of tracks that have animations, which may contain NULLs.</summary>
            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.TrackEntry> Tracks
            {
                get
                {
                    var ___ret = __Internal.GetTracks(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.TrackEntry>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public float TimeScale
            {
                get
                {
                    var ___ret = __Internal.GetTimeScale(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetTimeScale(__Instance, value);
                }
            }

            public bool ManualTrackEntryDisposal
            {
                get
                {
                    var ___ret = __Internal.GetManualTrackEntryDisposal(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetManualTrackEntryDisposal(__Instance, value);
                }
            }

            public __IntPtr RendererObject
            {
                get
                {
                    var ___ret = __Internal.GetRendererObject(__Instance + 8);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // ~AnimationState()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.AnimationState.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[2];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[2];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0), *(IntPtr*)(instance + 8) };
                                VTables.Methods = new Delegate[2][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTablesDtorOnly[1] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 8, 1, 0);
                                ManagedVTablesDtorOnly[1][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                                ManagedVTables[1] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 8, 1, 0);
                                ManagedVTables[1][0] = Thunks[0];
                                VTables.Methods[1] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        *(IntPtr**)(instance + 8) = ManagedVTablesDtorOnly[1];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        *(IntPtr**)(instance + 8) = ManagedVTables[1];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0), *(IntPtr*)(__Instance + 8) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class AnimationStateListenerObjectInternal : global::spine_cpp.Spine.AnimationStateListenerObject, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal AnimationStateListenerObjectInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal AnimationStateListenerObjectInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>The callback function to be called</summary>
            public override void Callback(global::spine_cpp.Spine.AnimationState state, global::spine_cpp.Spine.EventType type, global::spine_cpp.Spine.TrackEntry entry, global::spine_cpp.Spine.Event @event)
            {
                var ___CallbackDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_spine_cpp_spine_EventType___IntPtr___IntPtr>(0, 1);
                var __arg0 = state is null ? __IntPtr.Zero : state.__Instance;
                var __arg2 = entry is null ? __IntPtr.Zero : entry.__Instance;
                var __arg3 = @event is null ? __IntPtr.Zero : @event.__Instance;
                ___CallbackDelegate(__Instance, __arg0, type, __arg2, __arg3);
            }
        }
    }

    namespace Spine
    {
        /// <summary>Stores mix (crossfade) durations to be applied when AnimationState animations are changed.</summary>
        public unsafe partial class AnimationStateData : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 48)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _skeletonData;
                internal float _defaultMix;
                internal global::spine_cpp.Spine.HashMap.__Internal _animationToMixTime;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AnimationStateData@spine@@QEAA@PEAVSkeletonData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr skeletonData);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AnimationStateData@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMix@AnimationStateData@spine@@QEAAXAEBVString@2@0M@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMix(__IntPtr __instance, __IntPtr fromName, __IntPtr toName, float duration);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMix@AnimationStateData@spine@@QEAAXPEAVAnimation@2@0M@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMix_1(__IntPtr __instance, __IntPtr from, __IntPtr to, float duration);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMix@AnimationStateData@spine@@QEAAMPEAVAnimation@2@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMix(__IntPtr __instance, __IntPtr from, __IntPtr to);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clear@AnimationStateData@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clear(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSkeletonData@AnimationStateData@spine@@QEAAPEAVSkeletonData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSkeletonData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getDefaultMix@AnimationStateData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetDefaultMix(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setDefaultMix@AnimationStateData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDefaultMix(__IntPtr __instance, float inValue);
            }

            public unsafe partial class AnimationPair
            {
                [StructLayout(LayoutKind.Sequential, Size = 24)]
                public partial struct __Internal
                {
                    internal __IntPtr vfptr_SpineObject;
                    internal __IntPtr _a1;
                    internal __IntPtr _a2;
                }
            }

            internal static new AnimationStateData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AnimationStateData(native.ToPointer(), skipVTables);
            }

            internal static new AnimationStateData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AnimationStateData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new AnimationStateData __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AnimationStateData)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AnimationStateData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AnimationStateData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.AnimationStateData.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private AnimationStateData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected AnimationStateData(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public AnimationStateData(global::spine_cpp.Spine.SkeletonData skeletonData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AnimationStateData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = skeletonData is null ? __IntPtr.Zero : skeletonData.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AnimationStateData");
            }

            public AnimationStateData(global::spine_cpp.Spine.AnimationStateData _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AnimationStateData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AnimationStateData");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Sets a mix duration by animation names.</summary>
            public void SetMix(global::spine_cpp.Spine.String fromName, global::spine_cpp.Spine.String toName, float duration)
            {
                if (ReferenceEquals(fromName, null))
                    throw new global::System.ArgumentNullException("fromName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = fromName.__Instance;
                if (ReferenceEquals(toName, null))
                    throw new global::System.ArgumentNullException("toName", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = toName.__Instance;
                __Internal.SetMix(__Instance, __arg0, __arg1, duration);
            }

            /// <summary>
            /// <para>Sets a mix duration when changing from the specified animation to the other.</para>
            /// <para>See TrackEntry.MixDuration.</para>
            /// </summary>
            public void SetMix(global::spine_cpp.Spine.Animation from, global::spine_cpp.Spine.Animation to, float duration)
            {
                var __arg0 = from is null ? __IntPtr.Zero : from.__Instance;
                var __arg1 = to is null ? __IntPtr.Zero : to.__Instance;
                __Internal.SetMix_1(__Instance, __arg0, __arg1, duration);
            }

            /// <summary>
            /// <para>The mix duration to use when changing from the specified animation to the other,</para>
            /// <para>or the DefaultMix if no mix duration has been set.</para>
            /// </summary>
            public float GetMix(global::spine_cpp.Spine.Animation from, global::spine_cpp.Spine.Animation to)
            {
                var __arg0 = from is null ? __IntPtr.Zero : from.__Instance;
                var __arg1 = to is null ? __IntPtr.Zero : to.__Instance;
                var ___ret = __Internal.GetMix(__Instance, __arg0, __arg1);
                return ___ret;
            }

            /// <summary>Removes all mixes and sets the default mix to 0.</summary>
            public void Clear()
            {
                __Internal.Clear(__Instance);
            }

            public static explicit operator global::spine_cpp.Spine.AnimationStateData(global::spine_cpp.Spine.SkeletonData skeletonData)
            {
                return new global::spine_cpp.Spine.AnimationStateData(skeletonData);
            }

            /// <summary>The SkeletonData to look up animations when they are specified by name.</summary>
            public global::spine_cpp.Spine.SkeletonData SkeletonData
            {
                get
                {
                    var ___ret = __Internal.GetSkeletonData(__Instance);
                    var __result0 = global::spine_cpp.Spine.SkeletonData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>The mix duration to use when no mix duration has been specifically defined between two animations.</summary>
            public float DefaultMix
            {
                get
                {
                    var ___ret = __Internal.GetDefaultMix(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetDefaultMix(__Instance, value);
                }
            }

            #region Virtual table interop

            // AnimationStateData
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.AnimationStateData.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class TextureRegion : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 64)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr rendererObject;
                internal float u;
                internal float v;
                internal float u2;
                internal float v2;
                internal int degrees;
                internal float offsetX;
                internal float offsetY;
                internal int width;
                internal int height;
                internal int originalWidth;
                internal int originalHeight;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0TextureRegion@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0TextureRegion@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new TextureRegion __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TextureRegion(native.ToPointer(), skipVTables);
            }

            internal static new TextureRegion __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TextureRegion)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new TextureRegion __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (TextureRegion)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static TextureRegion __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TextureRegion(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.TextureRegion.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private TextureRegion(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TextureRegion(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public TextureRegion()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TextureRegion.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TextureRegion");
            }

            public TextureRegion(global::spine_cpp.Spine.TextureRegion _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TextureRegion.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TextureRegion");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public __IntPtr RendererObject
            {
                get
                {
                    return ((__Internal*)__Instance)->rendererObject;
                }

                set
                {
                    ((__Internal*)__Instance)->rendererObject = (__IntPtr) value;
                }
            }

            public float U
            {
                get
                {
                    return ((__Internal*)__Instance)->u;
                }

                set
                {
                    ((__Internal*)__Instance)->u = value;
                }
            }

            public float V
            {
                get
                {
                    return ((__Internal*)__Instance)->v;
                }

                set
                {
                    ((__Internal*)__Instance)->v = value;
                }
            }

            public float U2
            {
                get
                {
                    return ((__Internal*)__Instance)->u2;
                }

                set
                {
                    ((__Internal*)__Instance)->u2 = value;
                }
            }

            public float V2
            {
                get
                {
                    return ((__Internal*)__Instance)->v2;
                }

                set
                {
                    ((__Internal*)__Instance)->v2 = value;
                }
            }

            public int Degrees
            {
                get
                {
                    return ((__Internal*)__Instance)->degrees;
                }

                set
                {
                    ((__Internal*)__Instance)->degrees = value;
                }
            }

            public float OffsetX
            {
                get
                {
                    return ((__Internal*)__Instance)->offsetX;
                }

                set
                {
                    ((__Internal*)__Instance)->offsetX = value;
                }
            }

            public float OffsetY
            {
                get
                {
                    return ((__Internal*)__Instance)->offsetY;
                }

                set
                {
                    ((__Internal*)__Instance)->offsetY = value;
                }
            }

            public int Width
            {
                get
                {
                    return ((__Internal*)__Instance)->width;
                }

                set
                {
                    ((__Internal*)__Instance)->width = value;
                }
            }

            public int Height
            {
                get
                {
                    return ((__Internal*)__Instance)->height;
                }

                set
                {
                    ((__Internal*)__Instance)->height = value;
                }
            }

            public int OriginalWidth
            {
                get
                {
                    return ((__Internal*)__Instance)->originalWidth;
                }

                set
                {
                    ((__Internal*)__Instance)->originalWidth = value;
                }
            }

            public int OriginalHeight
            {
                get
                {
                    return ((__Internal*)__Instance)->originalHeight;
                }

                set
                {
                    ((__Internal*)__Instance)->originalHeight = value;
                }
            }

            #region Virtual table interop

            // ~TextureRegion()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.TextureRegion.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public enum Format
        {
            FormatAlpha = 0,
            FormatIntensity = 1,
            FormatLuminanceAlpha = 2,
            FormatRGB565 = 3,
            FormatRGBA4444 = 4,
            FormatRGB888 = 5,
            FormatRGBA8888 = 6
        }

        public enum TextureFilter
        {
            TextureFilterUnknown = 0,
            TextureFilterNearest = 1,
            TextureFilterLinear = 2,
            TextureFilterMipMap = 3,
            TextureFilterMipMapNearestNearest = 4,
            TextureFilterMipMapLinearNearest = 5,
            TextureFilterMipMapNearestLinear = 6,
            TextureFilterMipMapLinearLinear = 7
        }

        public enum TextureWrap
        {
            TextureWrapMirroredRepeat = 0,
            TextureWrapClampToEdge = 1,
            TextureWrapRepeat = 2
        }

        public unsafe partial class AtlasPage : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal name;
                internal global::spine_cpp.Spine.String.__Internal texturePath;
                internal global::spine_cpp.Spine.Format format;
                internal global::spine_cpp.Spine.TextureFilter minFilter;
                internal global::spine_cpp.Spine.TextureFilter magFilter;
                internal global::spine_cpp.Spine.TextureWrap uWrap;
                internal global::spine_cpp.Spine.TextureWrap vWrap;
                internal int width;
                internal int height;
                internal byte pma;
                internal int index;
                internal __IntPtr texture;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AtlasPage@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr inName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AtlasPage@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new AtlasPage __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AtlasPage(native.ToPointer(), skipVTables);
            }

            internal static new AtlasPage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AtlasPage)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new AtlasPage __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AtlasPage)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AtlasPage __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AtlasPage(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.AtlasPage.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private AtlasPage(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected AtlasPage(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public AtlasPage(global::spine_cpp.Spine.String inName)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AtlasPage.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(inName, null))
                    throw new global::System.ArgumentNullException("inName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = inName.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AtlasPage");
            }

            public AtlasPage(global::spine_cpp.Spine.AtlasPage _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AtlasPage.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AtlasPage");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.AtlasPage(global::spine_cpp.Spine.String inName)
            {
                return new global::spine_cpp.Spine.AtlasPage(inName);
            }

            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    return global::spine_cpp.Spine.String.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->name));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->name = *(global::spine_cpp.Spine.String.__Internal*) value.__Instance;
                }
            }

            public global::spine_cpp.Spine.String TexturePath
            {
                get
                {
                    return global::spine_cpp.Spine.String.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->texturePath));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->texturePath = *(global::spine_cpp.Spine.String.__Internal*) value.__Instance;
                }
            }

            public global::spine_cpp.Spine.Format Format
            {
                get
                {
                    return ((__Internal*)__Instance)->format;
                }

                set
                {
                    ((__Internal*)__Instance)->format = value;
                }
            }

            public global::spine_cpp.Spine.TextureFilter MinFilter
            {
                get
                {
                    return ((__Internal*)__Instance)->minFilter;
                }

                set
                {
                    ((__Internal*)__Instance)->minFilter = value;
                }
            }

            public global::spine_cpp.Spine.TextureFilter MagFilter
            {
                get
                {
                    return ((__Internal*)__Instance)->magFilter;
                }

                set
                {
                    ((__Internal*)__Instance)->magFilter = value;
                }
            }

            public global::spine_cpp.Spine.TextureWrap UWrap
            {
                get
                {
                    return ((__Internal*)__Instance)->uWrap;
                }

                set
                {
                    ((__Internal*)__Instance)->uWrap = value;
                }
            }

            public global::spine_cpp.Spine.TextureWrap VWrap
            {
                get
                {
                    return ((__Internal*)__Instance)->vWrap;
                }

                set
                {
                    ((__Internal*)__Instance)->vWrap = value;
                }
            }

            public int Width
            {
                get
                {
                    return ((__Internal*)__Instance)->width;
                }

                set
                {
                    ((__Internal*)__Instance)->width = value;
                }
            }

            public int Height
            {
                get
                {
                    return ((__Internal*)__Instance)->height;
                }

                set
                {
                    ((__Internal*)__Instance)->height = value;
                }
            }

            public bool Pma
            {
                get
                {
                    return ((__Internal*)__Instance)->pma != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->pma = (byte) (value ? 1 : 0);
                }
            }

            public int Index
            {
                get
                {
                    return ((__Internal*)__Instance)->index;
                }

                set
                {
                    ((__Internal*)__Instance)->index = value;
                }
            }

            public __IntPtr Texture
            {
                get
                {
                    return ((__Internal*)__Instance)->texture;
                }

                set
                {
                    ((__Internal*)__Instance)->texture = (__IntPtr) value;
                }
            }

            #region Virtual table interop

            // AtlasPage
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.AtlasPage.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class AtlasRegion : global::spine_cpp.Spine.TextureRegion, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 248)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr rendererObject;
                internal float u;
                internal float v;
                internal float u2;
                internal float v2;
                internal int degrees;
                internal float offsetX;
                internal float offsetY;
                internal int width;
                internal int height;
                internal int originalWidth;
                internal int originalHeight;
                internal __IntPtr page;
                internal global::spine_cpp.Spine.String.__Internal name;
                internal int index;
                internal int x;
                internal int y;
                internal global::spine_cpp.Spine.Vector.__Internal splits;
                internal global::spine_cpp.Spine.Vector.__Internal pads;
                internal global::spine_cpp.Spine.Vector.__Internal names;
                internal global::spine_cpp.Spine.Vector.__Internal values;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AtlasRegion@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AtlasRegion@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new AtlasRegion __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AtlasRegion(native.ToPointer(), skipVTables);
            }

            internal static new AtlasRegion __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AtlasRegion)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new AtlasRegion __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AtlasRegion)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AtlasRegion __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AtlasRegion(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.AtlasRegion.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private AtlasRegion(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected AtlasRegion(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public AtlasRegion(global::spine_cpp.Spine.AtlasRegion _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AtlasRegion.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AtlasRegion");
            }

            public AtlasRegion()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AtlasRegion.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AtlasRegion");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::spine_cpp.Spine.AtlasPage Page
            {
                get
                {
                    var __result0 = global::spine_cpp.Spine.AtlasPage.__GetOrCreateInstance(((__Internal*)__Instance)->page, true);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->page = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    return global::spine_cpp.Spine.String.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->name));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->name = *(global::spine_cpp.Spine.String.__Internal*) value.__Instance;
                }
            }

            public int Index
            {
                get
                {
                    return ((__Internal*)__Instance)->index;
                }

                set
                {
                    ((__Internal*)__Instance)->index = value;
                }
            }

            public int X
            {
                get
                {
                    return ((__Internal*)__Instance)->x;
                }

                set
                {
                    ((__Internal*)__Instance)->x = value;
                }
            }

            public int Y
            {
                get
                {
                    return ((__Internal*)__Instance)->y;
                }

                set
                {
                    ((__Internal*)__Instance)->y = value;
                }
            }

            public global::spine_cpp.Spine.Vector<int> Splits
            {
                get
                {
                    return global::spine_cpp.Spine.Vector<int>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->splits));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->splits = *(global::spine_cpp.Spine.Vector.__Internal*) value.__Instance;
                }
            }

            public global::spine_cpp.Spine.Vector<int> Pads
            {
                get
                {
                    return global::spine_cpp.Spine.Vector<int>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->pads));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->pads = *(global::spine_cpp.Spine.Vector.__Internal*) value.__Instance;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.String> Names
            {
                get
                {
                    return global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.String>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->names));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->names = *(global::spine_cpp.Spine.Vector.__Internal*) value.__Instance;
                }
            }

            public global::spine_cpp.Spine.Vector<float> Values
            {
                get
                {
                    return global::spine_cpp.Spine.Vector<float>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->values));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->values = *(global::spine_cpp.Spine.Vector.__Internal*) value.__Instance;
                }
            }

            #region Virtual table interop

            // AtlasRegion
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.AtlasRegion.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class Atlas : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 80)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _pages;
                internal global::spine_cpp.Spine.Vector.__Internal _regions;
                internal __IntPtr _textureLoader;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Atlas@spine@@QEAA@AEBVString@1@PEAVTextureLoader@1@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr path, __IntPtr textureLoader, bool createTexture);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Atlas@spine@@QEAA@PEBDH0PEAVTextureLoader@1@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string data, int length, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string dir, __IntPtr textureLoader, bool createTexture);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Atlas@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?flipV@Atlas@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void FlipV(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?findRegion@Atlas@spine@@QEAAPEAVAtlasRegion@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindRegion(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getPages@Atlas@spine@@QEAAAEAV?$Vector@PEAVAtlasPage@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetPages(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getRegions@Atlas@spine@@QEAAAEAV?$Vector@PEAVAtlasRegion@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRegions(__IntPtr __instance);
            }

            internal static new Atlas __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Atlas(native.ToPointer(), skipVTables);
            }

            internal static new Atlas __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Atlas)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Atlas __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Atlas)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Atlas __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Atlas(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Atlas.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Atlas(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Atlas(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Atlas(global::spine_cpp.Spine.String path, global::spine_cpp.Spine.TextureLoader textureLoader, bool createTexture)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Atlas.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = path.__Instance;
                var __arg1 = textureLoader is null ? __IntPtr.Zero : textureLoader.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1, createTexture);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Atlas");
            }

            public Atlas(string data, int length, string dir, global::spine_cpp.Spine.TextureLoader textureLoader, bool createTexture)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Atlas.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg3 = textureLoader is null ? __IntPtr.Zero : textureLoader.__Instance;
                __Internal.ctor(__Instance, data, length, dir, __arg3, createTexture);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Atlas");
            }

            public Atlas(global::spine_cpp.Spine.Atlas _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Atlas.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Atlas");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void FlipV()
            {
                __Internal.FlipV(__Instance);
            }

            /// <summary>
            /// <para>Returns the first region found with the specified name. This method uses String comparison to find the region, so the result</para>
            /// <para>should be cached rather than calling this method multiple times.</para>
            /// </summary>
            /// <returns>The region, or NULL.</returns>
            public global::spine_cpp.Spine.AtlasRegion FindRegion(global::spine_cpp.Spine.String name)
            {
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                var ___ret = __Internal.FindRegion(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.AtlasRegion.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.AtlasPage> Pages
            {
                get
                {
                    var ___ret = __Internal.GetPages(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.AtlasPage>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.AtlasRegion> Regions
            {
                get
                {
                    var ___ret = __Internal.GetRegions(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.AtlasRegion>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // ~Atlas()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Atlas.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class RTTI : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr _className;
                internal __IntPtr _pBaseRTTI;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0RTTI@spine@@QEAA@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string className);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0RTTI@spine@@QEAA@PEBDAEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string className, __IntPtr baseRTTI);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?isExactly@RTTI@spine@@QEBA_NAEBV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsExactly(__IntPtr __instance, __IntPtr rtti);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?instanceOf@RTTI@spine@@QEBA_NAEBV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool InstanceOf(__IntPtr __instance, __IntPtr rtti);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getClassName@RTTI@spine@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetClassName(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.RTTI> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.RTTI>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.Spine.RTTI managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.Spine.RTTI managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static RTTI __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new RTTI(native.ToPointer(), skipVTables);
            }

            internal static RTTI __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (RTTI)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static RTTI __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new RTTI(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private RTTI(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected RTTI(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public RTTI(string className)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RTTI.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, className);
            }

            public RTTI(string className, global::spine_cpp.Spine.RTTI baseRTTI)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RTTI.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(baseRTTI, null))
                    throw new global::System.ArgumentNullException("baseRTTI", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = baseRTTI.__Instance;
                __Internal.ctor(__Instance, className, __arg1);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public bool IsExactly(global::spine_cpp.Spine.RTTI rtti)
            {
                if (ReferenceEquals(rtti, null))
                    throw new global::System.ArgumentNullException("rtti", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = rtti.__Instance;
                var ___ret = __Internal.IsExactly(__Instance, __arg0);
                return ___ret;
            }

            public bool InstanceOf(global::spine_cpp.Spine.RTTI rtti)
            {
                if (ReferenceEquals(rtti, null))
                    throw new global::System.ArgumentNullException("rtti", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = rtti.__Instance;
                var ___ret = __Internal.InstanceOf(__Instance, __arg0);
                return ___ret;
            }

            public static explicit operator global::spine_cpp.Spine.RTTI(string className)
            {
                return new global::spine_cpp.Spine.RTTI(className);
            }

            public string ClassName
            {
                get
                {
                    var ___ret = __Internal.GetClassName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }
        }
    }

    namespace Spine
    {
        public unsafe abstract partial class AttachmentLoader : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AttachmentLoader@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AttachmentLoader@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new AttachmentLoader __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AttachmentLoaderInternal(native.ToPointer(), skipVTables);
            }

            internal static new AttachmentLoader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AttachmentLoader)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new AttachmentLoader __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AttachmentLoader)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AttachmentLoader __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AttachmentLoaderInternal(native, skipVTables);
            }

            protected AttachmentLoader(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected AttachmentLoader()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AttachmentLoader.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AttachmentLoader");
            }

            protected AttachmentLoader(global::spine_cpp.Spine.AttachmentLoader _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AttachmentLoader.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AttachmentLoader");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <returns>May be NULL to not load any attachment.</returns>
            public abstract global::spine_cpp.Spine.RegionAttachment NewRegionAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.String path, global::spine_cpp.Spine.Sequence sequence);

            /// <returns>May be NULL to not load any attachment.</returns>
            public abstract global::spine_cpp.Spine.MeshAttachment NewMeshAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.String path, global::spine_cpp.Spine.Sequence sequence);

            /// <returns>May be NULL to not load any attachment.</returns>
            public abstract global::spine_cpp.Spine.BoundingBoxAttachment NewBoundingBoxAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name);

            /// <returns>May be NULL to not load any attachment</returns>
            public abstract global::spine_cpp.Spine.PathAttachment NewPathAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name);

            public abstract global::spine_cpp.Spine.PointAttachment NewPointAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name);

            public abstract global::spine_cpp.Spine.ClippingAttachment NewClippingAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name);

            public abstract void ConfigureAttachment(global::spine_cpp.Spine.Attachment attachment);

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_AttachmentLoader_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public virtual global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    var ___GetRTTIDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 1);
                    var ___ret = ___GetRTTIDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.RTTI.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            #region Virtual table interop

            // virtual ~AttachmentLoader()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.AttachmentLoader.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.AttachmentLoader.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // RegionAttachment *newRegionAttachment(Skin &skin, const String &name, const String &path, Sequence *sequence) = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr _NewRegionAttachmentDelegateInstance;

            private static __IntPtr _NewRegionAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name, __IntPtr path, __IntPtr sequence)
            {
                var __target = global::spine_cpp.Spine.AttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var __result2 = global::spine_cpp.Spine.String.__GetOrCreateInstance(path, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Sequence.__GetOrCreateInstance(sequence, false, skipVTables: true);
                var ___ret = __target.NewRegionAttachment(__result0, __result1, __result2, __result3);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // MeshAttachment *newMeshAttachment(Skin &skin, const String &name, const String &path, Sequence *sequence) = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr _NewMeshAttachmentDelegateInstance;

            private static __IntPtr _NewMeshAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name, __IntPtr path, __IntPtr sequence)
            {
                var __target = global::spine_cpp.Spine.AttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var __result2 = global::spine_cpp.Spine.String.__GetOrCreateInstance(path, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Sequence.__GetOrCreateInstance(sequence, false, skipVTables: true);
                var ___ret = __target.NewMeshAttachment(__result0, __result1, __result2, __result3);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // BoundingBoxAttachment *newBoundingBoxAttachment(Skin &skin, const String &name) = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr _NewBoundingBoxAttachmentDelegateInstance;

            private static __IntPtr _NewBoundingBoxAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name)
            {
                var __target = global::spine_cpp.Spine.AttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var ___ret = __target.NewBoundingBoxAttachment(__result0, __result1);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // PathAttachment *newPathAttachment(Skin &skin, const String &name) = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr _NewPathAttachmentDelegateInstance;

            private static __IntPtr _NewPathAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name)
            {
                var __target = global::spine_cpp.Spine.AttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var ___ret = __target.NewPathAttachment(__result0, __result1);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // PointAttachment *newPointAttachment(Skin &skin, const String &name) = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr _NewPointAttachmentDelegateInstance;

            private static __IntPtr _NewPointAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name)
            {
                var __target = global::spine_cpp.Spine.AttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var ___ret = __target.NewPointAttachment(__result0, __result1);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // ClippingAttachment *newClippingAttachment(Skin &skin, const String &name) = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr _NewClippingAttachmentDelegateInstance;

            private static __IntPtr _NewClippingAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name)
            {
                var __target = global::spine_cpp.Spine.AttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var ___ret = __target.NewClippingAttachment(__result0, __result1);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // void configureAttachment(Attachment *attachment) = 0
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr _ConfigureAttachmentDelegateInstance;

            private static void _ConfigureAttachmentDelegateHook(__IntPtr __instance, __IntPtr attachment)
            {
                var __target = global::spine_cpp.Spine.AttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(attachment, false, skipVTables: true);
                __target.ConfigureAttachment(__result0);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[9];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _NewRegionAttachmentDelegateInstance += _NewRegionAttachmentDelegateHook;
                    _NewMeshAttachmentDelegateInstance += _NewMeshAttachmentDelegateHook;
                    _NewBoundingBoxAttachmentDelegateInstance += _NewBoundingBoxAttachmentDelegateHook;
                    _NewPathAttachmentDelegateInstance += _NewPathAttachmentDelegateHook;
                    _NewPointAttachmentDelegateInstance += _NewPointAttachmentDelegateHook;
                    _NewClippingAttachmentDelegateInstance += _NewClippingAttachmentDelegateHook;
                    _ConfigureAttachmentDelegateInstance += _ConfigureAttachmentDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_NewRegionAttachmentDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_NewMeshAttachmentDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_NewBoundingBoxAttachmentDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_NewPathAttachmentDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_NewPointAttachmentDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_NewClippingAttachmentDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_ConfigureAttachmentDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 9, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 9, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                VTables.Methods[0] = new Delegate[9];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class AttachmentLoaderInternal : global::spine_cpp.Spine.AttachmentLoader, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal AttachmentLoaderInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal AttachmentLoaderInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <returns>May be NULL to not load any attachment.</returns>
            public override global::spine_cpp.Spine.RegionAttachment NewRegionAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.String path, global::spine_cpp.Spine.Sequence sequence)
            {
                var ___NewRegionAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr>(0, 2);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = path.__Instance;
                var __arg3 = sequence is null ? __IntPtr.Zero : sequence.__Instance;
                var ___ret = ___NewRegionAttachmentDelegate(__Instance, __arg0, __arg1, __arg2, __arg3);
                var __result0 = global::spine_cpp.Spine.RegionAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL to not load any attachment.</returns>
            public override global::spine_cpp.Spine.MeshAttachment NewMeshAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.String path, global::spine_cpp.Spine.Sequence sequence)
            {
                var ___NewMeshAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr>(0, 3);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = path.__Instance;
                var __arg3 = sequence is null ? __IntPtr.Zero : sequence.__Instance;
                var ___ret = ___NewMeshAttachmentDelegate(__Instance, __arg0, __arg1, __arg2, __arg3);
                var __result0 = global::spine_cpp.Spine.MeshAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL to not load any attachment.</returns>
            public override global::spine_cpp.Spine.BoundingBoxAttachment NewBoundingBoxAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name)
            {
                var ___NewBoundingBoxAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr>(0, 4);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var ___ret = ___NewBoundingBoxAttachmentDelegate(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.BoundingBoxAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL to not load any attachment</returns>
            public override global::spine_cpp.Spine.PathAttachment NewPathAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name)
            {
                var ___NewPathAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr>(0, 5);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var ___ret = ___NewPathAttachmentDelegate(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.PathAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override global::spine_cpp.Spine.PointAttachment NewPointAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name)
            {
                var ___NewPointAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr>(0, 6);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var ___ret = ___NewPointAttachmentDelegate(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.PointAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override global::spine_cpp.Spine.ClippingAttachment NewClippingAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name)
            {
                var ___NewClippingAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr>(0, 7);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var ___ret = ___NewClippingAttachmentDelegate(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.ClippingAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override void ConfigureAttachment(global::spine_cpp.Spine.Attachment attachment)
            {
                var ___ConfigureAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr>(0, 8);
                var __arg0 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
                ___ConfigureAttachmentDelegate(__Instance, __arg0);
            }
        }
    }

    namespace Spine
    {
        /// <summary>
        /// <para>An AttachmentLoader that configures attachments using texture regions from an Atlas.</para>
        /// <para>See http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data about Loading Skeleton Data in the Spine Runtimes Guide.</para>
        /// </summary>
        public unsafe partial class AtlasAttachmentLoader : global::spine_cpp.Spine.AttachmentLoader, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _atlas;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AtlasAttachmentLoader@spine@@QEAA@PEAVAtlas@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr atlas);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AtlasAttachmentLoader@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?findRegion@AtlasAttachmentLoader@spine@@QEAAPEAVAtlasRegion@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindRegion(__IntPtr __instance, __IntPtr name);
            }

            internal static new AtlasAttachmentLoader __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AtlasAttachmentLoader(native.ToPointer(), skipVTables);
            }

            internal static new AtlasAttachmentLoader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AtlasAttachmentLoader)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new AtlasAttachmentLoader __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AtlasAttachmentLoader)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AtlasAttachmentLoader __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AtlasAttachmentLoader(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.AtlasAttachmentLoader.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private AtlasAttachmentLoader(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected AtlasAttachmentLoader(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public AtlasAttachmentLoader(global::spine_cpp.Spine.Atlas atlas)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AtlasAttachmentLoader.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = atlas is null ? __IntPtr.Zero : atlas.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AtlasAttachmentLoader");
            }

            public AtlasAttachmentLoader(global::spine_cpp.Spine.AtlasAttachmentLoader _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AtlasAttachmentLoader.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AtlasAttachmentLoader");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override global::spine_cpp.Spine.RegionAttachment NewRegionAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.String path, global::spine_cpp.Spine.Sequence sequence)
            {
                var ___NewRegionAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr>(0, 2);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = path.__Instance;
                var __arg3 = sequence is null ? __IntPtr.Zero : sequence.__Instance;
                var ___ret = ___NewRegionAttachmentDelegate(__Instance, __arg0, __arg1, __arg2, __arg3);
                var __result0 = global::spine_cpp.Spine.RegionAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override global::spine_cpp.Spine.MeshAttachment NewMeshAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.String path, global::spine_cpp.Spine.Sequence sequence)
            {
                var ___NewMeshAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr>(0, 3);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = path.__Instance;
                var __arg3 = sequence is null ? __IntPtr.Zero : sequence.__Instance;
                var ___ret = ___NewMeshAttachmentDelegate(__Instance, __arg0, __arg1, __arg2, __arg3);
                var __result0 = global::spine_cpp.Spine.MeshAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override global::spine_cpp.Spine.BoundingBoxAttachment NewBoundingBoxAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name)
            {
                var ___NewBoundingBoxAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr>(0, 4);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var ___ret = ___NewBoundingBoxAttachmentDelegate(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.BoundingBoxAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override global::spine_cpp.Spine.PathAttachment NewPathAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name)
            {
                var ___NewPathAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr>(0, 5);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var ___ret = ___NewPathAttachmentDelegate(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.PathAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override global::spine_cpp.Spine.PointAttachment NewPointAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name)
            {
                var ___NewPointAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr>(0, 6);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var ___ret = ___NewPointAttachmentDelegate(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.PointAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override global::spine_cpp.Spine.ClippingAttachment NewClippingAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name)
            {
                var ___NewClippingAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr>(0, 7);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var ___ret = ___NewClippingAttachmentDelegate(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.ClippingAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override void ConfigureAttachment(global::spine_cpp.Spine.Attachment attachment)
            {
                var ___ConfigureAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr>(0, 8);
                var __arg0 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
                ___ConfigureAttachmentDelegate(__Instance, __arg0);
            }

            public global::spine_cpp.Spine.AtlasRegion FindRegion(global::spine_cpp.Spine.String name)
            {
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                var ___ret = __Internal.FindRegion(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.AtlasRegion.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public static explicit operator global::spine_cpp.Spine.AtlasAttachmentLoader(global::spine_cpp.Spine.Atlas atlas)
            {
                return new global::spine_cpp.Spine.AtlasAttachmentLoader(atlas);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_AtlasAttachmentLoader_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            #region Virtual table interop

            // AtlasAttachmentLoader
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.AtlasAttachmentLoader.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.AtlasAttachmentLoader.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // RegionAttachment *newRegionAttachment(Skin &skin, const String &name, const String &path, Sequence *sequence)
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr _NewRegionAttachmentDelegateInstance;

            private static __IntPtr _NewRegionAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name, __IntPtr path, __IntPtr sequence)
            {
                var __target = global::spine_cpp.Spine.AtlasAttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var __result2 = global::spine_cpp.Spine.String.__GetOrCreateInstance(path, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Sequence.__GetOrCreateInstance(sequence, false, skipVTables: true);
                var ___ret = __target.NewRegionAttachment(__result0, __result1, __result2, __result3);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // MeshAttachment *newMeshAttachment(Skin &skin, const String &name, const String &path, Sequence *sequence)
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr _NewMeshAttachmentDelegateInstance;

            private static __IntPtr _NewMeshAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name, __IntPtr path, __IntPtr sequence)
            {
                var __target = global::spine_cpp.Spine.AtlasAttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var __result2 = global::spine_cpp.Spine.String.__GetOrCreateInstance(path, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Sequence.__GetOrCreateInstance(sequence, false, skipVTables: true);
                var ___ret = __target.NewMeshAttachment(__result0, __result1, __result2, __result3);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // BoundingBoxAttachment *newBoundingBoxAttachment(Skin &skin, const String &name)
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr _NewBoundingBoxAttachmentDelegateInstance;

            private static __IntPtr _NewBoundingBoxAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name)
            {
                var __target = global::spine_cpp.Spine.AtlasAttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var ___ret = __target.NewBoundingBoxAttachment(__result0, __result1);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // PathAttachment *newPathAttachment(Skin &skin, const String &name)
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr _NewPathAttachmentDelegateInstance;

            private static __IntPtr _NewPathAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name)
            {
                var __target = global::spine_cpp.Spine.AtlasAttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var ___ret = __target.NewPathAttachment(__result0, __result1);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // PointAttachment *newPointAttachment(Skin &skin, const String &name)
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr _NewPointAttachmentDelegateInstance;

            private static __IntPtr _NewPointAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name)
            {
                var __target = global::spine_cpp.Spine.AtlasAttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var ___ret = __target.NewPointAttachment(__result0, __result1);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // ClippingAttachment *newClippingAttachment(Skin &skin, const String &name)
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr _NewClippingAttachmentDelegateInstance;

            private static __IntPtr _NewClippingAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name)
            {
                var __target = global::spine_cpp.Spine.AtlasAttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var ___ret = __target.NewClippingAttachment(__result0, __result1);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // void configureAttachment(Attachment *attachment)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr _ConfigureAttachmentDelegateInstance;

            private static void _ConfigureAttachmentDelegateHook(__IntPtr __instance, __IntPtr attachment)
            {
                var __target = global::spine_cpp.Spine.AtlasAttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(attachment, false, skipVTables: true);
                __target.ConfigureAttachment(__result0);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[9];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _NewRegionAttachmentDelegateInstance += _NewRegionAttachmentDelegateHook;
                    _NewMeshAttachmentDelegateInstance += _NewMeshAttachmentDelegateHook;
                    _NewBoundingBoxAttachmentDelegateInstance += _NewBoundingBoxAttachmentDelegateHook;
                    _NewPathAttachmentDelegateInstance += _NewPathAttachmentDelegateHook;
                    _NewPointAttachmentDelegateInstance += _NewPointAttachmentDelegateHook;
                    _NewClippingAttachmentDelegateInstance += _NewClippingAttachmentDelegateHook;
                    _ConfigureAttachmentDelegateInstance += _ConfigureAttachmentDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_NewRegionAttachmentDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_NewMeshAttachmentDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_NewBoundingBoxAttachmentDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_NewPathAttachmentDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_NewPointAttachmentDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_NewClippingAttachmentDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_ConfigureAttachmentDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 9, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 9, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                VTables.Methods[0] = new Delegate[9];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe abstract partial class Attachment : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 48)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal int _refCount;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Attachment@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Attachment@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?reference@Attachment@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Reference(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?dereference@Attachment@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Dereference(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getName@Attachment@spine@@QEBAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getRefCount@Attachment@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetRefCount(__IntPtr __instance);
            }

            internal static new Attachment __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AttachmentInternal(native.ToPointer(), skipVTables);
            }

            internal static new Attachment __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Attachment)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Attachment __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Attachment)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Attachment __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AttachmentInternal(native, skipVTables);
            }

            protected Attachment(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected Attachment(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Attachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Attachment");
            }

            protected Attachment(global::spine_cpp.Spine.Attachment _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Attachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Attachment");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Reference()
            {
                __Internal.Reference(__Instance);
            }

            public void Dereference()
            {
                __Internal.Dereference(__Instance);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_Attachment_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public virtual global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    var ___GetRTTIDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 1);
                    var ___ret = ___GetRTTIDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.RTTI.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public abstract global::spine_cpp.Spine.Attachment Copy
            {
                get;
            }

            public int RefCount
            {
                get
                {
                    var ___ret = __Internal.GetRefCount(__Instance);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // virtual ~Attachment()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Attachment.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Attachment.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // Attachment *copy() = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Attachment.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class AttachmentInternal : global::spine_cpp.Spine.Attachment, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal AttachmentInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal AttachmentInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override global::spine_cpp.Spine.Attachment Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___CopyDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }
        }
    }

    namespace Spine
    {
        public unsafe abstract partial class Timeline : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 80)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Timeline@spine@@QEAA@_K0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong frameEntries);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Timeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setPropertyIds@Timeline@spine@@IEAAXQEA_J_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPropertyIds(__IntPtr __instance, long[] propertyIds, ulong propertyIdsCount);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getFrameEntries@Timeline@spine@@QEAA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetFrameEntries(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getFrameCount@Timeline@spine@@QEAA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetFrameCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getFrames@Timeline@spine@@QEAAAEAV?$Vector@M@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetFrames(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getDuration@Timeline@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetDuration(__IntPtr __instance);
            }

            internal static new Timeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TimelineInternal(native.ToPointer(), skipVTables);
            }

            internal static new Timeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Timeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Timeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Timeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Timeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TimelineInternal(native, skipVTables);
            }

            protected Timeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected Timeline(ulong frameCount, ulong frameEntries)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Timeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, frameEntries);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Timeline");
            }

            protected Timeline(global::spine_cpp.Spine.Timeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Timeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Timeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Sets the value(s) for the specified time.</summary>
            /// <param name="skeleton">The skeleton the timeline is being applied to. This provides access to the bones, slots, and other skeleton components the timeline may change.</param>
            /// <param name="lastTime">lastTime The time this timeline was last applied. Timelines such as EventTimeline trigger only at specific times rather than every frame. In that case, the timeline triggers everything between lastTime (exclusive) and time (inclusive).</param>
            /// <param name="time">The time within the animation. Most timelines find the key before and the key after this time so they can interpolate between the keys.</param>
            /// <param name="pEvents">If any events are fired, they are added to this array. Can be NULL to ignore firing events or if the timeline does not fire events. May be NULL.</param>
            /// <param name="alpha">
            /// <para>alpha 0 applies the current or setup pose value (depending on pose parameter). 1 applies the timeline</para>
            /// <para>value. Between 0 and 1 applies a value between the current or setup pose and the timeline value. By adjusting alpha over</para>
            /// <para>time, an animation can be mixed in or out. alpha can also be useful to apply animations on top of each other (layered).</para>
            /// </param>
            /// <param name="blend">Controls how mixing is applied when alpha is than 1.</param>
            /// <param name="direction">Indicates whether the timeline is mixing in or out. Used by timelines which perform instant transitions such as DrawOrderTimeline and AttachmentTimeline.</param>
            public abstract void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction);

            protected void SetPropertyIds(long[] propertyIds, ulong propertyIdsCount)
            {
                __Internal.SetPropertyIds(__Instance, propertyIds, propertyIdsCount);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_Timeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected global::spine_cpp.Spine.Vector<long> _propertyIds
            {
                get
                {
                    return global::spine_cpp.Spine.Vector<long>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_propertyIds));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->_propertyIds = *(global::spine_cpp.Spine.Vector.__Internal*) value.__Instance;
                }
            }

            protected global::spine_cpp.Spine.Vector<float> _frames
            {
                get
                {
                    return global::spine_cpp.Spine.Vector<float>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_frames));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->_frames = *(global::spine_cpp.Spine.Vector.__Internal*) value.__Instance;
                }
            }

            protected ulong _frameEntries
            {
                get
                {
                    return ((__Internal*)__Instance)->_frameEntries;
                }

                set
                {
                    ((__Internal*)__Instance)->_frameEntries = value;
                }
            }

            public virtual global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    var ___GetRTTIDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 1);
                    var ___ret = ___GetRTTIDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.RTTI.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public ulong FrameEntries
            {
                get
                {
                    var ___ret = __Internal.GetFrameEntries(__Instance);
                    return ___ret;
                }
            }

            public ulong FrameCount
            {
                get
                {
                    var ___ret = __Internal.GetFrameCount(__Instance);
                    return ___ret;
                }
            }

            public global::spine_cpp.Spine.Vector<float> Frames
            {
                get
                {
                    var ___ret = __Internal.GetFrames(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<float>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public float Duration
            {
                get
                {
                    var ___ret = __Internal.GetDuration(__Instance);
                    return ___ret;
                }
            }

            public virtual global::spine_cpp.Spine.Vector<long> PropertyIds
            {
                get
                {
                    var ___GetPropertyIdsDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 3);
                    var ___ret = ___GetPropertyIdsDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<long>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // virtual ~Timeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Timeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Timeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction) = 0
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.Timeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Timeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[4];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                VTables.Methods[0] = new Delegate[4];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class TimelineInternal : global::spine_cpp.Spine.Timeline, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal TimelineInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal TimelineInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Sets the value(s) for the specified time.</summary>
            /// <param name="skeleton">The skeleton the timeline is being applied to. This provides access to the bones, slots, and other skeleton components the timeline may change.</param>
            /// <param name="lastTime">lastTime The time this timeline was last applied. Timelines such as EventTimeline trigger only at specific times rather than every frame. In that case, the timeline triggers everything between lastTime (exclusive) and time (inclusive).</param>
            /// <param name="time">The time within the animation. Most timelines find the key before and the key after this time so they can interpolate between the keys.</param>
            /// <param name="pEvents">If any events are fired, they are added to this array. Can be NULL to ignore firing events or if the timeline does not fire events. May be NULL.</param>
            /// <param name="alpha">
            /// <para>alpha 0 applies the current or setup pose value (depending on pose parameter). 1 applies the timeline</para>
            /// <para>value. Between 0 and 1 applies a value between the current or setup pose and the timeline value. By adjusting alpha over</para>
            /// <para>time, an animation can be mixed in or out. alpha can also be useful to apply animations on top of each other (layered).</para>
            /// </param>
            /// <param name="blend">Controls how mixing is applied when alpha is than 1.</param>
            /// <param name="direction">Indicates whether the timeline is mixing in or out. Used by timelines which perform instant transitions such as DrawOrderTimeline and AttachmentTimeline.</param>
            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }
        }
    }

    namespace Spine
    {
        public unsafe partial class AttachmentTimeline : global::spine_cpp.Spine.Timeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal int _slotIndex;
                internal global::spine_cpp.Spine.Vector.__Internal _attachmentNames;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AttachmentTimeline@spine@@QEAA@_KH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, int slotIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AttachmentTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setFrame@AttachmentTimeline@spine@@QEAAXHMAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, int frame, float time, __IntPtr attachmentName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAttachment@AttachmentTimeline@spine@@IEAAXAEAVSkeleton@2@AEAVSlot@2@PEAVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAttachment(__IntPtr __instance, __IntPtr skeleton, __IntPtr slot, __IntPtr attachmentName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAttachmentNames@AttachmentTimeline@spine@@QEAAAEAV?$Vector@VString@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAttachmentNames(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSlotIndex@AttachmentTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetSlotIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSlotIndex@AttachmentTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSlotIndex(__IntPtr __instance, int inValue);
            }

            internal static new AttachmentTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AttachmentTimeline(native.ToPointer(), skipVTables);
            }

            internal static new AttachmentTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AttachmentTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new AttachmentTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AttachmentTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AttachmentTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AttachmentTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.AttachmentTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private AttachmentTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected AttachmentTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public AttachmentTimeline(ulong frameCount, int slotIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AttachmentTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, slotIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AttachmentTimeline");
            }

            public AttachmentTimeline(global::spine_cpp.Spine.AttachmentTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AttachmentTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AttachmentTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            /// <summary>Sets the time and value of the specified keyframe.</summary>
            public void SetFrame(int frame, float time, global::spine_cpp.Spine.String attachmentName)
            {
                if (ReferenceEquals(attachmentName, null))
                    throw new global::System.ArgumentNullException("attachmentName", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = attachmentName.__Instance;
                __Internal.SetFrame(__Instance, frame, time, __arg2);
            }

            protected void SetAttachment(global::spine_cpp.Spine.Skeleton skeleton, global::spine_cpp.Spine.Slot slot, global::spine_cpp.Spine.String attachmentName)
            {
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                if (ReferenceEquals(slot, null))
                    throw new global::System.ArgumentNullException("slot", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = slot.__Instance;
                var __arg2 = attachmentName is null ? __IntPtr.Zero : attachmentName.__Instance;
                __Internal.SetAttachment(__Instance, __arg0, __arg1, __arg2);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_AttachmentTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected int _slotIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_slotIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_slotIndex = value;
                }
            }

            protected global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.String> _attachmentNames
            {
                get
                {
                    return global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.String>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_attachmentNames));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->_attachmentNames = *(global::spine_cpp.Spine.Vector.__Internal*) value.__Instance;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.String> AttachmentNames
            {
                get
                {
                    var ___ret = __Internal.GetAttachmentNames(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.String>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public int SlotIndex
            {
                get
                {
                    var ___ret = __Internal.GetSlotIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSlotIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~AttachmentTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.AttachmentTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.AttachmentTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.AttachmentTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.AttachmentTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[4];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                VTables.Methods[0] = new Delegate[4];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe abstract partial class Updatable : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Updatable@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Updatable@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new Updatable __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new UpdatableInternal(native.ToPointer(), skipVTables);
            }

            internal static new Updatable __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Updatable)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Updatable __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Updatable)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Updatable __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new UpdatableInternal(native, skipVTables);
            }

            protected Updatable(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected Updatable()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Updatable.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Updatable");
            }

            protected Updatable(global::spine_cpp.Spine.Updatable _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Updatable.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Updatable");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract void Update();

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_Updatable_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public virtual global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    var ___GetRTTIDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 1);
                    var ___ret = ___GetRTTIDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.RTTI.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public abstract bool Active
            {
                get;

                set;
            }

            #region Virtual table interop

            // virtual ~Updatable()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Updatable.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Updatable.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void update() = 0
            private static global::spine_cpp.Delegates.Action___IntPtr _UpdateDelegateInstance;

            private static void _UpdateDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Updatable.__GetInstance(__instance);
                __target.Update();
            }

            // bool isActive() = 0
            private static global::spine_cpp.Delegates.Func_bool___IntPtr _IsActiveDelegateInstance;

            private static bool _IsActiveDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Updatable.__GetInstance(__instance);
                var ___ret = __target.Active;
                return ___ret;
            }

            // void setActive(bool inValue) = 0
            private static global::spine_cpp.Delegates.Action___IntPtr_bool _SetActiveDelegateInstance;

            private static void _SetActiveDelegateHook(__IntPtr __instance, bool inValue)
            {
                var __target = global::spine_cpp.Spine.Updatable.__GetInstance(__instance);
                __target.Active = inValue;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _UpdateDelegateInstance += _UpdateDelegateHook;
                    _IsActiveDelegateInstance += _IsActiveDelegateHook;
                    _SetActiveDelegateInstance += _SetActiveDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_IsActiveDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetActiveDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class UpdatableInternal : global::spine_cpp.Spine.Updatable, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal UpdatableInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal UpdatableInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override void Update()
            {
                var ___UpdateDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr>(0, 2);
                ___UpdateDelegate(__Instance);
            }

            public override bool Active
            {
                get
                {
                    var ___IsActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_bool___IntPtr>(0, 3);
                    var ___ret = ___IsActiveDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_bool>(0, 4);
                    ___SetActiveDelegate(__Instance, value);
                }
            }
        }
    }

    namespace Spine
    {
        /// <summary>Stores a bone's current pose.</summary>
        /// <remarks>
        /// <para>A bone has a local transform which is used to compute its world transform. A bone also has an applied transform, which is a</para>
        /// <para>local transform that can be applied to compute the world transform. The local transform and applied transform may differ if a</para>
        /// <para>constraint or application code modifies the world transform after it was computed from the local transform.</para>
        /// </remarks>
        public unsafe partial class Bone : global::spine_cpp.Spine.Updatable, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 152)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _data;
                internal __IntPtr _skeleton;
                internal __IntPtr _parent;
                internal global::spine_cpp.Spine.Vector.__Internal _children;
                internal float _x;
                internal float _y;
                internal float _rotation;
                internal float _scaleX;
                internal float _scaleY;
                internal float _shearX;
                internal float _shearY;
                internal float _ax;
                internal float _ay;
                internal float _arotation;
                internal float _ascaleX;
                internal float _ascaleY;
                internal float _ashearX;
                internal float _ashearY;
                internal float _a;
                internal float _b;
                internal float _worldX;
                internal float _c;
                internal float _d;
                internal float _worldY;
                internal byte _sorted;
                internal byte _active;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Bone@spine@@QEAA@AEAVBoneData@1@AEAVSkeleton@1@PEAV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr data, __IntPtr skeleton, __IntPtr parent);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Bone@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?updateWorldTransform@Bone@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateWorldTransform(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?updateWorldTransform@Bone@spine@@QEAAXMMMMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateWorldTransform(__IntPtr __instance, float x, float y, float rotation, float scaleX, float scaleY, float shearX, float shearY);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?updateAppliedTransform@Bone@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateAppliedTransform(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setToSetupPose@Bone@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetToSetupPose(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?worldToLocal@Bone@spine@@QEAAXMMAEAM0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void WorldToLocal(__IntPtr __instance, float worldX, float worldY, float* outLocalX, float* outLocalY);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?localToWorld@Bone@spine@@QEAAXMMAEAM0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void LocalToWorld(__IntPtr __instance, float localX, float localY, float* outWorldX, float* outWorldY);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?worldToLocalRotation@Bone@spine@@QEAAMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float WorldToLocalRotation(__IntPtr __instance, float worldRotation);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?localToWorldRotation@Bone@spine@@QEAAMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float LocalToWorldRotation(__IntPtr __instance, float localRotation);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?rotateWorld@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RotateWorld(__IntPtr __instance, float degrees);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?isYDown@Bone@spine@@SA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsYDown();

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setYDown@Bone@spine@@SAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetYDown(bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getWorldToLocalRotationX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWorldToLocalRotationX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getWorldToLocalRotationY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWorldToLocalRotationY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getData@Bone@spine@@QEAAAEAVBoneData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSkeleton@Bone@spine@@QEAAAEAVSkeleton@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSkeleton(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getParent@Bone@spine@@QEAAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetParent(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getChildren@Bone@spine@@QEAAAEAV?$Vector@PEAVBone@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetChildren(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setX@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setY@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getRotation@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetRotation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setRotation@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRotation(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getScaleX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScaleX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setScaleX@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScaleX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getScaleY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScaleY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setScaleY@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScaleY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getShearX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetShearX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setShearX@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetShearX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getShearY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetShearY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setShearY@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetShearY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAppliedRotation@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAppliedRotation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAppliedRotation@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAppliedRotation(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAX@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAY@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAScaleX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAScaleX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAScaleX@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAScaleX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAScaleY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAScaleY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAScaleY@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAScaleY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAShearX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAShearX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAShearX@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAShearX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAShearY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAShearY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAShearY@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAShearY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getA@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetA(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setA@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetA(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getB@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetB(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setB@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetB(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getC@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetC(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setC@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetC(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getD@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetD(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setD@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetD(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getWorldX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWorldX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setWorldX@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWorldX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getWorldY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWorldY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setWorldY@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWorldY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getWorldRotationX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWorldRotationX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getWorldRotationY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWorldRotationY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getWorldScaleX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWorldScaleX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getWorldScaleY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWorldScaleY(__IntPtr __instance);
            }

            internal static new Bone __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Bone(native.ToPointer(), skipVTables);
            }

            internal static new Bone __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Bone)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Bone __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Bone)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Bone __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Bone(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Bone.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Bone(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Bone(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            /// <param name="parent">May be NULL.</param>
            public Bone(global::spine_cpp.Spine.BoneData data, global::spine_cpp.Spine.Skeleton skeleton, global::spine_cpp.Spine.Bone parent)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Bone.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(data, null))
                    throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = data.__Instance;
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = skeleton.__Instance;
                var __arg2 = parent is null ? __IntPtr.Zero : parent.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1, __arg2);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Bone");
            }

            public Bone(global::spine_cpp.Spine.Bone _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Bone.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Bone");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Same as updateWorldTransform. This method exists for Bone to implement Spine::Updatable.</summary>
            public override void Update()
            {
                var ___UpdateDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr>(0, 2);
                ___UpdateDelegate(__Instance);
            }

            /// <summary>Computes the world transform using the parent bone and this bone's local transform.</summary>
            public void UpdateWorldTransform()
            {
                __Internal.UpdateWorldTransform(__Instance);
            }

            /// <summary>Computes the world transform using the parent bone and the specified local transform.</summary>
            public void UpdateWorldTransform(float x, float y, float rotation, float scaleX, float scaleY, float shearX, float shearY)
            {
                __Internal.UpdateWorldTransform(__Instance, x, y, rotation, scaleX, scaleY, shearX, shearY);
            }

            /// <summary>
            /// <para>Computes the individual applied transform values from the world transform. This can be useful to perform processing using</para>
            /// <para>the applied transform after the world transform has been modified directly (eg, by a constraint)..</para>
            /// </summary>
            /// <remarks>Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation.</remarks>
            public void UpdateAppliedTransform()
            {
                __Internal.UpdateAppliedTransform(__Instance);
            }

            public void SetToSetupPose()
            {
                __Internal.SetToSetupPose(__Instance);
            }

            public void WorldToLocal(float worldX, float worldY, ref float outLocalX, ref float outLocalY)
            {
                fixed (float* __outLocalX2 = &outLocalX)
                {
                    var __arg2 = __outLocalX2;
                    fixed (float* __outLocalY3 = &outLocalY)
                    {
                        var __arg3 = __outLocalY3;
                        __Internal.WorldToLocal(__Instance, worldX, worldY, __arg2, __arg3);
                    }
                }
            }

            public void LocalToWorld(float localX, float localY, ref float outWorldX, ref float outWorldY)
            {
                fixed (float* __outWorldX2 = &outWorldX)
                {
                    var __arg2 = __outWorldX2;
                    fixed (float* __outWorldY3 = &outWorldY)
                    {
                        var __arg3 = __outWorldY3;
                        __Internal.LocalToWorld(__Instance, localX, localY, __arg2, __arg3);
                    }
                }
            }

            public float WorldToLocalRotation(float worldRotation)
            {
                var ___ret = __Internal.WorldToLocalRotation(__Instance, worldRotation);
                return ___ret;
            }

            public float LocalToWorldRotation(float localRotation)
            {
                var ___ret = __Internal.LocalToWorldRotation(__Instance, localRotation);
                return ___ret;
            }

            /// <summary>Rotates the world transform the specified amount and sets isAppliedValid to false.</summary>
            /// <param name="degrees">Degrees.</param>
            public void RotateWorld(float degrees)
            {
                __Internal.RotateWorld(__Instance, degrees);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_Bone_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public static bool yDown
            {
                get
                {
                    var ___ret = __Internal.IsYDown();
                    return ___ret;
                }

                set
                {
                    __Internal.SetYDown(value);
                }
            }

            public float WorldToLocalRotationX
            {
                get
                {
                    var ___ret = __Internal.GetWorldToLocalRotationX(__Instance);
                    return ___ret;
                }
            }

            public float WorldToLocalRotationY
            {
                get
                {
                    var ___ret = __Internal.GetWorldToLocalRotationY(__Instance);
                    return ___ret;
                }
            }

            public global::spine_cpp.Spine.BoneData Data
            {
                get
                {
                    var ___ret = __Internal.GetData(__Instance);
                    var __result0 = global::spine_cpp.Spine.BoneData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Skeleton Skeleton
            {
                get
                {
                    var ___ret = __Internal.GetSkeleton(__Instance);
                    var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Bone Parent
            {
                get
                {
                    var ___ret = __Internal.GetParent(__Instance);
                    var __result0 = global::spine_cpp.Spine.Bone.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Bone> Children
            {
                get
                {
                    var ___ret = __Internal.GetChildren(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Bone>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>The local X translation.</summary>
            public float X
            {
                get
                {
                    var ___ret = __Internal.GetX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetX(__Instance, value);
                }
            }

            /// <summary>The local Y translation.</summary>
            public float Y
            {
                get
                {
                    var ___ret = __Internal.GetY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetY(__Instance, value);
                }
            }

            /// <summary>The local rotation.</summary>
            public float Rotation
            {
                get
                {
                    var ___ret = __Internal.GetRotation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetRotation(__Instance, value);
                }
            }

            /// <summary>The local scaleX.</summary>
            public float ScaleX
            {
                get
                {
                    var ___ret = __Internal.GetScaleX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetScaleX(__Instance, value);
                }
            }

            /// <summary>The local scaleY.</summary>
            public float ScaleY
            {
                get
                {
                    var ___ret = __Internal.GetScaleY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetScaleY(__Instance, value);
                }
            }

            /// <summary>The local shearX.</summary>
            public float ShearX
            {
                get
                {
                    var ___ret = __Internal.GetShearX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetShearX(__Instance, value);
                }
            }

            /// <summary>The local shearY.</summary>
            public float ShearY
            {
                get
                {
                    var ___ret = __Internal.GetShearY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetShearY(__Instance, value);
                }
            }

            /// <summary>The rotation, as calculated by any constraints.</summary>
            public float AppliedRotation
            {
                get
                {
                    var ___ret = __Internal.GetAppliedRotation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAppliedRotation(__Instance, value);
                }
            }

            /// <summary>The applied local x translation.</summary>
            public float AX
            {
                get
                {
                    var ___ret = __Internal.GetAX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAX(__Instance, value);
                }
            }

            /// <summary>The applied local y translation.</summary>
            public float AY
            {
                get
                {
                    var ___ret = __Internal.GetAY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAY(__Instance, value);
                }
            }

            /// <summary>The applied local scaleX.</summary>
            public float AScaleX
            {
                get
                {
                    var ___ret = __Internal.GetAScaleX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAScaleX(__Instance, value);
                }
            }

            /// <summary>The applied local scaleY.</summary>
            public float AScaleY
            {
                get
                {
                    var ___ret = __Internal.GetAScaleY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAScaleY(__Instance, value);
                }
            }

            /// <summary>The applied local shearX.</summary>
            public float AShearX
            {
                get
                {
                    var ___ret = __Internal.GetAShearX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAShearX(__Instance, value);
                }
            }

            /// <summary>The applied local shearY.</summary>
            public float AShearY
            {
                get
                {
                    var ___ret = __Internal.GetAShearY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAShearY(__Instance, value);
                }
            }

            public float A
            {
                get
                {
                    var ___ret = __Internal.GetA(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetA(__Instance, value);
                }
            }

            public float B
            {
                get
                {
                    var ___ret = __Internal.GetB(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetB(__Instance, value);
                }
            }

            public float C
            {
                get
                {
                    var ___ret = __Internal.GetC(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetC(__Instance, value);
                }
            }

            public float D
            {
                get
                {
                    var ___ret = __Internal.GetD(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetD(__Instance, value);
                }
            }

            public float WorldX
            {
                get
                {
                    var ___ret = __Internal.GetWorldX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetWorldX(__Instance, value);
                }
            }

            public float WorldY
            {
                get
                {
                    var ___ret = __Internal.GetWorldY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetWorldY(__Instance, value);
                }
            }

            public float WorldRotationX
            {
                get
                {
                    var ___ret = __Internal.GetWorldRotationX(__Instance);
                    return ___ret;
                }
            }

            public float WorldRotationY
            {
                get
                {
                    var ___ret = __Internal.GetWorldRotationY(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the magnitide (always positive) of the world scale X.</summary>
            public float WorldScaleX
            {
                get
                {
                    var ___ret = __Internal.GetWorldScaleX(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the magnitide (always positive) of the world scale Y.</summary>
            public float WorldScaleY
            {
                get
                {
                    var ___ret = __Internal.GetWorldScaleY(__Instance);
                    return ___ret;
                }
            }

            public override bool Active
            {
                get
                {
                    var ___IsActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_bool___IntPtr>(0, 3);
                    var ___ret = ___IsActiveDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_bool>(0, 4);
                    ___SetActiveDelegate(__Instance, value);
                }
            }

            #region Virtual table interop

            // Bone
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Bone.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Bone.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void update()
            private static global::spine_cpp.Delegates.Action___IntPtr _UpdateDelegateInstance;

            private static void _UpdateDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Bone.__GetInstance(__instance);
                __target.Update();
            }

            // bool isActive()
            private static global::spine_cpp.Delegates.Func_bool___IntPtr _IsActiveDelegateInstance;

            private static bool _IsActiveDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Bone.__GetInstance(__instance);
                var ___ret = __target.Active;
                return ___ret;
            }

            // void setActive(bool inValue)
            private static global::spine_cpp.Delegates.Action___IntPtr_bool _SetActiveDelegateInstance;

            private static void _SetActiveDelegateHook(__IntPtr __instance, bool inValue)
            {
                var __target = global::spine_cpp.Spine.Bone.__GetInstance(__instance);
                __target.Active = inValue;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _UpdateDelegateInstance += _UpdateDelegateHook;
                    _IsActiveDelegateInstance += _IsActiveDelegateHook;
                    _SetActiveDelegateInstance += _SetActiveDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_IsActiveDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetActiveDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class BoneData : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal int _index;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal __IntPtr _parent;
                internal float _length;
                internal float _x;
                internal float _y;
                internal float _rotation;
                internal float _scaleX;
                internal float _scaleY;
                internal float _shearX;
                internal float _shearY;
                internal global::spine_cpp.Spine.TransformMode _transformMode;
                internal byte _skinRequired;
                internal global::spine_cpp.Spine.Color.__Internal _color;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0BoneData@spine@@QEAA@HAEBVString@1@PEAV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, int index, __IntPtr name, __IntPtr parent);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0BoneData@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getIndex@BoneData@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getName@BoneData@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getParent@BoneData@spine@@QEAAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetParent(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getLength@BoneData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetLength(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setLength@BoneData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetLength(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getX@BoneData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setX@BoneData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getY@BoneData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setY@BoneData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getRotation@BoneData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetRotation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setRotation@BoneData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRotation(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getScaleX@BoneData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScaleX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setScaleX@BoneData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScaleX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getScaleY@BoneData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScaleY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setScaleY@BoneData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScaleY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getShearX@BoneData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetShearX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setShearX@BoneData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetShearX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getShearY@BoneData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetShearY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setShearY@BoneData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetShearY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTransformMode@BoneData@spine@@QEAA?AW4TransformMode@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::spine_cpp.Spine.TransformMode GetTransformMode(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setTransformMode@BoneData@spine@@QEAAXW4TransformMode@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTransformMode(__IntPtr __instance, global::spine_cpp.Spine.TransformMode inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?isSkinRequired@BoneData@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsSkinRequired(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSkinRequired@BoneData@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSkinRequired(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getColor@BoneData@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);
            }

            internal static new BoneData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new BoneData(native.ToPointer(), skipVTables);
            }

            internal static new BoneData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (BoneData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new BoneData __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (BoneData)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static BoneData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new BoneData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.BoneData.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private BoneData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected BoneData(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public BoneData(int index, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.BoneData parent)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.BoneData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var __arg2 = parent is null ? __IntPtr.Zero : parent.__Instance;
                __Internal.ctor(__Instance, index, __arg1, __arg2);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.BoneData");
            }

            public BoneData(global::spine_cpp.Spine.BoneData _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.BoneData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.BoneData");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>The index of the bone in Skeleton.Bones</summary>
            public int Index
            {
                get
                {
                    var ___ret = __Internal.GetIndex(__Instance);
                    return ___ret;
                }
            }

            /// <summary>The name of the bone, which is unique within the skeleton.</summary>
            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>May be NULL.</summary>
            public global::spine_cpp.Spine.BoneData Parent
            {
                get
                {
                    var ___ret = __Internal.GetParent(__Instance);
                    var __result0 = global::spine_cpp.Spine.BoneData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public float Length
            {
                get
                {
                    var ___ret = __Internal.GetLength(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetLength(__Instance, value);
                }
            }

            /// <summary>Local X translation.</summary>
            public float X
            {
                get
                {
                    var ___ret = __Internal.GetX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetX(__Instance, value);
                }
            }

            /// <summary>Local Y translation.</summary>
            public float Y
            {
                get
                {
                    var ___ret = __Internal.GetY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetY(__Instance, value);
                }
            }

            /// <summary>Local rotation.</summary>
            public float Rotation
            {
                get
                {
                    var ___ret = __Internal.GetRotation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetRotation(__Instance, value);
                }
            }

            /// <summary>Local scaleX.</summary>
            public float ScaleX
            {
                get
                {
                    var ___ret = __Internal.GetScaleX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetScaleX(__Instance, value);
                }
            }

            /// <summary>Local scaleY.</summary>
            public float ScaleY
            {
                get
                {
                    var ___ret = __Internal.GetScaleY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetScaleY(__Instance, value);
                }
            }

            /// <summary>Local shearX.</summary>
            public float ShearX
            {
                get
                {
                    var ___ret = __Internal.GetShearX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetShearX(__Instance, value);
                }
            }

            /// <summary>Local shearY.</summary>
            public float ShearY
            {
                get
                {
                    var ___ret = __Internal.GetShearY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetShearY(__Instance, value);
                }
            }

            /// <summary>The transform mode for how parent world transforms affect this bone.</summary>
            public global::spine_cpp.Spine.TransformMode TransformMode
            {
                get
                {
                    var ___ret = __Internal.GetTransformMode(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetTransformMode(__Instance, value);
                }
            }

            public bool SkinRequired
            {
                get
                {
                    var ___ret = __Internal.IsSkinRequired(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSkinRequired(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // BoneData
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.BoneData.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>An attachment with vertices that are transformed by one or more bones and can be deformed by a slot's vertices.</summary>
        public unsafe abstract partial class VertexAttachment : global::spine_cpp.Spine.Attachment, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 136)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal int _refCount;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal global::spine_cpp.Spine.Vector.__Internal _vertices;
                internal ulong _worldVerticesLength;
                internal __IntPtr _timelineAttachment;
                internal int _id;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0VertexAttachment@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0VertexAttachment@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?computeWorldVertices@VertexAttachment@spine@@QEAAXAEAVSlot@2@PEAM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ComputeWorldVertices(__IntPtr __instance, __IntPtr slot, float* worldVertices);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?computeWorldVertices@VertexAttachment@spine@@QEAAXAEAVSlot@2@AEAV?$Vector@M@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ComputeWorldVertices(__IntPtr __instance, __IntPtr slot, __IntPtr worldVertices);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?copyTo@VertexAttachment@spine@@QEAAXPEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CopyTo(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getId@VertexAttachment@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetId(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBones@VertexAttachment@spine@@QEAAAEAV?$Vector@H@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBones(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getVertices@VertexAttachment@spine@@QEAAAEAV?$Vector@M@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetVertices(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getWorldVerticesLength@VertexAttachment@spine@@QEAA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetWorldVerticesLength(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setWorldVerticesLength@VertexAttachment@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWorldVerticesLength(__IntPtr __instance, ulong inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTimelineAttachment@VertexAttachment@spine@@QEAAPEAVAttachment@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTimelineAttachment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setTimelineAttachment@VertexAttachment@spine@@QEAAXPEAVAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTimelineAttachment(__IntPtr __instance, __IntPtr attachment);
            }

            internal static new VertexAttachment __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new VertexAttachmentInternal(native.ToPointer(), skipVTables);
            }

            internal static new VertexAttachment __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (VertexAttachment)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new VertexAttachment __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (VertexAttachment)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static VertexAttachment __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new VertexAttachmentInternal(native, skipVTables);
            }

            protected VertexAttachment(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected VertexAttachment(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.VertexAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.VertexAttachment");
            }

            protected VertexAttachment(global::spine_cpp.Spine.VertexAttachment _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.VertexAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.VertexAttachment");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void ComputeWorldVertices(global::spine_cpp.Spine.Slot slot, ref float worldVertices)
            {
                if (ReferenceEquals(slot, null))
                    throw new global::System.ArgumentNullException("slot", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slot.__Instance;
                fixed (float* __worldVertices1 = &worldVertices)
                {
                    var __arg1 = __worldVertices1;
                    __Internal.ComputeWorldVertices(__Instance, __arg0, __arg1);
                }
            }

            public void ComputeWorldVertices(global::spine_cpp.Spine.Slot slot, global::spine_cpp.Spine.Vector<float> worldVertices)
            {
                if (ReferenceEquals(slot, null))
                    throw new global::System.ArgumentNullException("slot", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slot.__Instance;
                if (ReferenceEquals(worldVertices, null))
                    throw new global::System.ArgumentNullException("worldVertices", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = worldVertices.__Instance;
                __Internal.ComputeWorldVertices(__Instance, __arg0, __arg1);
            }

            /// <summary>Transforms local vertices to world coordinates.</summary>
            /// <param name="start">The index of the first Vertices value to transform. Each vertex has 2 values, x and y.</param>
            /// <param name="count">The number of world vertex values to output. Must be less than or equal to WorldVerticesLength - start.</param>
            /// <param name="worldVertices">The output world vertices. Must have a length greater than or equal to offset + count.</param>
            /// <param name="offset">The worldVertices index to begin writing values.</param>
            /// <param name="stride">The number of worldVertices entries between the value pairs written.</param>
            public virtual void ComputeWorldVertices(global::spine_cpp.Spine.Slot slot, ulong start, ulong count, ref float worldVertices, ulong offset, ulong stride)
            {
                var ___ComputeWorldVertices_2Delegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_ulong_ulong_floatPtr_ulong_ulong>(0, 4);
                if (ReferenceEquals(slot, null))
                    throw new global::System.ArgumentNullException("slot", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slot.__Instance;
                fixed (float* __worldVertices3 = &worldVertices)
                {
                    var __arg3 = __worldVertices3;
                    ___ComputeWorldVertices_2Delegate(__Instance, __arg0, start, count, __arg3, offset, stride);
                }
            }

            public virtual void ComputeWorldVertices(global::spine_cpp.Spine.Slot slot, ulong start, ulong count, global::spine_cpp.Spine.Vector<float> worldVertices, ulong offset, ulong stride)
            {
                var ___ComputeWorldVertices_3Delegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_ulong_ulong___IntPtr_ulong_ulong>(0, 3);
                if (ReferenceEquals(slot, null))
                    throw new global::System.ArgumentNullException("slot", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slot.__Instance;
                if (ReferenceEquals(worldVertices, null))
                    throw new global::System.ArgumentNullException("worldVertices", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = worldVertices.__Instance;
                ___ComputeWorldVertices_3Delegate(__Instance, __arg0, start, count, __arg3, offset, stride);
            }

            public void CopyTo(global::spine_cpp.Spine.VertexAttachment other)
            {
                var __arg0 = other is null ? __IntPtr.Zero : other.__Instance;
                __Internal.CopyTo(__Instance, __arg0);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_VertexAttachment_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected global::spine_cpp.Spine.Vector<int> _bones
            {
                get
                {
                    return global::spine_cpp.Spine.Vector<int>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_bones));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->_bones = *(global::spine_cpp.Spine.Vector.__Internal*) value.__Instance;
                }
            }

            protected global::spine_cpp.Spine.Vector<float> _vertices
            {
                get
                {
                    return global::spine_cpp.Spine.Vector<float>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_vertices));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->_vertices = *(global::spine_cpp.Spine.Vector.__Internal*) value.__Instance;
                }
            }

            protected ulong _worldVerticesLength
            {
                get
                {
                    return ((__Internal*)__Instance)->_worldVerticesLength;
                }

                set
                {
                    ((__Internal*)__Instance)->_worldVerticesLength = value;
                }
            }

            protected global::spine_cpp.Spine.Attachment _timelineAttachment
            {
                get
                {
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(((__Internal*)__Instance)->_timelineAttachment, true);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->_timelineAttachment = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            /// <summary>Gets a unique ID for this attachment.</summary>
            public int Id
            {
                get
                {
                    var ___ret = __Internal.GetId(__Instance);
                    return ___ret;
                }
            }

            public global::spine_cpp.Spine.Vector<int> Bones
            {
                get
                {
                    var ___ret = __Internal.GetBones(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<int>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<float> Vertices
            {
                get
                {
                    var ___ret = __Internal.GetVertices(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<float>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public ulong WorldVerticesLength
            {
                get
                {
                    var ___ret = __Internal.GetWorldVerticesLength(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetWorldVerticesLength(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.Attachment TimelineAttachment
            {
                get
                {
                    var ___ret = __Internal.GetTimelineAttachment(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetTimelineAttachment(__Instance, __arg0);
                }
            }

            #region Virtual table interop

            // virtual ~VertexAttachment()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.VertexAttachment.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.VertexAttachment.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // Attachment *copy() = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.VertexAttachment.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // void computeWorldVertices(Slot &slot, size_t start, size_t count, Vector<float> &worldVertices, size_t offset, size_t stride = 2)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_ulong_ulong___IntPtr_ulong_ulong _ComputeWorldVertices_3DelegateInstance;

            private static void _ComputeWorldVertices_3DelegateHook(__IntPtr __instance, __IntPtr slot, ulong start, ulong count, __IntPtr worldVertices, ulong offset, ulong stride)
            {
                var __target = global::spine_cpp.Spine.VertexAttachment.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(slot, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<float>.__GetOrCreateInstance(worldVertices, false, skipVTables: true);
                __target.ComputeWorldVertices(__result0, start, count, __result3, offset, stride);
            }

            // void computeWorldVertices(Slot &slot, size_t start, size_t count, float *worldVertices, size_t offset, size_t stride = 2)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_ulong_ulong_floatPtr_ulong_ulong _ComputeWorldVertices_2DelegateInstance;

            private static void _ComputeWorldVertices_2DelegateHook(__IntPtr __instance, __IntPtr slot, ulong start, ulong count, float* worldVertices, ulong offset, ulong stride)
            {
                var __target = global::spine_cpp.Spine.VertexAttachment.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(slot, false, skipVTables: true);
                __target.ComputeWorldVertices(__result0, start, count, ref *worldVertices, offset, stride);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    _ComputeWorldVertices_3DelegateInstance += _ComputeWorldVertices_3DelegateHook;
                    _ComputeWorldVertices_2DelegateInstance += _ComputeWorldVertices_2DelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ComputeWorldVertices_3DelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_ComputeWorldVertices_2DelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class VertexAttachmentInternal : global::spine_cpp.Spine.VertexAttachment, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal VertexAttachmentInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal VertexAttachmentInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override global::spine_cpp.Spine.Attachment Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___CopyDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }
        }
    }

    namespace Spine
    {
        /// <summary>Attachment that has a polygon for bounds checking.</summary>
        public unsafe partial class BoundingBoxAttachment : global::spine_cpp.Spine.VertexAttachment, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 160)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal int _refCount;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal global::spine_cpp.Spine.Vector.__Internal _vertices;
                internal ulong _worldVerticesLength;
                internal __IntPtr _timelineAttachment;
                internal int _id;
                internal global::spine_cpp.Spine.Color.__Internal _color;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0BoundingBoxAttachment@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0BoundingBoxAttachment@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getColor@BoundingBoxAttachment@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);
            }

            internal static new BoundingBoxAttachment __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new BoundingBoxAttachment(native.ToPointer(), skipVTables);
            }

            internal static new BoundingBoxAttachment __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (BoundingBoxAttachment)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new BoundingBoxAttachment __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (BoundingBoxAttachment)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static BoundingBoxAttachment __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new BoundingBoxAttachment(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.BoundingBoxAttachment.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private BoundingBoxAttachment(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected BoundingBoxAttachment(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public BoundingBoxAttachment(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.BoundingBoxAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.BoundingBoxAttachment");
            }

            public BoundingBoxAttachment(global::spine_cpp.Spine.BoundingBoxAttachment _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.BoundingBoxAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.BoundingBoxAttachment");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.BoundingBoxAttachment(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.BoundingBoxAttachment(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_BoundingBoxAttachment_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public override global::spine_cpp.Spine.Attachment Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___CopyDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // BoundingBoxAttachment
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.BoundingBoxAttachment.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.BoundingBoxAttachment.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // Attachment *copy()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.BoundingBoxAttachment.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // void computeWorldVertices(Slot &slot, size_t start, size_t count, Vector<float> &worldVertices, size_t offset, size_t stride = 2)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_ulong_ulong___IntPtr_ulong_ulong _ComputeWorldVertices_3DelegateInstance;

            private static void _ComputeWorldVertices_3DelegateHook(__IntPtr __instance, __IntPtr slot, ulong start, ulong count, __IntPtr worldVertices, ulong offset, ulong stride)
            {
                var __target = global::spine_cpp.Spine.BoundingBoxAttachment.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(slot, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<float>.__GetOrCreateInstance(worldVertices, false, skipVTables: true);
                __target.ComputeWorldVertices(__result0, start, count, __result3, offset, stride);
            }

            // void computeWorldVertices(Slot &slot, size_t start, size_t count, float *worldVertices, size_t offset, size_t stride = 2)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_ulong_ulong_floatPtr_ulong_ulong _ComputeWorldVertices_2DelegateInstance;

            private static void _ComputeWorldVertices_2DelegateHook(__IntPtr __instance, __IntPtr slot, ulong start, ulong count, float* worldVertices, ulong offset, ulong stride)
            {
                var __target = global::spine_cpp.Spine.BoundingBoxAttachment.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(slot, false, skipVTables: true);
                __target.ComputeWorldVertices(__result0, start, count, ref *worldVertices, offset, stride);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    _ComputeWorldVertices_3DelegateInstance += _ComputeWorldVertices_3DelegateHook;
                    _ComputeWorldVertices_2DelegateInstance += _ComputeWorldVertices_2DelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ComputeWorldVertices_3DelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_ComputeWorldVertices_2DelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class ClippingAttachment : global::spine_cpp.Spine.VertexAttachment, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 168)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal int _refCount;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal global::spine_cpp.Spine.Vector.__Internal _vertices;
                internal ulong _worldVerticesLength;
                internal __IntPtr _timelineAttachment;
                internal int _id;
                internal __IntPtr _endSlot;
                internal global::spine_cpp.Spine.Color.__Internal _color;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0ClippingAttachment@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0ClippingAttachment@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getEndSlot@ClippingAttachment@spine@@QEAAPEAVSlotData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetEndSlot(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setEndSlot@ClippingAttachment@spine@@QEAAXPEAVSlotData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetEndSlot(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getColor@ClippingAttachment@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);
            }

            internal static new ClippingAttachment __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ClippingAttachment(native.ToPointer(), skipVTables);
            }

            internal static new ClippingAttachment __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ClippingAttachment)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ClippingAttachment __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ClippingAttachment)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ClippingAttachment __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ClippingAttachment(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.ClippingAttachment.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private ClippingAttachment(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ClippingAttachment(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public ClippingAttachment(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ClippingAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ClippingAttachment");
            }

            public ClippingAttachment(global::spine_cpp.Spine.ClippingAttachment _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ClippingAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ClippingAttachment");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.ClippingAttachment(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.ClippingAttachment(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_ClippingAttachment_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public global::spine_cpp.Spine.SlotData EndSlot
            {
                get
                {
                    var ___ret = __Internal.GetEndSlot(__Instance);
                    var __result0 = global::spine_cpp.Spine.SlotData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetEndSlot(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public override global::spine_cpp.Spine.Attachment Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___CopyDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // ClippingAttachment
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.ClippingAttachment.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ClippingAttachment.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // Attachment *copy()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ClippingAttachment.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // void computeWorldVertices(Slot &slot, size_t start, size_t count, Vector<float> &worldVertices, size_t offset, size_t stride = 2)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_ulong_ulong___IntPtr_ulong_ulong _ComputeWorldVertices_3DelegateInstance;

            private static void _ComputeWorldVertices_3DelegateHook(__IntPtr __instance, __IntPtr slot, ulong start, ulong count, __IntPtr worldVertices, ulong offset, ulong stride)
            {
                var __target = global::spine_cpp.Spine.ClippingAttachment.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(slot, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<float>.__GetOrCreateInstance(worldVertices, false, skipVTables: true);
                __target.ComputeWorldVertices(__result0, start, count, __result3, offset, stride);
            }

            // void computeWorldVertices(Slot &slot, size_t start, size_t count, float *worldVertices, size_t offset, size_t stride = 2)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_ulong_ulong_floatPtr_ulong_ulong _ComputeWorldVertices_2DelegateInstance;

            private static void _ComputeWorldVertices_2DelegateHook(__IntPtr __instance, __IntPtr slot, ulong start, ulong count, float* worldVertices, ulong offset, ulong stride)
            {
                var __target = global::spine_cpp.Spine.ClippingAttachment.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(slot, false, skipVTables: true);
                __target.ComputeWorldVertices(__result0, start, count, ref *worldVertices, offset, stride);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    _ComputeWorldVertices_3DelegateInstance += _ComputeWorldVertices_3DelegateHook;
                    _ComputeWorldVertices_2DelegateInstance += _ComputeWorldVertices_2DelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ComputeWorldVertices_3DelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_ComputeWorldVertices_2DelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>Base class for frames that use an interpolation bezier curve.</summary>
        public unsafe abstract partial class CurveTimeline : global::spine_cpp.Spine.Timeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 112)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0CurveTimeline@spine@@QEAA@_K00@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong frameEntries, ulong bezierCount);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0CurveTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setLinear@CurveTimeline@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetLinear(__IntPtr __instance, ulong frame);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setStepped@CurveTimeline@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetStepped(__IntPtr __instance, ulong frame);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBezierValue@CurveTimeline@spine@@QEAAMM_K00@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetBezierValue(__IntPtr __instance, float time, ulong frame, ulong valueOffset, ulong i);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCurves@CurveTimeline@spine@@QEAAAEAV?$Vector@M@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetCurves(__IntPtr __instance);
            }

            internal static new CurveTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new CurveTimelineInternal(native.ToPointer(), skipVTables);
            }

            internal static new CurveTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (CurveTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new CurveTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (CurveTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static CurveTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new CurveTimelineInternal(native, skipVTables);
            }

            protected CurveTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected CurveTimeline(ulong frameCount, ulong frameEntries, ulong bezierCount)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.CurveTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, frameEntries, bezierCount);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.CurveTimeline");
            }

            protected CurveTimeline(global::spine_cpp.Spine.CurveTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.CurveTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.CurveTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void SetLinear(ulong frame)
            {
                __Internal.SetLinear(__Instance, frame);
            }

            public void SetStepped(ulong frame)
            {
                __Internal.SetStepped(__Instance, frame);
            }

            public virtual void SetBezier(ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var ___SetBezierDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float>(0, 4);
                ___SetBezierDelegate(__Instance, bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            public float GetBezierValue(float time, ulong frame, ulong valueOffset, ulong i)
            {
                var ___ret = __Internal.GetBezierValue(__Instance, time, frame, valueOffset, i);
                return ___ret;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_CurveTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected global::spine_cpp.Spine.Vector<float> _curves
            {
                get
                {
                    return global::spine_cpp.Spine.Vector<float>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_curves));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->_curves = *(global::spine_cpp.Spine.Vector.__Internal*) value.__Instance;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public global::spine_cpp.Spine.Vector<float> Curves
            {
                get
                {
                    var ___ret = __Internal.GetCurves(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<float>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // virtual ~CurveTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction) = 0
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe abstract partial class CurveTimeline1 : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 112)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0CurveTimeline1@spine@@QEAA@_K0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0CurveTimeline1@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setFrame@CurveTimeline1@spine@@QEAAX_KMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, ulong frame, float time, float value);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCurveValue@CurveTimeline1@spine@@QEAAMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetCurveValue(__IntPtr __instance, float time);
            }

            internal static new CurveTimeline1 __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new CurveTimeline1Internal(native.ToPointer(), skipVTables);
            }

            internal static new CurveTimeline1 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (CurveTimeline1)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new CurveTimeline1 __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (CurveTimeline1)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static CurveTimeline1 __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new CurveTimeline1Internal(native, skipVTables);
            }

            protected CurveTimeline1(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected CurveTimeline1(ulong frameCount, ulong bezierCount)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.CurveTimeline1.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.CurveTimeline1");
            }

            protected CurveTimeline1(global::spine_cpp.Spine.CurveTimeline1 _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.CurveTimeline1.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.CurveTimeline1");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void SetFrame(ulong frame, float time, float value)
            {
                __Internal.SetFrame(__Instance, frame, time, value);
            }

            public float GetCurveValue(float time)
            {
                var ___ret = __Internal.GetCurveValue(__Instance, time);
                return ___ret;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_CurveTimeline1_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            #region Virtual table interop

            // virtual ~CurveTimeline1()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline1.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline1.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction) = 0
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline1.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline1.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline1.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe abstract partial class CurveTimeline2 : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 112)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0CurveTimeline2@spine@@QEAA@_K0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0CurveTimeline2@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setFrame@CurveTimeline2@spine@@QEAAX_KMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, ulong frame, float time, float value1, float value2);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCurveValue@CurveTimeline2@spine@@QEAAMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetCurveValue(__IntPtr __instance, float time);
            }

            internal static new CurveTimeline2 __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new CurveTimeline2Internal(native.ToPointer(), skipVTables);
            }

            internal static new CurveTimeline2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (CurveTimeline2)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new CurveTimeline2 __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (CurveTimeline2)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static CurveTimeline2 __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new CurveTimeline2Internal(native, skipVTables);
            }

            protected CurveTimeline2(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected CurveTimeline2(ulong frameCount, ulong bezierCount)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.CurveTimeline2.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.CurveTimeline2");
            }

            protected CurveTimeline2(global::spine_cpp.Spine.CurveTimeline2 _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.CurveTimeline2.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.CurveTimeline2");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void SetFrame(ulong frame, float time, float value1, float value2)
            {
                __Internal.SetFrame(__Instance, frame, time, value1, value2);
            }

            public float GetCurveValue(float time)
            {
                var ___ret = __Internal.GetCurveValue(__Instance, time);
                return ___ret;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_CurveTimeline2_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            #region Virtual table interop

            // virtual ~CurveTimeline2()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline2.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline2.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction) = 0
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline2.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline2.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline2.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class CurveTimelineInternal : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal CurveTimelineInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal CurveTimelineInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Sets the value(s) for the specified time.</summary>
            /// <param name="skeleton">The skeleton the timeline is being applied to. This provides access to the bones, slots, and other skeleton components the timeline may change.</param>
            /// <param name="lastTime">lastTime The time this timeline was last applied. Timelines such as EventTimeline trigger only at specific times rather than every frame. In that case, the timeline triggers everything between lastTime (exclusive) and time (inclusive).</param>
            /// <param name="time">The time within the animation. Most timelines find the key before and the key after this time so they can interpolate between the keys.</param>
            /// <param name="pEvents">If any events are fired, they are added to this array. Can be NULL to ignore firing events or if the timeline does not fire events. May be NULL.</param>
            /// <param name="alpha">
            /// <para>alpha 0 applies the current or setup pose value (depending on pose parameter). 1 applies the timeline</para>
            /// <para>value. Between 0 and 1 applies a value between the current or setup pose and the timeline value. By adjusting alpha over</para>
            /// <para>time, an animation can be mixed in or out. alpha can also be useful to apply animations on top of each other (layered).</para>
            /// </param>
            /// <param name="blend">Controls how mixing is applied when alpha is than 1.</param>
            /// <param name="direction">Indicates whether the timeline is mixing in or out. Used by timelines which perform instant transitions such as DrawOrderTimeline and AttachmentTimeline.</param>
            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }
        }

        public unsafe partial class CurveTimeline1Internal : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal CurveTimeline1Internal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal CurveTimeline1Internal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Sets the value(s) for the specified time.</summary>
            /// <param name="skeleton">The skeleton the timeline is being applied to. This provides access to the bones, slots, and other skeleton components the timeline may change.</param>
            /// <param name="lastTime">lastTime The time this timeline was last applied. Timelines such as EventTimeline trigger only at specific times rather than every frame. In that case, the timeline triggers everything between lastTime (exclusive) and time (inclusive).</param>
            /// <param name="time">The time within the animation. Most timelines find the key before and the key after this time so they can interpolate between the keys.</param>
            /// <param name="pEvents">If any events are fired, they are added to this array. Can be NULL to ignore firing events or if the timeline does not fire events. May be NULL.</param>
            /// <param name="alpha">
            /// <para>alpha 0 applies the current or setup pose value (depending on pose parameter). 1 applies the timeline</para>
            /// <para>value. Between 0 and 1 applies a value between the current or setup pose and the timeline value. By adjusting alpha over</para>
            /// <para>time, an animation can be mixed in or out. alpha can also be useful to apply animations on top of each other (layered).</para>
            /// </param>
            /// <param name="blend">Controls how mixing is applied when alpha is than 1.</param>
            /// <param name="direction">Indicates whether the timeline is mixing in or out. Used by timelines which perform instant transitions such as DrawOrderTimeline and AttachmentTimeline.</param>
            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }
        }

        public unsafe partial class CurveTimeline2Internal : global::spine_cpp.Spine.CurveTimeline2, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal CurveTimeline2Internal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal CurveTimeline2Internal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Sets the value(s) for the specified time.</summary>
            /// <param name="skeleton">The skeleton the timeline is being applied to. This provides access to the bones, slots, and other skeleton components the timeline may change.</param>
            /// <param name="lastTime">lastTime The time this timeline was last applied. Timelines such as EventTimeline trigger only at specific times rather than every frame. In that case, the timeline triggers everything between lastTime (exclusive) and time (inclusive).</param>
            /// <param name="time">The time within the animation. Most timelines find the key before and the key after this time so they can interpolate between the keys.</param>
            /// <param name="pEvents">If any events are fired, they are added to this array. Can be NULL to ignore firing events or if the timeline does not fire events. May be NULL.</param>
            /// <param name="alpha">
            /// <para>alpha 0 applies the current or setup pose value (depending on pose parameter). 1 applies the timeline</para>
            /// <para>value. Between 0 and 1 applies a value between the current or setup pose and the timeline value. By adjusting alpha over</para>
            /// <para>time, an animation can be mixed in or out. alpha can also be useful to apply animations on top of each other (layered).</para>
            /// </param>
            /// <param name="blend">Controls how mixing is applied when alpha is than 1.</param>
            /// <param name="direction">Indicates whether the timeline is mixing in or out. Used by timelines which perform instant transitions such as DrawOrderTimeline and AttachmentTimeline.</param>
            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }
        }
    }

    namespace Spine
    {
        public unsafe partial class RGBATimeline : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _slotIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0RGBATimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int slotIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0RGBATimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setFrame@RGBATimeline@spine@@QEAAXHMMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, int frame, float time, float r, float g, float b, float a);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSlotIndex@RGBATimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetSlotIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSlotIndex@RGBATimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSlotIndex(__IntPtr __instance, int inValue);
            }

            internal static new RGBATimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new RGBATimeline(native.ToPointer(), skipVTables);
            }

            internal static new RGBATimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (RGBATimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new RGBATimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (RGBATimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static RGBATimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new RGBATimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.RGBATimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private RGBATimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected RGBATimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public RGBATimeline(ulong frameCount, ulong bezierCount, int slotIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RGBATimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, slotIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RGBATimeline");
            }

            public RGBATimeline(global::spine_cpp.Spine.RGBATimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RGBATimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RGBATimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            /// <summary>Sets the time and value of the specified keyframe.</summary>
            public void SetFrame(int frame, float time, float r, float g, float b, float a)
            {
                __Internal.SetFrame(__Instance, frame, time, r, g, b, a);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_RGBATimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected int _slotIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_slotIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_slotIndex = value;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int SlotIndex
            {
                get
                {
                    var ___ret = __Internal.GetSlotIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSlotIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~RGBATimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.RGBATimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RGBATimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.RGBATimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RGBATimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.RGBATimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class RGBTimeline : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _slotIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0RGBTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int slotIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0RGBTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setFrame@RGBTimeline@spine@@QEAAXHMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, int frame, float time, float r, float g, float b);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSlotIndex@RGBTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetSlotIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSlotIndex@RGBTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSlotIndex(__IntPtr __instance, int inValue);
            }

            internal static new RGBTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new RGBTimeline(native.ToPointer(), skipVTables);
            }

            internal static new RGBTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (RGBTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new RGBTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (RGBTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static RGBTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new RGBTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.RGBTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private RGBTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected RGBTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public RGBTimeline(ulong frameCount, ulong bezierCount, int slotIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RGBTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, slotIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RGBTimeline");
            }

            public RGBTimeline(global::spine_cpp.Spine.RGBTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RGBTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RGBTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            /// <summary>Sets the time and value of the specified keyframe.</summary>
            public void SetFrame(int frame, float time, float r, float g, float b)
            {
                __Internal.SetFrame(__Instance, frame, time, r, g, b);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_RGBTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected int _slotIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_slotIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_slotIndex = value;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int SlotIndex
            {
                get
                {
                    var ___ret = __Internal.GetSlotIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSlotIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~RGBTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.RGBTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RGBTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.RGBTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RGBTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.RGBTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class AlphaTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _slotIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AlphaTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int slotIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AlphaTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSlotIndex@AlphaTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetSlotIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSlotIndex@AlphaTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSlotIndex(__IntPtr __instance, int inValue);
            }

            internal static new AlphaTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AlphaTimeline(native.ToPointer(), skipVTables);
            }

            internal static new AlphaTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AlphaTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new AlphaTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AlphaTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AlphaTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AlphaTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.AlphaTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private AlphaTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected AlphaTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public AlphaTimeline(ulong frameCount, ulong bezierCount, int slotIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AlphaTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, slotIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AlphaTimeline");
            }

            public AlphaTimeline(global::spine_cpp.Spine.AlphaTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AlphaTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AlphaTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_AlphaTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected int _slotIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_slotIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_slotIndex = value;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int SlotIndex
            {
                get
                {
                    var ___ret = __Internal.GetSlotIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSlotIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~AlphaTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.AlphaTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.AlphaTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.AlphaTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.AlphaTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.AlphaTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class RGBA2Timeline : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _slotIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0RGBA2Timeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int slotIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0RGBA2Timeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setFrame@RGBA2Timeline@spine@@QEAAXHMMMMMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, int frame, float time, float r, float g, float b, float a, float r2, float g2, float b2);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSlotIndex@RGBA2Timeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetSlotIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSlotIndex@RGBA2Timeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSlotIndex(__IntPtr __instance, int inValue);
            }

            internal static new RGBA2Timeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new RGBA2Timeline(native.ToPointer(), skipVTables);
            }

            internal static new RGBA2Timeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (RGBA2Timeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new RGBA2Timeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (RGBA2Timeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static RGBA2Timeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new RGBA2Timeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.RGBA2Timeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private RGBA2Timeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected RGBA2Timeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public RGBA2Timeline(ulong frameCount, ulong bezierCount, int slotIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RGBA2Timeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, slotIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RGBA2Timeline");
            }

            public RGBA2Timeline(global::spine_cpp.Spine.RGBA2Timeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RGBA2Timeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RGBA2Timeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            /// <summary>Sets the time and value of the specified keyframe.</summary>
            public void SetFrame(int frame, float time, float r, float g, float b, float a, float r2, float g2, float b2)
            {
                __Internal.SetFrame(__Instance, frame, time, r, g, b, a, r2, g2, b2);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_RGBA2Timeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected int _slotIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_slotIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_slotIndex = value;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int SlotIndex
            {
                get
                {
                    var ___ret = __Internal.GetSlotIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSlotIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~RGBA2Timeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.RGBA2Timeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RGBA2Timeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.RGBA2Timeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RGBA2Timeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.RGBA2Timeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class RGB2Timeline : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _slotIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0RGB2Timeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int slotIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0RGB2Timeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setFrame@RGB2Timeline@spine@@QEAAXHMMMMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, int frame, float time, float r, float g, float b, float r2, float g2, float b2);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSlotIndex@RGB2Timeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetSlotIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSlotIndex@RGB2Timeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSlotIndex(__IntPtr __instance, int inValue);
            }

            internal static new RGB2Timeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new RGB2Timeline(native.ToPointer(), skipVTables);
            }

            internal static new RGB2Timeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (RGB2Timeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new RGB2Timeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (RGB2Timeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static RGB2Timeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new RGB2Timeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.RGB2Timeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private RGB2Timeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected RGB2Timeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public RGB2Timeline(ulong frameCount, ulong bezierCount, int slotIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RGB2Timeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, slotIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RGB2Timeline");
            }

            public RGB2Timeline(global::spine_cpp.Spine.RGB2Timeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RGB2Timeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RGB2Timeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            /// <summary>Sets the time and value of the specified keyframe.</summary>
            public void SetFrame(int frame, float time, float r, float g, float b, float r2, float g2, float b2)
            {
                __Internal.SetFrame(__Instance, frame, time, r, g, b, r2, g2, b2);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_RGB2Timeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected int _slotIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_slotIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_slotIndex = value;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int SlotIndex
            {
                get
                {
                    var ___ret = __Internal.GetSlotIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSlotIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~RGB2Timeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.RGB2Timeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RGB2Timeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.RGB2Timeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RGB2Timeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.RGB2Timeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>The interface for all constraints.</summary>
        public unsafe partial class ConstraintData : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 56)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal ulong _order;
                internal byte _skinRequired;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0ConstraintData@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0ConstraintData@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getName@ConstraintData@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getOrder@ConstraintData@spine@@QEAA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetOrder(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setOrder@ConstraintData@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetOrder(__IntPtr __instance, ulong inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?isSkinRequired@ConstraintData@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsSkinRequired(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSkinRequired@ConstraintData@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSkinRequired(__IntPtr __instance, bool inValue);
            }

            internal static new ConstraintData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ConstraintData(native.ToPointer(), skipVTables);
            }

            internal static new ConstraintData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ConstraintData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ConstraintData __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ConstraintData)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ConstraintData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ConstraintData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.ConstraintData.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private ConstraintData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ConstraintData(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public ConstraintData(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ConstraintData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ConstraintData");
            }

            public ConstraintData(global::spine_cpp.Spine.ConstraintData _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ConstraintData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ConstraintData");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static implicit operator global::spine_cpp.Spine.ConstraintData(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.ConstraintData(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_ConstraintData_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public virtual global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    var ___GetRTTIDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 1);
                    var ___ret = ___GetRTTIDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.RTTI.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>The IK constraint's name, which is unique within the skeleton.</summary>
            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>The ordinal for the order a skeleton's constraints will be applied.</summary>
            public ulong Order
            {
                get
                {
                    var ___ret = __Internal.GetOrder(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOrder(__Instance, value);
                }
            }

            /// <summary>Whether the constraint is only active for a specific skin.</summary>
            public bool SkinRequired
            {
                get
                {
                    var ___ret = __Internal.IsSkinRequired(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSkinRequired(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~ConstraintData()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.ConstraintData.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ConstraintData.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class DeformTimeline : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 160)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _slotIndex;
                internal global::spine_cpp.Spine.Vector.__Internal _vertices;
                internal __IntPtr _attachment;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0DeformTimeline@spine@@QEAA@_K0HPEAVVertexAttachment@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int slotIndex, __IntPtr attachment);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0DeformTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setFrame@DeformTimeline@spine@@QEAAXHMAEAV?$Vector@M@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, int frameIndex, float time, __IntPtr vertices);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCurvePercent@DeformTimeline@spine@@QEAAMMH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetCurvePercent(__IntPtr __instance, float time, int frame);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getVertices@DeformTimeline@spine@@QEAAAEAV?$Vector@V?$Vector@M@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetVertices(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAttachment@DeformTimeline@spine@@QEAAPEAVVertexAttachment@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAttachment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAttachment@DeformTimeline@spine@@QEAAXPEAVVertexAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAttachment(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSlotIndex@DeformTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetSlotIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSlotIndex@DeformTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSlotIndex(__IntPtr __instance, int inValue);
            }

            internal static new DeformTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new DeformTimeline(native.ToPointer(), skipVTables);
            }

            internal static new DeformTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (DeformTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new DeformTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (DeformTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static DeformTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new DeformTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.DeformTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private DeformTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected DeformTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public DeformTimeline(ulong frameCount, ulong bezierCount, int slotIndex, global::spine_cpp.Spine.VertexAttachment attachment)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.DeformTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg3 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
                __Internal.ctor(__Instance, frameCount, bezierCount, slotIndex, __arg3);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.DeformTimeline");
            }

            public DeformTimeline(global::spine_cpp.Spine.DeformTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.DeformTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.DeformTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            /// <summary>Sets the time and value of the specified keyframe.</summary>
            public void SetFrame(int frameIndex, float time, global::spine_cpp.Spine.Vector<float> vertices)
            {
                if (ReferenceEquals(vertices, null))
                    throw new global::System.ArgumentNullException("vertices", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = vertices.__Instance;
                __Internal.SetFrame(__Instance, frameIndex, time, __arg2);
            }

            public override void SetBezier(ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                base.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            public float GetCurvePercent(float time, int frame)
            {
                var ___ret = __Internal.GetCurvePercent(__Instance, time, frame);
                return ___ret;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_DeformTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected int _slotIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_slotIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_slotIndex = value;
                }
            }

            protected global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Vector<float>> _vertices
            {
                get
                {
                    return global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Vector<float>>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_vertices));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->_vertices = *(global::spine_cpp.Spine.Vector.__Internal*) value.__Instance;
                }
            }

            protected global::spine_cpp.Spine.VertexAttachment _attachment
            {
                get
                {
                    var __result0 = global::spine_cpp.Spine.VertexAttachment.__GetOrCreateInstance(((__Internal*)__Instance)->_attachment, true);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->_attachment = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Vector<float>> Vertices
            {
                get
                {
                    var ___ret = __Internal.GetVertices(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Vector<float>>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.VertexAttachment Attachment
            {
                get
                {
                    var ___ret = __Internal.GetAttachment(__Instance);
                    var __result0 = global::spine_cpp.Spine.VertexAttachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetAttachment(__Instance, __arg0);
                }
            }

            public int SlotIndex
            {
                get
                {
                    var ___ret = __Internal.GetSlotIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSlotIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // DeformTimeline
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.DeformTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.DeformTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.DeformTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.DeformTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.DeformTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class DrawOrderTimeline : global::spine_cpp.Spine.Timeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 112)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _drawOrders;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0DrawOrderTimeline@spine@@QEAA@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0DrawOrderTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setFrame@DrawOrderTimeline@spine@@QEAAX_KMAEAV?$Vector@H@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, ulong frame, float time, __IntPtr drawOrder);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getDrawOrders@DrawOrderTimeline@spine@@QEAAAEAV?$Vector@V?$Vector@H@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDrawOrders(__IntPtr __instance);
            }

            internal static new DrawOrderTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new DrawOrderTimeline(native.ToPointer(), skipVTables);
            }

            internal static new DrawOrderTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (DrawOrderTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new DrawOrderTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (DrawOrderTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static DrawOrderTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new DrawOrderTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.DrawOrderTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private DrawOrderTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected DrawOrderTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public DrawOrderTimeline(ulong frameCount)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.DrawOrderTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.DrawOrderTimeline");
            }

            public DrawOrderTimeline(global::spine_cpp.Spine.DrawOrderTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.DrawOrderTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.DrawOrderTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            /// <summary>Sets the time and value of the specified keyframe.</summary>
            /// <param name="drawOrder">May be NULL to use bind pose draw order</param>
            public void SetFrame(ulong frame, float time, global::spine_cpp.Spine.Vector<int> drawOrder)
            {
                if (ReferenceEquals(drawOrder, null))
                    throw new global::System.ArgumentNullException("drawOrder", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = drawOrder.__Instance;
                __Internal.SetFrame(__Instance, frame, time, __arg2);
            }

            public static explicit operator global::spine_cpp.Spine.DrawOrderTimeline(ulong frameCount)
            {
                return new global::spine_cpp.Spine.DrawOrderTimeline(frameCount);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_DrawOrderTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Vector<int>> DrawOrders
            {
                get
                {
                    var ___ret = __Internal.GetDrawOrders(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Vector<int>>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // DrawOrderTimeline
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.DrawOrderTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.DrawOrderTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.DrawOrderTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.DrawOrderTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[4];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                VTables.Methods[0] = new Delegate[4];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>Stores the current pose values for an Event.</summary>
        public unsafe partial class Event : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 72)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _data;
                internal float _time;
                internal int _intValue;
                internal float _floatValue;
                internal global::spine_cpp.Spine.String.__Internal _stringValue;
                internal float _volume;
                internal float _balance;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Event@spine@@QEAA@MAEBVEventData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, float time, __IntPtr data);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Event@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getData@Event@spine@@QEAAAEBVEventData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTime@Event@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetTime(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getIntValue@Event@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetIntValue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setIntValue@Event@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIntValue(__IntPtr __instance, int inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getFloatValue@Event@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetFloatValue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setFloatValue@Event@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFloatValue(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getStringValue@Event@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetStringValue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setStringValue@Event@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetStringValue(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getVolume@Event@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetVolume(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setVolume@Event@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVolume(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBalance@Event@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetBalance(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setBalance@Event@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBalance(__IntPtr __instance, float inValue);
            }

            internal static new Event __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Event(native.ToPointer(), skipVTables);
            }

            internal static new Event __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Event)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Event __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Event)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Event __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Event(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Event.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Event(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Event(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Event(float time, global::spine_cpp.Spine.EventData data)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Event.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(data, null))
                    throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = data.__Instance;
                __Internal.ctor(__Instance, time, __arg1);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Event");
            }

            public Event(global::spine_cpp.Spine.Event _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Event.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Event");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::spine_cpp.Spine.EventData Data
            {
                get
                {
                    var ___ret = __Internal.GetData(__Instance);
                    var __result0 = global::spine_cpp.Spine.EventData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>The animation time this event was keyed.</summary>
            public float Time
            {
                get
                {
                    var ___ret = __Internal.GetTime(__Instance);
                    return ___ret;
                }
            }

            public int IntValue
            {
                get
                {
                    var ___ret = __Internal.GetIntValue(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetIntValue(__Instance, value);
                }
            }

            public float FloatValue
            {
                get
                {
                    var ___ret = __Internal.GetFloatValue(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetFloatValue(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.String StringValue
            {
                get
                {
                    var ___ret = __Internal.GetStringValue(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetStringValue(__Instance, __arg0);
                }
            }

            public float Volume
            {
                get
                {
                    var ___ret = __Internal.GetVolume(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetVolume(__Instance, value);
                }
            }

            public float Balance
            {
                get
                {
                    var ___ret = __Internal.GetBalance(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBalance(__Instance, value);
                }
            }

            #region Virtual table interop

            // Event
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Event.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>Stores the setup pose values for an Event.</summary>
        public unsafe partial class EventData : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal int _intValue;
                internal float _floatValue;
                internal global::spine_cpp.Spine.String.__Internal _stringValue;
                internal global::spine_cpp.Spine.String.__Internal _audioPath;
                internal float _volume;
                internal float _balance;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0EventData@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0EventData@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getName@EventData@spine@@QEBAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getIntValue@EventData@spine@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetIntValue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setIntValue@EventData@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIntValue(__IntPtr __instance, int inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getFloatValue@EventData@spine@@QEBAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetFloatValue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setFloatValue@EventData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFloatValue(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getStringValue@EventData@spine@@QEBAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetStringValue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setStringValue@EventData@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetStringValue(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAudioPath@EventData@spine@@QEBAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAudioPath(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAudioPath@EventData@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAudioPath(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getVolume@EventData@spine@@QEBAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetVolume(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setVolume@EventData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVolume(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBalance@EventData@spine@@QEBAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetBalance(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setBalance@EventData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBalance(__IntPtr __instance, float inValue);
            }

            internal static new EventData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new EventData(native.ToPointer(), skipVTables);
            }

            internal static new EventData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (EventData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new EventData __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (EventData)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static EventData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new EventData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.EventData.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private EventData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected EventData(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public EventData(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.EventData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.EventData");
            }

            public EventData(global::spine_cpp.Spine.EventData _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.EventData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.EventData");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.EventData(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.EventData(name);
            }

            /// <summary>The name of the event, which is unique within the skeleton.</summary>
            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public int IntValue
            {
                get
                {
                    var ___ret = __Internal.GetIntValue(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetIntValue(__Instance, value);
                }
            }

            public float FloatValue
            {
                get
                {
                    var ___ret = __Internal.GetFloatValue(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetFloatValue(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.String StringValue
            {
                get
                {
                    var ___ret = __Internal.GetStringValue(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetStringValue(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.String AudioPath
            {
                get
                {
                    var ___ret = __Internal.GetAudioPath(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetAudioPath(__Instance, __arg0);
                }
            }

            public float Volume
            {
                get
                {
                    var ___ret = __Internal.GetVolume(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetVolume(__Instance, value);
                }
            }

            public float Balance
            {
                get
                {
                    var ___ret = __Internal.GetBalance(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBalance(__Instance, value);
                }
            }

            #region Virtual table interop

            // EventData
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.EventData.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class EventTimeline : global::spine_cpp.Spine.Timeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 112)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _events;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0EventTimeline@spine@@QEAA@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0EventTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setFrame@EventTimeline@spine@@QEAAX_KPEAVEvent@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, ulong frame, __IntPtr @event);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getEvents@EventTimeline@spine@@QEAAAEAV?$Vector@PEAVEvent@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetEvents(__IntPtr __instance);
            }

            internal static new EventTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new EventTimeline(native.ToPointer(), skipVTables);
            }

            internal static new EventTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (EventTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new EventTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (EventTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static EventTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new EventTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.EventTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private EventTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected EventTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public EventTimeline(ulong frameCount)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.EventTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.EventTimeline");
            }

            public EventTimeline(global::spine_cpp.Spine.EventTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.EventTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.EventTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            /// <summary>Sets the time and value of the specified keyframe.</summary>
            public void SetFrame(ulong frame, global::spine_cpp.Spine.Event @event)
            {
                var __arg1 = @event is null ? __IntPtr.Zero : @event.__Instance;
                __Internal.SetFrame(__Instance, frame, __arg1);
            }

            public static explicit operator global::spine_cpp.Spine.EventTimeline(ulong frameCount)
            {
                return new global::spine_cpp.Spine.EventTimeline(frameCount);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_EventTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> Events
            {
                get
                {
                    var ___ret = __Internal.GetEvents(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // ~EventTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.EventTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.EventTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.EventTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.EventTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[4];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                VTables.Methods[0] = new Delegate[4];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class IkConstraint : global::spine_cpp.Spine.Updatable, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 80)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _data;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal int _bendDirection;
                internal byte _compress;
                internal byte _stretch;
                internal float _mix;
                internal float _softness;
                internal __IntPtr _target;
                internal byte _active;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0IkConstraint@spine@@QEAA@AEAVIkConstraintData@1@AEAVSkeleton@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr data, __IntPtr skeleton);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0IkConstraint@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?apply@IkConstraint@spine@@SAXAEAVBone@2@MM_N11M@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Apply(__IntPtr bone, float targetX, float targetY, bool compress, bool stretch, bool uniform, float alpha);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?apply@IkConstraint@spine@@SAXAEAVBone@2@0MMH_N1MM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Apply(__IntPtr parent, __IntPtr child, float targetX, float targetY, int bendDir, bool stretch, bool uniform, float softness, float alpha);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getData@IkConstraint@spine@@QEAAAEAVIkConstraintData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBones@IkConstraint@spine@@QEAAAEAV?$Vector@PEAVBone@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBones(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTarget@IkConstraint@spine@@QEAAPEAVBone@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTarget(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setTarget@IkConstraint@spine@@QEAAXPEAVBone@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTarget(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBendDirection@IkConstraint@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBendDirection(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setBendDirection@IkConstraint@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBendDirection(__IntPtr __instance, int inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCompress@IkConstraint@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetCompress(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setCompress@IkConstraint@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetCompress(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getStretch@IkConstraint@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetStretch(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setStretch@IkConstraint@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetStretch(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMix@IkConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMix(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMix@IkConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMix(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSoftness@IkConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetSoftness(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSoftness@IkConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSoftness(__IntPtr __instance, float inValue);
            }

            internal static new IkConstraint __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new IkConstraint(native.ToPointer(), skipVTables);
            }

            internal static new IkConstraint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (IkConstraint)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new IkConstraint __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (IkConstraint)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static IkConstraint __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new IkConstraint(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.IkConstraint.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private IkConstraint(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected IkConstraint(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public IkConstraint(global::spine_cpp.Spine.IkConstraintData data, global::spine_cpp.Spine.Skeleton skeleton)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.IkConstraint.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(data, null))
                    throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = data.__Instance;
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = skeleton.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.IkConstraint");
            }

            public IkConstraint(global::spine_cpp.Spine.IkConstraint _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.IkConstraint.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.IkConstraint");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Update()
            {
                var ___UpdateDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr>(0, 2);
                ___UpdateDelegate(__Instance);
            }

            /// <summary>
            /// <para>Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified</para>
            /// <para>in the world coordinate system.</para>
            /// </summary>
            public static void Apply(global::spine_cpp.Spine.Bone bone, float targetX, float targetY, bool compress, bool stretch, bool uniform, float alpha)
            {
                if (ReferenceEquals(bone, null))
                    throw new global::System.ArgumentNullException("bone", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = bone.__Instance;
                __Internal.Apply(__arg0, targetX, targetY, compress, stretch, uniform, alpha);
            }

            /// <summary>
            /// <para>Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as</para>
            /// <para>possible. The target is specified in the world coordinate system.</para>
            /// </summary>
            /// <param name="child">A direct descendant of the parent bone.</param>
            public static void Apply(global::spine_cpp.Spine.Bone parent, global::spine_cpp.Spine.Bone child, float targetX, float targetY, int bendDir, bool stretch, bool uniform, float softness, float alpha)
            {
                if (ReferenceEquals(parent, null))
                    throw new global::System.ArgumentNullException("parent", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = parent.__Instance;
                if (ReferenceEquals(child, null))
                    throw new global::System.ArgumentNullException("child", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = child.__Instance;
                __Internal.Apply(__arg0, __arg1, targetX, targetY, bendDir, stretch, uniform, softness, alpha);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_IkConstraint_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public virtual int Order
            {
                get
                {
                    var ___GetOrderDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_int___IntPtr>(0, 5);
                    var ___ret = ___GetOrderDelegate(__Instance);
                    return ___ret;
                }
            }

            public global::spine_cpp.Spine.IkConstraintData Data
            {
                get
                {
                    var ___ret = __Internal.GetData(__Instance);
                    var __result0 = global::spine_cpp.Spine.IkConstraintData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Bone> Bones
            {
                get
                {
                    var ___ret = __Internal.GetBones(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Bone>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Bone Target
            {
                get
                {
                    var ___ret = __Internal.GetTarget(__Instance);
                    var __result0 = global::spine_cpp.Spine.Bone.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetTarget(__Instance, __arg0);
                }
            }

            public int BendDirection
            {
                get
                {
                    var ___ret = __Internal.GetBendDirection(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBendDirection(__Instance, value);
                }
            }

            public bool Compress
            {
                get
                {
                    var ___ret = __Internal.GetCompress(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetCompress(__Instance, value);
                }
            }

            public bool Stretch
            {
                get
                {
                    var ___ret = __Internal.GetStretch(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetStretch(__Instance, value);
                }
            }

            public float Mix
            {
                get
                {
                    var ___ret = __Internal.GetMix(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMix(__Instance, value);
                }
            }

            public float Softness
            {
                get
                {
                    var ___ret = __Internal.GetSoftness(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSoftness(__Instance, value);
                }
            }

            public override bool Active
            {
                get
                {
                    var ___IsActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_bool___IntPtr>(0, 3);
                    var ___ret = ___IsActiveDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_bool>(0, 4);
                    ___SetActiveDelegate(__Instance, value);
                }
            }

            #region Virtual table interop

            // IkConstraint
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.IkConstraint.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.IkConstraint.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void update()
            private static global::spine_cpp.Delegates.Action___IntPtr _UpdateDelegateInstance;

            private static void _UpdateDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.IkConstraint.__GetInstance(__instance);
                __target.Update();
            }

            // bool isActive()
            private static global::spine_cpp.Delegates.Func_bool___IntPtr _IsActiveDelegateInstance;

            private static bool _IsActiveDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.IkConstraint.__GetInstance(__instance);
                var ___ret = __target.Active;
                return ___ret;
            }

            // void setActive(bool inValue)
            private static global::spine_cpp.Delegates.Action___IntPtr_bool _SetActiveDelegateInstance;

            private static void _SetActiveDelegateHook(__IntPtr __instance, bool inValue)
            {
                var __target = global::spine_cpp.Spine.IkConstraint.__GetInstance(__instance);
                __target.Active = inValue;
            }

            // int getOrder()
            private static global::spine_cpp.Delegates.Func_int___IntPtr _GetOrderDelegateInstance;

            private static int _GetOrderDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.IkConstraint.__GetInstance(__instance);
                var ___ret = __target.Order;
                return ___ret;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[6];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _UpdateDelegateInstance += _UpdateDelegateHook;
                    _IsActiveDelegateInstance += _IsActiveDelegateHook;
                    _SetActiveDelegateInstance += _SetActiveDelegateHook;
                    _GetOrderDelegateInstance += _GetOrderDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_IsActiveDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetActiveDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetOrderDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                VTables.Methods[0] = new Delegate[6];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class IkConstraintData : global::spine_cpp.Spine.ConstraintData, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 112)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal ulong _order;
                internal byte _skinRequired;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal __IntPtr _target;
                internal int _bendDirection;
                internal byte _compress;
                internal byte _stretch;
                internal byte _uniform;
                internal float _mix;
                internal float _softness;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0IkConstraintData@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0IkConstraintData@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBones@IkConstraintData@spine@@QEAAAEAV?$Vector@PEAVBoneData@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBones(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTarget@IkConstraintData@spine@@QEAAPEAVBoneData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTarget(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setTarget@IkConstraintData@spine@@QEAAXPEAVBoneData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTarget(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBendDirection@IkConstraintData@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBendDirection(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setBendDirection@IkConstraintData@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBendDirection(__IntPtr __instance, int inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCompress@IkConstraintData@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetCompress(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setCompress@IkConstraintData@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetCompress(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getStretch@IkConstraintData@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetStretch(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setStretch@IkConstraintData@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetStretch(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getUniform@IkConstraintData@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetUniform(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setUniform@IkConstraintData@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetUniform(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMix@IkConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMix(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMix@IkConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMix(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSoftness@IkConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetSoftness(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSoftness@IkConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSoftness(__IntPtr __instance, float inValue);
            }

            internal static new IkConstraintData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new IkConstraintData(native.ToPointer(), skipVTables);
            }

            internal static new IkConstraintData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (IkConstraintData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new IkConstraintData __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (IkConstraintData)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static IkConstraintData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new IkConstraintData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.IkConstraintData.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private IkConstraintData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected IkConstraintData(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public IkConstraintData(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.IkConstraintData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.IkConstraintData");
            }

            public IkConstraintData(global::spine_cpp.Spine.IkConstraintData _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.IkConstraintData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.IkConstraintData");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.IkConstraintData(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.IkConstraintData(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_IkConstraintData_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            /// <summary>The bones that are constrained by this IK Constraint.</summary>
            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.BoneData> Bones
            {
                get
                {
                    var ___ret = __Internal.GetBones(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.BoneData>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>The bone that is the IK target.</summary>
            public global::spine_cpp.Spine.BoneData Target
            {
                get
                {
                    var ___ret = __Internal.GetTarget(__Instance);
                    var __result0 = global::spine_cpp.Spine.BoneData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetTarget(__Instance, __arg0);
                }
            }

            /// <summary>Controls the bend direction of the IK bones, either 1 or -1.</summary>
            public int BendDirection
            {
                get
                {
                    var ___ret = __Internal.GetBendDirection(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBendDirection(__Instance, value);
                }
            }

            public bool Compress
            {
                get
                {
                    var ___ret = __Internal.GetCompress(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetCompress(__Instance, value);
                }
            }

            public bool Stretch
            {
                get
                {
                    var ___ret = __Internal.GetStretch(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetStretch(__Instance, value);
                }
            }

            public bool Uniform
            {
                get
                {
                    var ___ret = __Internal.GetUniform(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetUniform(__Instance, value);
                }
            }

            public float Mix
            {
                get
                {
                    var ___ret = __Internal.GetMix(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMix(__Instance, value);
                }
            }

            public float Softness
            {
                get
                {
                    var ___ret = __Internal.GetSoftness(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSoftness(__Instance, value);
                }
            }

            #region Virtual table interop

            // IkConstraintData
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.IkConstraintData.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.IkConstraintData.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class IkConstraintTimeline : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _ikConstraintIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0IkConstraintTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int ikConstraintIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0IkConstraintTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setFrame@IkConstraintTimeline@spine@@QEAAXHMMMH_N0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, int frame, float time, float mix, float softness, int bendDirection, bool compress, bool stretch);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getIkConstraintIndex@IkConstraintTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetIkConstraintIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setIkConstraintIndex@IkConstraintTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIkConstraintIndex(__IntPtr __instance, int inValue);
            }

            internal static new IkConstraintTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new IkConstraintTimeline(native.ToPointer(), skipVTables);
            }

            internal static new IkConstraintTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (IkConstraintTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new IkConstraintTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (IkConstraintTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static IkConstraintTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new IkConstraintTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.IkConstraintTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private IkConstraintTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected IkConstraintTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public IkConstraintTimeline(ulong frameCount, ulong bezierCount, int ikConstraintIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.IkConstraintTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, ikConstraintIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.IkConstraintTimeline");
            }

            public IkConstraintTimeline(global::spine_cpp.Spine.IkConstraintTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.IkConstraintTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.IkConstraintTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            /// <summary>Sets the time, mix and bend direction of the specified keyframe.</summary>
            public void SetFrame(int frame, float time, float mix, float softness, int bendDirection, bool compress, bool stretch)
            {
                __Internal.SetFrame(__Instance, frame, time, mix, softness, bendDirection, compress, stretch);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_IkConstraintTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int IkConstraintIndex
            {
                get
                {
                    var ___ret = __Internal.GetIkConstraintIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetIkConstraintIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // IkConstraintTimeline
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.IkConstraintTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.IkConstraintTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.IkConstraintTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.IkConstraintTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.IkConstraintTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class Json : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 56)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _next;
                internal __IntPtr _child;
                internal int _type;
                internal int _size;
                internal __IntPtr _valueString;
                internal int _valueInt;
                internal float _valueFloat;
                internal __IntPtr _name;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Json@spine@@QEAA@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string value);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Json@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getItem@Json@spine@@SAPEAV12@PEAV12@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetItem(__IntPtr @object, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string @string);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getItem@Json@spine@@SAPEAV12@PEAV12@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetItem_1(__IntPtr @object, int childIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getString@Json@spine@@SAPEBDPEAV12@PEBD1@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetString(__IntPtr @object, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getFloat@Json@spine@@SAMPEAV12@PEBDM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetFloat(__IntPtr @object, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, float defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getInt@Json@spine@@SAHPEAV12@PEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetInt(__IntPtr @object, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, int defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBoolean@Json@spine@@SA_NPEAV12@PEBD_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetBoolean(__IntPtr @object, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, bool defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getError@Json@spine@@SAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetError();
            }

            internal static new Json __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Json(native.ToPointer(), skipVTables);
            }

            internal static new Json __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Json)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Json __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Json)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Json __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Json(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Json.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Json(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Json(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Json(string value)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Json.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, value);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Json");
            }

            public Json(global::spine_cpp.Spine.Json _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Json.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Json");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.Json(string value)
            {
                return new global::spine_cpp.Spine.Json(value);
            }

            public static global::spine_cpp.Spine.Json GetItem(global::spine_cpp.Spine.Json @object, string @string)
            {
                var __arg0 = @object is null ? __IntPtr.Zero : @object.__Instance;
                var ___ret = __Internal.GetItem(__arg0, @string);
                var __result0 = global::spine_cpp.Spine.Json.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public static global::spine_cpp.Spine.Json GetItem(global::spine_cpp.Spine.Json @object, int childIndex)
            {
                var __arg0 = @object is null ? __IntPtr.Zero : @object.__Instance;
                var ___ret = __Internal.GetItem_1(__arg0, childIndex);
                var __result0 = global::spine_cpp.Spine.Json.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public static string GetString(global::spine_cpp.Spine.Json @object, string name, string defaultValue)
            {
                var __arg0 = @object is null ? __IntPtr.Zero : @object.__Instance;
                var ___ret = __Internal.GetString(__arg0, name, defaultValue);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public static float GetFloat(global::spine_cpp.Spine.Json @object, string name, float defaultValue)
            {
                var __arg0 = @object is null ? __IntPtr.Zero : @object.__Instance;
                var ___ret = __Internal.GetFloat(__arg0, name, defaultValue);
                return ___ret;
            }

            public static int GetInt(global::spine_cpp.Spine.Json @object, string name, int defaultValue)
            {
                var __arg0 = @object is null ? __IntPtr.Zero : @object.__Instance;
                var ___ret = __Internal.GetInt(__arg0, name, defaultValue);
                return ___ret;
            }

            public static bool GetBoolean(global::spine_cpp.Spine.Json @object, string name, bool defaultValue)
            {
                var __arg0 = @object is null ? __IntPtr.Zero : @object.__Instance;
                var ___ret = __Internal.GetBoolean(__arg0, name, defaultValue);
                return ___ret;
            }

            public static int JSON_FALSE
            {
                get
                {
                    var __ptr = (int*)global::spine_cpp.__Symbols.spine_cpp._JSON_FALSE_Json_spine__2HB;
                    return *__ptr;
                }
            }

            public static int JSON_TRUE
            {
                get
                {
                    var __ptr = (int*)global::spine_cpp.__Symbols.spine_cpp._JSON_TRUE_Json_spine__2HB;
                    return *__ptr;
                }
            }

            public static int JSON_NULL
            {
                get
                {
                    var __ptr = (int*)global::spine_cpp.__Symbols.spine_cpp._JSON_NULL_Json_spine__2HB;
                    return *__ptr;
                }
            }

            public static int JSON_NUMBER
            {
                get
                {
                    var __ptr = (int*)global::spine_cpp.__Symbols.spine_cpp._JSON_NUMBER_Json_spine__2HB;
                    return *__ptr;
                }
            }

            public static int JSON_STRING
            {
                get
                {
                    var __ptr = (int*)global::spine_cpp.__Symbols.spine_cpp._JSON_STRING_Json_spine__2HB;
                    return *__ptr;
                }
            }

            public static int JSON_ARRAY
            {
                get
                {
                    var __ptr = (int*)global::spine_cpp.__Symbols.spine_cpp._JSON_ARRAY_Json_spine__2HB;
                    return *__ptr;
                }
            }

            public static int JSON_OBJECT
            {
                get
                {
                    var __ptr = (int*)global::spine_cpp.__Symbols.spine_cpp._JSON_OBJECT_Json_spine__2HB;
                    return *__ptr;
                }
            }

            public static string error
            {
                get
                {
                    var ___ret = __Internal.GetError();
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            #region Virtual table interop

            // ~Json()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Json.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class LinkedMesh : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 96)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _mesh;
                internal global::spine_cpp.Spine.String.__Internal _skin;
                internal ulong _slotIndex;
                internal global::spine_cpp.Spine.String.__Internal _parent;
                internal byte _inheritTimeline;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0LinkedMesh@spine@@QEAA@PEAVMeshAttachment@1@AEBVString@1@_K1_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr mesh, __IntPtr skin, ulong slotIndex, __IntPtr parent, bool inheritTimeline);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0LinkedMesh@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new LinkedMesh __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new LinkedMesh(native.ToPointer(), skipVTables);
            }

            internal static new LinkedMesh __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (LinkedMesh)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new LinkedMesh __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (LinkedMesh)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static LinkedMesh __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new LinkedMesh(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.LinkedMesh.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private LinkedMesh(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected LinkedMesh(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public LinkedMesh(global::spine_cpp.Spine.MeshAttachment mesh, global::spine_cpp.Spine.String skin, ulong slotIndex, global::spine_cpp.Spine.String parent, bool inheritTimeline)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.LinkedMesh.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = mesh is null ? __IntPtr.Zero : mesh.__Instance;
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = skin.__Instance;
                if (ReferenceEquals(parent, null))
                    throw new global::System.ArgumentNullException("parent", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = parent.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1, slotIndex, __arg3, inheritTimeline);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.LinkedMesh");
            }

            public LinkedMesh(global::spine_cpp.Spine.LinkedMesh _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.LinkedMesh.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.LinkedMesh");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // LinkedMesh
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.LinkedMesh.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public enum SequenceMode
        {
            Hold = 0,
            Once = 1,
            Loop = 2,
            Pingpong = 3,
            OnceReverse = 4,
            LoopReverse = 5,
            PingpongReverse = 6
        }

        public unsafe partial class Sequence : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 64)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal int _id;
                internal global::spine_cpp.Spine.Vector.__Internal _regions;
                internal int _start;
                internal int _digits;
                internal int _setupIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Sequence@spine@@QEAA@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, int count);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Sequence@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?apply@Sequence@spine@@QEAAXPEAVSlot@2@PEAVAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Apply(__IntPtr __instance, __IntPtr slot, __IntPtr attachment);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getPath@Sequence@spine@@QEAA?AVString@2@AEBV32@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetPath(__IntPtr __instance, __IntPtr @return, __IntPtr basePath, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?copy@Sequence@spine@@QEAAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Copy(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getId@Sequence@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetId(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setId@Sequence@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetId(__IntPtr __instance, int id);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getStart@Sequence@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetStart(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setStart@Sequence@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetStart(__IntPtr __instance, int start);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getDigits@Sequence@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetDigits(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setDigits@Sequence@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDigits(__IntPtr __instance, int digits);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSetupIndex@Sequence@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetSetupIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSetupIndex@Sequence@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSetupIndex(__IntPtr __instance, int setupIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getRegions@Sequence@spine@@QEAAAEAV?$Vector@PEAVTextureRegion@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRegions(__IntPtr __instance);
            }

            internal static new Sequence __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Sequence(native.ToPointer(), skipVTables);
            }

            internal static new Sequence __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Sequence)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Sequence __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Sequence)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Sequence __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Sequence(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Sequence.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Sequence(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Sequence(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Sequence(int count)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Sequence.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, count);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Sequence");
            }

            public Sequence(global::spine_cpp.Spine.Sequence _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Sequence.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Sequence");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Apply(global::spine_cpp.Spine.Slot slot, global::spine_cpp.Spine.Attachment attachment)
            {
                var __arg0 = slot is null ? __IntPtr.Zero : slot.__Instance;
                var __arg1 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
                __Internal.Apply(__Instance, __arg0, __arg1);
            }

            public global::spine_cpp.Spine.String GetPath(global::spine_cpp.Spine.String basePath, int index)
            {
                if (ReferenceEquals(basePath, null))
                    throw new global::System.ArgumentNullException("basePath", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = basePath.__Instance;
                var ___ret = new global::spine_cpp.Spine.String.__Internal();
                __Internal.GetPath(__Instance, new IntPtr(&___ret), __arg0, index);
                var _____ret = global::spine_cpp.Spine.String.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::spine_cpp.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            public static implicit operator global::spine_cpp.Spine.Sequence(int count)
            {
                return new global::spine_cpp.Spine.Sequence(count);
            }

            public global::spine_cpp.Spine.Sequence Copy
            {
                get
                {
                    var ___ret = __Internal.Copy(__Instance);
                    var __result0 = global::spine_cpp.Spine.Sequence.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public int Id
            {
                get
                {
                    var ___ret = __Internal.GetId(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetId(__Instance, value);
                }
            }

            public int Start
            {
                get
                {
                    var ___ret = __Internal.GetStart(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetStart(__Instance, value);
                }
            }

            public int Digits
            {
                get
                {
                    var ___ret = __Internal.GetDigits(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetDigits(__Instance, value);
                }
            }

            public int SetupIndex
            {
                get
                {
                    var ___ret = __Internal.GetSetupIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSetupIndex(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.TextureRegion> Regions
            {
                get
                {
                    var ___ret = __Internal.GetRegions(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.TextureRegion>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // ~Sequence()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Sequence.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>Attachment that displays a texture region using a mesh.</summary>
        public unsafe partial class MeshAttachment : global::spine_cpp.Spine.VertexAttachment, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 360)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal int _refCount;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal global::spine_cpp.Spine.Vector.__Internal _vertices;
                internal ulong _worldVerticesLength;
                internal __IntPtr _timelineAttachment;
                internal int _id;
                internal __IntPtr _parentMesh;
                internal global::spine_cpp.Spine.Vector.__Internal _uvs;
                internal global::spine_cpp.Spine.Vector.__Internal _regionUVs;
                internal global::spine_cpp.Spine.Vector.__Internal _triangles;
                internal global::spine_cpp.Spine.Vector.__Internal _edges;
                internal global::spine_cpp.Spine.String.__Internal _path;
                internal global::spine_cpp.Spine.Color.__Internal _color;
                internal int _hullLength;
                internal int _width;
                internal int _height;
                internal __IntPtr _region;
                internal __IntPtr _sequence;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0MeshAttachment@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0MeshAttachment@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?updateRegion@MeshAttachment@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?newLinkedMesh@MeshAttachment@spine@@QEAAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr NewLinkedMesh(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getHullLength@MeshAttachment@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetHullLength(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setHullLength@MeshAttachment@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHullLength(__IntPtr __instance, int inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getRegionUVs@MeshAttachment@spine@@QEAAAEAV?$Vector@M@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRegionUVs(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getUVs@MeshAttachment@spine@@QEAAAEAV?$Vector@M@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetUVs(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTriangles@MeshAttachment@spine@@QEAAAEAV?$Vector@G@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTriangles(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getColor@MeshAttachment@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getPath@MeshAttachment@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetPath(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setPath@MeshAttachment@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPath(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getRegion@MeshAttachment@spine@@QEAAPEAVTextureRegion@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setRegion@MeshAttachment@spine@@QEAAXPEAVTextureRegion@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRegion(__IntPtr __instance, __IntPtr region);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSequence@MeshAttachment@spine@@QEAAPEAVSequence@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSequence(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSequence@MeshAttachment@spine@@QEAAXPEAVSequence@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSequence(__IntPtr __instance, __IntPtr sequence);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getParentMesh@MeshAttachment@spine@@QEAAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetParentMesh(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setParentMesh@MeshAttachment@spine@@QEAAXPEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetParentMesh(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getEdges@MeshAttachment@spine@@QEAAAEAV?$Vector@G@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetEdges(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getWidth@MeshAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWidth(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setWidth@MeshAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWidth(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getHeight@MeshAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetHeight(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setHeight@MeshAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHeight(__IntPtr __instance, float inValue);
            }

            internal static new MeshAttachment __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new MeshAttachment(native.ToPointer(), skipVTables);
            }

            internal static new MeshAttachment __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (MeshAttachment)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new MeshAttachment __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (MeshAttachment)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static MeshAttachment __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new MeshAttachment(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.MeshAttachment.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private MeshAttachment(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected MeshAttachment(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public MeshAttachment(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.MeshAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.MeshAttachment");
            }

            public MeshAttachment(global::spine_cpp.Spine.MeshAttachment _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.MeshAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.MeshAttachment");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void ComputeWorldVertices(global::spine_cpp.Spine.Slot slot, ulong start, ulong count, ref float worldVertices, ulong offset, ulong stride)
            {
                base.ComputeWorldVertices(slot, start, count, ref worldVertices, offset, stride);
            }

            public void UpdateRegion()
            {
                __Internal.UpdateRegion(__Instance);
            }

            public global::spine_cpp.Spine.MeshAttachment NewLinkedMesh()
            {
                var ___ret = __Internal.NewLinkedMesh(__Instance);
                var __result0 = global::spine_cpp.Spine.MeshAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public static explicit operator global::spine_cpp.Spine.MeshAttachment(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.MeshAttachment(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_MeshAttachment_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int HullLength
            {
                get
                {
                    var ___ret = __Internal.GetHullLength(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHullLength(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.Vector<float> RegionUVs
            {
                get
                {
                    var ___ret = __Internal.GetRegionUVs(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<float>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>The UV pair for each vertex, normalized within the entire texture. See also MeshAttachment::updateRegion</summary>
            public global::spine_cpp.Spine.Vector<float> UVs
            {
                get
                {
                    var ___ret = __Internal.GetUVs(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<float>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<ushort> Triangles
            {
                get
                {
                    var ___ret = __Internal.GetTriangles(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<ushort>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.String Path
            {
                get
                {
                    var ___ret = __Internal.GetPath(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetPath(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.TextureRegion Region
            {
                get
                {
                    var ___ret = __Internal.GetRegion(__Instance);
                    var __result0 = global::spine_cpp.Spine.TextureRegion.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetRegion(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.Sequence Sequence
            {
                get
                {
                    var ___ret = __Internal.GetSequence(__Instance);
                    var __result0 = global::spine_cpp.Spine.Sequence.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetSequence(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.MeshAttachment ParentMesh
            {
                get
                {
                    var ___ret = __Internal.GetParentMesh(__Instance);
                    var __result0 = global::spine_cpp.Spine.MeshAttachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetParentMesh(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.Vector<ushort> Edges
            {
                get
                {
                    var ___ret = __Internal.GetEdges(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<ushort>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public float Width
            {
                get
                {
                    var ___ret = __Internal.GetWidth(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetWidth(__Instance, value);
                }
            }

            public float Height
            {
                get
                {
                    var ___ret = __Internal.GetHeight(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHeight(__Instance, value);
                }
            }

            public override global::spine_cpp.Spine.Attachment Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___CopyDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // virtual ~MeshAttachment()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.MeshAttachment.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.MeshAttachment.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // Attachment *copy()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.MeshAttachment.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // void computeWorldVertices(Slot &slot, size_t start, size_t count, Vector<float> &worldVertices, size_t offset, size_t stride = 2)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_ulong_ulong___IntPtr_ulong_ulong _ComputeWorldVertices_3DelegateInstance;

            private static void _ComputeWorldVertices_3DelegateHook(__IntPtr __instance, __IntPtr slot, ulong start, ulong count, __IntPtr worldVertices, ulong offset, ulong stride)
            {
                var __target = global::spine_cpp.Spine.MeshAttachment.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(slot, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<float>.__GetOrCreateInstance(worldVertices, false, skipVTables: true);
                __target.ComputeWorldVertices(__result0, start, count, __result3, offset, stride);
            }

            // void computeWorldVertices(Slot &slot, size_t start, size_t count, float *worldVertices, size_t offset, size_t stride = 2)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_ulong_ulong_floatPtr_ulong_ulong _ComputeWorldVerticesDelegateInstance;

            private static void _ComputeWorldVerticesDelegateHook(__IntPtr __instance, __IntPtr slot, ulong start, ulong count, float* worldVertices, ulong offset, ulong stride)
            {
                var __target = global::spine_cpp.Spine.MeshAttachment.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(slot, false, skipVTables: true);
                __target.ComputeWorldVertices(__result0, start, count, ref *worldVertices, offset, stride);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    _ComputeWorldVertices_3DelegateInstance += _ComputeWorldVertices_3DelegateHook;
                    _ComputeWorldVerticesDelegateInstance += _ComputeWorldVerticesDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ComputeWorldVertices_3DelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_ComputeWorldVerticesDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class PathAttachment : global::spine_cpp.Spine.VertexAttachment, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 200)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal int _refCount;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal global::spine_cpp.Spine.Vector.__Internal _vertices;
                internal ulong _worldVerticesLength;
                internal __IntPtr _timelineAttachment;
                internal int _id;
                internal global::spine_cpp.Spine.Vector.__Internal _lengths;
                internal byte _closed;
                internal byte _constantSpeed;
                internal global::spine_cpp.Spine.Color.__Internal _color;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0PathAttachment@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0PathAttachment@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getLengths@PathAttachment@spine@@QEAAAEAV?$Vector@M@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetLengths(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?isClosed@PathAttachment@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsClosed(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setClosed@PathAttachment@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetClosed(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?isConstantSpeed@PathAttachment@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsConstantSpeed(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setConstantSpeed@PathAttachment@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetConstantSpeed(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getColor@PathAttachment@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);
            }

            internal static new PathAttachment __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PathAttachment(native.ToPointer(), skipVTables);
            }

            internal static new PathAttachment __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PathAttachment)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new PathAttachment __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (PathAttachment)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static PathAttachment __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PathAttachment(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.PathAttachment.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private PathAttachment(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PathAttachment(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public PathAttachment(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathAttachment");
            }

            public PathAttachment(global::spine_cpp.Spine.PathAttachment _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathAttachment");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.PathAttachment(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.PathAttachment(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_PathAttachment_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            /// <summary>The length in the setup pose from the start of the path to the end of each curve.</summary>
            public global::spine_cpp.Spine.Vector<float> Lengths
            {
                get
                {
                    var ___ret = __Internal.GetLengths(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<float>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public bool Closed
            {
                get
                {
                    var ___ret = __Internal.IsClosed(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetClosed(__Instance, value);
                }
            }

            public bool ConstantSpeed
            {
                get
                {
                    var ___ret = __Internal.IsConstantSpeed(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetConstantSpeed(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public override global::spine_cpp.Spine.Attachment Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___CopyDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // PathAttachment
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.PathAttachment.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathAttachment.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // Attachment *copy()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathAttachment.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // void computeWorldVertices(Slot &slot, size_t start, size_t count, Vector<float> &worldVertices, size_t offset, size_t stride = 2)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_ulong_ulong___IntPtr_ulong_ulong _ComputeWorldVertices_3DelegateInstance;

            private static void _ComputeWorldVertices_3DelegateHook(__IntPtr __instance, __IntPtr slot, ulong start, ulong count, __IntPtr worldVertices, ulong offset, ulong stride)
            {
                var __target = global::spine_cpp.Spine.PathAttachment.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(slot, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<float>.__GetOrCreateInstance(worldVertices, false, skipVTables: true);
                __target.ComputeWorldVertices(__result0, start, count, __result3, offset, stride);
            }

            // void computeWorldVertices(Slot &slot, size_t start, size_t count, float *worldVertices, size_t offset, size_t stride = 2)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_ulong_ulong_floatPtr_ulong_ulong _ComputeWorldVertices_2DelegateInstance;

            private static void _ComputeWorldVertices_2DelegateHook(__IntPtr __instance, __IntPtr slot, ulong start, ulong count, float* worldVertices, ulong offset, ulong stride)
            {
                var __target = global::spine_cpp.Spine.PathAttachment.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(slot, false, skipVTables: true);
                __target.ComputeWorldVertices(__result0, start, count, ref *worldVertices, offset, stride);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    _ComputeWorldVertices_3DelegateInstance += _ComputeWorldVertices_3DelegateHook;
                    _ComputeWorldVertices_2DelegateInstance += _ComputeWorldVertices_2DelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ComputeWorldVertices_3DelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_ComputeWorldVertices_2DelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class PathConstraint : global::spine_cpp.Spine.Updatable, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 280)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _data;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal __IntPtr _target;
                internal float _position;
                internal float _spacing;
                internal float _mixRotate;
                internal float _mixX;
                internal float _mixY;
                internal global::spine_cpp.Spine.Vector.__Internal _spaces;
                internal global::spine_cpp.Spine.Vector.__Internal _positions;
                internal global::spine_cpp.Spine.Vector.__Internal _world;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal global::spine_cpp.Spine.Vector.__Internal _lengths;
                internal global::spine_cpp.Spine.Vector.__Internal _segments;
                internal byte _active;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0PathConstraint@spine@@QEAA@AEAVPathConstraintData@1@AEAVSkeleton@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr data, __IntPtr skeleton);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0PathConstraint@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getData@PathConstraint@spine@@QEAAAEAVPathConstraintData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBones@PathConstraint@spine@@QEAAAEAV?$Vector@PEAVBone@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBones(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTarget@PathConstraint@spine@@QEAAPEAVSlot@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTarget(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setTarget@PathConstraint@spine@@QEAAXPEAVSlot@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTarget(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getPosition@PathConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetPosition(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setPosition@PathConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPosition(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSpacing@PathConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetSpacing(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSpacing@PathConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSpacing(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixRotate@PathConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixRotate(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixRotate@PathConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixRotate(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixX@PathConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixX@PathConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixY@PathConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixY@PathConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixY(__IntPtr __instance, float inValue);
            }

            internal static new PathConstraint __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PathConstraint(native.ToPointer(), skipVTables);
            }

            internal static new PathConstraint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PathConstraint)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new PathConstraint __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (PathConstraint)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static PathConstraint __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PathConstraint(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.PathConstraint.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private PathConstraint(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PathConstraint(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public PathConstraint(global::spine_cpp.Spine.PathConstraintData data, global::spine_cpp.Spine.Skeleton skeleton)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraint.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(data, null))
                    throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = data.__Instance;
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = skeleton.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraint");
            }

            public PathConstraint(global::spine_cpp.Spine.PathConstraint _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraint.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraint");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Update()
            {
                var ___UpdateDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr>(0, 2);
                ___UpdateDelegate(__Instance);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_PathConstraint_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public virtual int Order
            {
                get
                {
                    var ___GetOrderDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_int___IntPtr>(0, 5);
                    var ___ret = ___GetOrderDelegate(__Instance);
                    return ___ret;
                }
            }

            public global::spine_cpp.Spine.PathConstraintData Data
            {
                get
                {
                    var ___ret = __Internal.GetData(__Instance);
                    var __result0 = global::spine_cpp.Spine.PathConstraintData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Bone> Bones
            {
                get
                {
                    var ___ret = __Internal.GetBones(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Bone>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Slot Target
            {
                get
                {
                    var ___ret = __Internal.GetTarget(__Instance);
                    var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetTarget(__Instance, __arg0);
                }
            }

            public float Position
            {
                get
                {
                    var ___ret = __Internal.GetPosition(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetPosition(__Instance, value);
                }
            }

            public float Spacing
            {
                get
                {
                    var ___ret = __Internal.GetSpacing(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSpacing(__Instance, value);
                }
            }

            public float MixRotate
            {
                get
                {
                    var ___ret = __Internal.GetMixRotate(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixRotate(__Instance, value);
                }
            }

            public float MixX
            {
                get
                {
                    var ___ret = __Internal.GetMixX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixX(__Instance, value);
                }
            }

            public float MixY
            {
                get
                {
                    var ___ret = __Internal.GetMixY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixY(__Instance, value);
                }
            }

            public override bool Active
            {
                get
                {
                    var ___IsActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_bool___IntPtr>(0, 3);
                    var ___ret = ___IsActiveDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_bool>(0, 4);
                    ___SetActiveDelegate(__Instance, value);
                }
            }

            #region Virtual table interop

            // PathConstraint
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.PathConstraint.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraint.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void update()
            private static global::spine_cpp.Delegates.Action___IntPtr _UpdateDelegateInstance;

            private static void _UpdateDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraint.__GetInstance(__instance);
                __target.Update();
            }

            // bool isActive()
            private static global::spine_cpp.Delegates.Func_bool___IntPtr _IsActiveDelegateInstance;

            private static bool _IsActiveDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraint.__GetInstance(__instance);
                var ___ret = __target.Active;
                return ___ret;
            }

            // void setActive(bool inValue)
            private static global::spine_cpp.Delegates.Action___IntPtr_bool _SetActiveDelegateInstance;

            private static void _SetActiveDelegateHook(__IntPtr __instance, bool inValue)
            {
                var __target = global::spine_cpp.Spine.PathConstraint.__GetInstance(__instance);
                __target.Active = inValue;
            }

            // int getOrder()
            private static global::spine_cpp.Delegates.Func_int___IntPtr _GetOrderDelegateInstance;

            private static int _GetOrderDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraint.__GetInstance(__instance);
                var ___ret = __target.Order;
                return ___ret;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[6];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _UpdateDelegateInstance += _UpdateDelegateHook;
                    _IsActiveDelegateInstance += _IsActiveDelegateHook;
                    _SetActiveDelegateInstance += _SetActiveDelegateHook;
                    _GetOrderDelegateInstance += _GetOrderDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_IsActiveDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetActiveDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetOrderDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                VTables.Methods[0] = new Delegate[6];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class PathConstraintData : global::spine_cpp.Spine.ConstraintData, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 136)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal ulong _order;
                internal byte _skinRequired;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal __IntPtr _target;
                internal global::spine_cpp.Spine.PositionMode _positionMode;
                internal global::spine_cpp.Spine.SpacingMode _spacingMode;
                internal global::spine_cpp.Spine.RotateMode _rotateMode;
                internal float _offsetRotation;
                internal float _position;
                internal float _spacing;
                internal float _mixRotate;
                internal float _mixX;
                internal float _mixY;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0PathConstraintData@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0PathConstraintData@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBones@PathConstraintData@spine@@QEAAAEAV?$Vector@PEAVBoneData@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBones(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTarget@PathConstraintData@spine@@QEAAPEAVSlotData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTarget(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setTarget@PathConstraintData@spine@@QEAAXPEAVSlotData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTarget(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getPositionMode@PathConstraintData@spine@@QEAA?AW4PositionMode@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::spine_cpp.Spine.PositionMode GetPositionMode(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setPositionMode@PathConstraintData@spine@@QEAAXW4PositionMode@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPositionMode(__IntPtr __instance, global::spine_cpp.Spine.PositionMode inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSpacingMode@PathConstraintData@spine@@QEAA?AW4SpacingMode@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::spine_cpp.Spine.SpacingMode GetSpacingMode(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSpacingMode@PathConstraintData@spine@@QEAAXW4SpacingMode@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSpacingMode(__IntPtr __instance, global::spine_cpp.Spine.SpacingMode inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getRotateMode@PathConstraintData@spine@@QEAA?AW4RotateMode@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::spine_cpp.Spine.RotateMode GetRotateMode(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setRotateMode@PathConstraintData@spine@@QEAAXW4RotateMode@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRotateMode(__IntPtr __instance, global::spine_cpp.Spine.RotateMode inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getOffsetRotation@PathConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetOffsetRotation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setOffsetRotation@PathConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetOffsetRotation(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getPosition@PathConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetPosition(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setPosition@PathConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPosition(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSpacing@PathConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetSpacing(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSpacing@PathConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSpacing(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixRotate@PathConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixRotate(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixRotate@PathConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixRotate(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixX@PathConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixX@PathConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixY@PathConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixY@PathConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixY(__IntPtr __instance, float inValue);
            }

            internal static new PathConstraintData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PathConstraintData(native.ToPointer(), skipVTables);
            }

            internal static new PathConstraintData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PathConstraintData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new PathConstraintData __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (PathConstraintData)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static PathConstraintData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PathConstraintData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.PathConstraintData.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private PathConstraintData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PathConstraintData(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public PathConstraintData(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraintData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraintData");
            }

            public PathConstraintData(global::spine_cpp.Spine.PathConstraintData _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraintData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraintData");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.PathConstraintData(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.PathConstraintData(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_PathConstraintData_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.BoneData> Bones
            {
                get
                {
                    var ___ret = __Internal.GetBones(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.BoneData>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.SlotData Target
            {
                get
                {
                    var ___ret = __Internal.GetTarget(__Instance);
                    var __result0 = global::spine_cpp.Spine.SlotData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetTarget(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.PositionMode PositionMode
            {
                get
                {
                    var ___ret = __Internal.GetPositionMode(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetPositionMode(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.SpacingMode SpacingMode
            {
                get
                {
                    var ___ret = __Internal.GetSpacingMode(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSpacingMode(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.RotateMode RotateMode
            {
                get
                {
                    var ___ret = __Internal.GetRotateMode(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetRotateMode(__Instance, value);
                }
            }

            public float OffsetRotation
            {
                get
                {
                    var ___ret = __Internal.GetOffsetRotation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOffsetRotation(__Instance, value);
                }
            }

            public float Position
            {
                get
                {
                    var ___ret = __Internal.GetPosition(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetPosition(__Instance, value);
                }
            }

            public float Spacing
            {
                get
                {
                    var ___ret = __Internal.GetSpacing(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSpacing(__Instance, value);
                }
            }

            public float MixRotate
            {
                get
                {
                    var ___ret = __Internal.GetMixRotate(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixRotate(__Instance, value);
                }
            }

            public float MixX
            {
                get
                {
                    var ___ret = __Internal.GetMixX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixX(__Instance, value);
                }
            }

            public float MixY
            {
                get
                {
                    var ___ret = __Internal.GetMixY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixY(__Instance, value);
                }
            }

            #region Virtual table interop

            // PathConstraintData
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.PathConstraintData.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraintData.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class PathConstraintMixTimeline : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _pathConstraintIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0PathConstraintMixTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int pathConstraintIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0PathConstraintMixTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setFrame@PathConstraintMixTimeline@spine@@QEAAXHMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, int frameIndex, float time, float mixRotate, float mixX, float mixY);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getPathConstraintIndex@PathConstraintMixTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetPathConstraintIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setPathConstraintIndex@PathConstraintMixTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPathConstraintIndex(__IntPtr __instance, int inValue);
            }

            internal static new PathConstraintMixTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PathConstraintMixTimeline(native.ToPointer(), skipVTables);
            }

            internal static new PathConstraintMixTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PathConstraintMixTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new PathConstraintMixTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (PathConstraintMixTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static PathConstraintMixTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PathConstraintMixTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.PathConstraintMixTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private PathConstraintMixTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PathConstraintMixTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public PathConstraintMixTimeline(ulong frameCount, ulong bezierCount, int pathConstraintIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraintMixTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, pathConstraintIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraintMixTimeline");
            }

            public PathConstraintMixTimeline(global::spine_cpp.Spine.PathConstraintMixTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraintMixTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraintMixTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            /// <summary>Sets the time and mixes of the specified keyframe.</summary>
            public void SetFrame(int frameIndex, float time, float mixRotate, float mixX, float mixY)
            {
                __Internal.SetFrame(__Instance, frameIndex, time, mixRotate, mixX, mixY);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_PathConstraintMixTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int PathConstraintIndex
            {
                get
                {
                    var ___ret = __Internal.GetPathConstraintIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetPathConstraintIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // PathConstraintMixTimeline
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.PathConstraintMixTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraintMixTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.PathConstraintMixTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraintMixTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.PathConstraintMixTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class PathConstraintPositionTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _pathConstraintIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0PathConstraintPositionTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int pathConstraintIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0PathConstraintPositionTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getPathConstraintIndex@PathConstraintPositionTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetPathConstraintIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setPathConstraintIndex@PathConstraintPositionTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPathConstraintIndex(__IntPtr __instance, int inValue);
            }

            internal static new PathConstraintPositionTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PathConstraintPositionTimeline(native.ToPointer(), skipVTables);
            }

            internal static new PathConstraintPositionTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PathConstraintPositionTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new PathConstraintPositionTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (PathConstraintPositionTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static PathConstraintPositionTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PathConstraintPositionTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.PathConstraintPositionTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private PathConstraintPositionTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PathConstraintPositionTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public PathConstraintPositionTimeline(ulong frameCount, ulong bezierCount, int pathConstraintIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraintPositionTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, pathConstraintIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraintPositionTimeline");
            }

            public PathConstraintPositionTimeline(global::spine_cpp.Spine.PathConstraintPositionTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraintPositionTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraintPositionTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_PathConstraintPositionTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public static int ENTRIES
            {
                get
                {
                    var __ptr = (int*)global::spine_cpp.__Symbols.spine_cpp._ENTRIES_PathConstraintPositionTimeline_spine__2HB;
                    return *__ptr;
                }
            }

            protected int _pathConstraintIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_pathConstraintIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_pathConstraintIndex = value;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int PathConstraintIndex
            {
                get
                {
                    var ___ret = __Internal.GetPathConstraintIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetPathConstraintIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~PathConstraintPositionTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.PathConstraintPositionTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraintPositionTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.PathConstraintPositionTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraintPositionTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.PathConstraintPositionTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class PathConstraintSpacingTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _pathConstraintIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0PathConstraintSpacingTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int pathConstraintIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0PathConstraintSpacingTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getPathConstraintIndex@PathConstraintSpacingTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetPathConstraintIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setPathConstraintIndex@PathConstraintSpacingTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPathConstraintIndex(__IntPtr __instance, int inValue);
            }

            internal static new PathConstraintSpacingTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PathConstraintSpacingTimeline(native.ToPointer(), skipVTables);
            }

            internal static new PathConstraintSpacingTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PathConstraintSpacingTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new PathConstraintSpacingTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (PathConstraintSpacingTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static PathConstraintSpacingTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PathConstraintSpacingTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.PathConstraintSpacingTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private PathConstraintSpacingTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PathConstraintSpacingTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public PathConstraintSpacingTimeline(ulong frameCount, ulong bezierCount, int pathConstraintIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraintSpacingTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, pathConstraintIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraintSpacingTimeline");
            }

            public PathConstraintSpacingTimeline(global::spine_cpp.Spine.PathConstraintSpacingTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraintSpacingTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraintSpacingTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_PathConstraintSpacingTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected int _pathConstraintIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_pathConstraintIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_pathConstraintIndex = value;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int PathConstraintIndex
            {
                get
                {
                    var ___ret = __Internal.GetPathConstraintIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetPathConstraintIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // PathConstraintSpacingTimeline
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.PathConstraintSpacingTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraintSpacingTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.PathConstraintSpacingTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraintSpacingTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.PathConstraintSpacingTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>
        /// <para>An attachment which is a single point and a rotation. This can be used to spawn projectiles, particles, etc. A bone can be</para>
        /// <para>used in similar ways, but a PointAttachment is slightly less expensive to compute and can be hidden, shown, and placed in a</para>
        /// <para>skin.</para>
        /// </summary>
        /// <remarks>See http://esotericsoftware.com/spine-point-attachments for Point Attachments in the Spine User Guide.</remarks>
        public unsafe partial class PointAttachment : global::spine_cpp.Spine.Attachment, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 88)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal int _refCount;
                internal fixed byte _xPadding[4];
                internal float _x;
                internal float _y;
                internal float _rotation;
                internal global::spine_cpp.Spine.Color.__Internal _color;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0PointAttachment@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0PointAttachment@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?computeWorldPosition@PointAttachment@spine@@QEAAXAEAVBone@2@AEAM1@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ComputeWorldPosition(__IntPtr __instance, __IntPtr bone, float* ox, float* oy);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?computeWorldRotation@PointAttachment@spine@@QEAAMAEAVBone@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float ComputeWorldRotation(__IntPtr __instance, __IntPtr bone);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getX@PointAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setX@PointAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getY@PointAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setY@PointAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getRotation@PointAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetRotation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setRotation@PointAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRotation(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getColor@PointAttachment@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);
            }

            internal static new PointAttachment __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PointAttachment(native.ToPointer(), skipVTables);
            }

            internal static new PointAttachment __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PointAttachment)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new PointAttachment __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (PointAttachment)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static PointAttachment __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PointAttachment(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.PointAttachment.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private PointAttachment(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PointAttachment(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public PointAttachment(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PointAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PointAttachment");
            }

            public PointAttachment(global::spine_cpp.Spine.PointAttachment _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PointAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PointAttachment");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void ComputeWorldPosition(global::spine_cpp.Spine.Bone bone, ref float ox, ref float oy)
            {
                if (ReferenceEquals(bone, null))
                    throw new global::System.ArgumentNullException("bone", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = bone.__Instance;
                fixed (float* __ox1 = &ox)
                {
                    var __arg1 = __ox1;
                    fixed (float* __oy2 = &oy)
                    {
                        var __arg2 = __oy2;
                        __Internal.ComputeWorldPosition(__Instance, __arg0, __arg1, __arg2);
                    }
                }
            }

            public float ComputeWorldRotation(global::spine_cpp.Spine.Bone bone)
            {
                if (ReferenceEquals(bone, null))
                    throw new global::System.ArgumentNullException("bone", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = bone.__Instance;
                var ___ret = __Internal.ComputeWorldRotation(__Instance, __arg0);
                return ___ret;
            }

            public static explicit operator global::spine_cpp.Spine.PointAttachment(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.PointAttachment(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_PointAttachment_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public float X
            {
                get
                {
                    var ___ret = __Internal.GetX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetX(__Instance, value);
                }
            }

            public float Y
            {
                get
                {
                    var ___ret = __Internal.GetY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetY(__Instance, value);
                }
            }

            public float Rotation
            {
                get
                {
                    var ___ret = __Internal.GetRotation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetRotation(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public override global::spine_cpp.Spine.Attachment Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___CopyDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // PointAttachment
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.PointAttachment.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PointAttachment.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // Attachment *copy()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PointAttachment.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>Attachment that displays a texture region.</summary>
        public unsafe partial class RegionAttachment : global::spine_cpp.Spine.Attachment, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 216)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal int _refCount;
                internal fixed byte _xPadding[4];
                internal float _x;
                internal float _y;
                internal float _rotation;
                internal float _scaleX;
                internal float _scaleY;
                internal float _width;
                internal float _height;
                internal global::spine_cpp.Spine.Vector.__Internal _vertexOffset;
                internal global::spine_cpp.Spine.Vector.__Internal _uvs;
                internal global::spine_cpp.Spine.String.__Internal _path;
                internal global::spine_cpp.Spine.Color.__Internal _color;
                internal __IntPtr _region;
                internal __IntPtr _sequence;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0RegionAttachment@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0RegionAttachment@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?updateRegion@RegionAttachment@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?computeWorldVertices@RegionAttachment@spine@@QEAAXAEAVSlot@2@PEAM_K2@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ComputeWorldVertices(__IntPtr __instance, __IntPtr slot, float* worldVertices, ulong offset, ulong stride);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?computeWorldVertices@RegionAttachment@spine@@QEAAXAEAVSlot@2@AEAV?$Vector@M@2@_K2@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ComputeWorldVertices(__IntPtr __instance, __IntPtr slot, __IntPtr worldVertices, ulong offset, ulong stride);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getX@RegionAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setX@RegionAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getY@RegionAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setY@RegionAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getRotation@RegionAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetRotation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setRotation@RegionAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRotation(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getScaleX@RegionAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScaleX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setScaleX@RegionAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScaleX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getScaleY@RegionAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScaleY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setScaleY@RegionAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScaleY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getWidth@RegionAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWidth(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setWidth@RegionAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWidth(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getHeight@RegionAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetHeight(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setHeight@RegionAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHeight(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getColor@RegionAttachment@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getPath@RegionAttachment@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetPath(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setPath@RegionAttachment@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPath(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getRegion@RegionAttachment@spine@@QEAAPEAVTextureRegion@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setRegion@RegionAttachment@spine@@QEAAXPEAVTextureRegion@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRegion(__IntPtr __instance, __IntPtr region);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSequence@RegionAttachment@spine@@QEAAPEAVSequence@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSequence(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSequence@RegionAttachment@spine@@QEAAXPEAVSequence@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSequence(__IntPtr __instance, __IntPtr sequence);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getOffset@RegionAttachment@spine@@QEAAAEAV?$Vector@M@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetOffset(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getUVs@RegionAttachment@spine@@QEAAAEAV?$Vector@M@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetUVs(__IntPtr __instance);
            }

            internal static new RegionAttachment __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new RegionAttachment(native.ToPointer(), skipVTables);
            }

            internal static new RegionAttachment __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (RegionAttachment)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new RegionAttachment __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (RegionAttachment)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static RegionAttachment __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new RegionAttachment(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.RegionAttachment.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private RegionAttachment(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected RegionAttachment(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public RegionAttachment(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RegionAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RegionAttachment");
            }

            public RegionAttachment(global::spine_cpp.Spine.RegionAttachment _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RegionAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RegionAttachment");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void UpdateRegion()
            {
                __Internal.UpdateRegion(__Instance);
            }

            /// <summary>Transforms the attachment's four vertices to world coordinates.</summary>
            /// <param name="slot">The parent slot.</param>
            /// <param name="worldVertices">The output world vertices. Must have a length greater than or equal to offset + 8.</param>
            /// <param name="offset">The worldVertices index to begin writing values.</param>
            /// <param name="stride">The number of worldVertices entries between the value pairs written.</param>
            public void ComputeWorldVertices(global::spine_cpp.Spine.Slot slot, ref float worldVertices, ulong offset, ulong stride)
            {
                if (ReferenceEquals(slot, null))
                    throw new global::System.ArgumentNullException("slot", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slot.__Instance;
                fixed (float* __worldVertices1 = &worldVertices)
                {
                    var __arg1 = __worldVertices1;
                    __Internal.ComputeWorldVertices(__Instance, __arg0, __arg1, offset, stride);
                }
            }

            public void ComputeWorldVertices(global::spine_cpp.Spine.Slot slot, global::spine_cpp.Spine.Vector<float> worldVertices, ulong offset, ulong stride)
            {
                if (ReferenceEquals(slot, null))
                    throw new global::System.ArgumentNullException("slot", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slot.__Instance;
                if (ReferenceEquals(worldVertices, null))
                    throw new global::System.ArgumentNullException("worldVertices", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = worldVertices.__Instance;
                __Internal.ComputeWorldVertices(__Instance, __arg0, __arg1, offset, stride);
            }

            public static explicit operator global::spine_cpp.Spine.RegionAttachment(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.RegionAttachment(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_RegionAttachment_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public float X
            {
                get
                {
                    var ___ret = __Internal.GetX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetX(__Instance, value);
                }
            }

            public float Y
            {
                get
                {
                    var ___ret = __Internal.GetY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetY(__Instance, value);
                }
            }

            public float Rotation
            {
                get
                {
                    var ___ret = __Internal.GetRotation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetRotation(__Instance, value);
                }
            }

            public float ScaleX
            {
                get
                {
                    var ___ret = __Internal.GetScaleX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetScaleX(__Instance, value);
                }
            }

            public float ScaleY
            {
                get
                {
                    var ___ret = __Internal.GetScaleY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetScaleY(__Instance, value);
                }
            }

            public float Width
            {
                get
                {
                    var ___ret = __Internal.GetWidth(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetWidth(__Instance, value);
                }
            }

            public float Height
            {
                get
                {
                    var ___ret = __Internal.GetHeight(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHeight(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.String Path
            {
                get
                {
                    var ___ret = __Internal.GetPath(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetPath(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.TextureRegion Region
            {
                get
                {
                    var ___ret = __Internal.GetRegion(__Instance);
                    var __result0 = global::spine_cpp.Spine.TextureRegion.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetRegion(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.Sequence Sequence
            {
                get
                {
                    var ___ret = __Internal.GetSequence(__Instance);
                    var __result0 = global::spine_cpp.Spine.Sequence.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetSequence(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.Vector<float> Offset
            {
                get
                {
                    var ___ret = __Internal.GetOffset(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<float>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<float> UVs
            {
                get
                {
                    var ___ret = __Internal.GetUVs(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<float>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public override global::spine_cpp.Spine.Attachment Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___CopyDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // virtual ~RegionAttachment()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.RegionAttachment.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RegionAttachment.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // Attachment *copy()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RegionAttachment.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class RotateTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0RotateTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0RotateTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBoneIndex@RotateTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setBoneIndex@RotateTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new RotateTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new RotateTimeline(native.ToPointer(), skipVTables);
            }

            internal static new RotateTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (RotateTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new RotateTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (RotateTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static RotateTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new RotateTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.RotateTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private RotateTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected RotateTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public RotateTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RotateTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RotateTimeline");
            }

            public RotateTimeline(global::spine_cpp.Spine.RotateTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RotateTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RotateTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_RotateTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // RotateTimeline
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.RotateTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RotateTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.RotateTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RotateTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.RotateTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class TranslateTimeline : global::spine_cpp.Spine.CurveTimeline2, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0TranslateTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0TranslateTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBoneIndex@TranslateTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setBoneIndex@TranslateTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new TranslateTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TranslateTimeline(native.ToPointer(), skipVTables);
            }

            internal static new TranslateTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TranslateTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new TranslateTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (TranslateTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static TranslateTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TranslateTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.TranslateTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private TranslateTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TranslateTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public TranslateTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TranslateTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TranslateTimeline");
            }

            public TranslateTimeline(global::spine_cpp.Spine.TranslateTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TranslateTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TranslateTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_TranslateTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~TranslateTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.TranslateTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TranslateTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.TranslateTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TranslateTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.TranslateTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class TranslateXTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0TranslateXTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0TranslateXTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBoneIndex@TranslateXTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setBoneIndex@TranslateXTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new TranslateXTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TranslateXTimeline(native.ToPointer(), skipVTables);
            }

            internal static new TranslateXTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TranslateXTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new TranslateXTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (TranslateXTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static TranslateXTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TranslateXTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.TranslateXTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private TranslateXTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TranslateXTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public TranslateXTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TranslateXTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TranslateXTimeline");
            }

            public TranslateXTimeline(global::spine_cpp.Spine.TranslateXTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TranslateXTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TranslateXTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_TranslateXTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~TranslateXTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.TranslateXTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TranslateXTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.TranslateXTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TranslateXTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.TranslateXTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class TranslateYTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0TranslateYTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0TranslateYTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBoneIndex@TranslateYTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setBoneIndex@TranslateYTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new TranslateYTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TranslateYTimeline(native.ToPointer(), skipVTables);
            }

            internal static new TranslateYTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TranslateYTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new TranslateYTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (TranslateYTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static TranslateYTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TranslateYTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.TranslateYTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private TranslateYTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TranslateYTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public TranslateYTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TranslateYTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TranslateYTimeline");
            }

            public TranslateYTimeline(global::spine_cpp.Spine.TranslateYTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TranslateYTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TranslateYTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_TranslateYTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~TranslateYTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.TranslateYTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TranslateYTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.TranslateYTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TranslateYTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.TranslateYTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class ScaleTimeline : global::spine_cpp.Spine.CurveTimeline2, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0ScaleTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0ScaleTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBoneIndex@ScaleTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setBoneIndex@ScaleTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new ScaleTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ScaleTimeline(native.ToPointer(), skipVTables);
            }

            internal static new ScaleTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ScaleTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ScaleTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ScaleTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ScaleTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ScaleTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.ScaleTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private ScaleTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ScaleTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public ScaleTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ScaleTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ScaleTimeline");
            }

            public ScaleTimeline(global::spine_cpp.Spine.ScaleTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ScaleTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ScaleTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_ScaleTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~ScaleTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.ScaleTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ScaleTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.ScaleTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ScaleTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.ScaleTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class ScaleXTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0ScaleXTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0ScaleXTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBoneIndex@ScaleXTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setBoneIndex@ScaleXTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new ScaleXTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ScaleXTimeline(native.ToPointer(), skipVTables);
            }

            internal static new ScaleXTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ScaleXTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ScaleXTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ScaleXTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ScaleXTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ScaleXTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.ScaleXTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private ScaleXTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ScaleXTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public ScaleXTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ScaleXTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ScaleXTimeline");
            }

            public ScaleXTimeline(global::spine_cpp.Spine.ScaleXTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ScaleXTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ScaleXTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_ScaleXTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~ScaleXTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.ScaleXTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ScaleXTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.ScaleXTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ScaleXTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.ScaleXTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class ScaleYTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0ScaleYTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0ScaleYTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBoneIndex@ScaleYTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setBoneIndex@ScaleYTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new ScaleYTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ScaleYTimeline(native.ToPointer(), skipVTables);
            }

            internal static new ScaleYTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ScaleYTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ScaleYTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ScaleYTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ScaleYTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ScaleYTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.ScaleYTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private ScaleYTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ScaleYTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public ScaleYTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ScaleYTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ScaleYTimeline");
            }

            public ScaleYTimeline(global::spine_cpp.Spine.ScaleYTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ScaleYTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ScaleYTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_ScaleYTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~ScaleYTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.ScaleYTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ScaleYTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.ScaleYTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ScaleYTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.ScaleYTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class ShearTimeline : global::spine_cpp.Spine.CurveTimeline2, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0ShearTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0ShearTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBoneIndex@ShearTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setBoneIndex@ShearTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new ShearTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ShearTimeline(native.ToPointer(), skipVTables);
            }

            internal static new ShearTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ShearTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ShearTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ShearTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ShearTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ShearTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.ShearTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private ShearTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ShearTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public ShearTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ShearTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ShearTimeline");
            }

            public ShearTimeline(global::spine_cpp.Spine.ShearTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ShearTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ShearTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_ShearTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~ShearTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.ShearTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ShearTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.ShearTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ShearTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.ShearTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class ShearXTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0ShearXTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0ShearXTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBoneIndex@ShearXTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setBoneIndex@ShearXTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new ShearXTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ShearXTimeline(native.ToPointer(), skipVTables);
            }

            internal static new ShearXTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ShearXTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ShearXTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ShearXTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ShearXTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ShearXTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.ShearXTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private ShearXTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ShearXTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public ShearXTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ShearXTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ShearXTimeline");
            }

            public ShearXTimeline(global::spine_cpp.Spine.ShearXTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ShearXTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ShearXTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_ShearXTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~ShearXTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.ShearXTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ShearXTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.ShearXTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ShearXTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.ShearXTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class ShearYTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0ShearYTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0ShearYTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBoneIndex@ShearYTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setBoneIndex@ShearYTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new ShearYTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ShearYTimeline(native.ToPointer(), skipVTables);
            }

            internal static new ShearYTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ShearYTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ShearYTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ShearYTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ShearYTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ShearYTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.ShearYTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private ShearYTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ShearYTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public ShearYTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ShearYTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ShearYTimeline");
            }

            public ShearYTimeline(global::spine_cpp.Spine.ShearYTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ShearYTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ShearYTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_ShearYTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~ShearYTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.ShearYTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ShearYTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.ShearYTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ShearYTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.ShearYTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class Skeleton : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 288)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _data;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal global::spine_cpp.Spine.Vector.__Internal _slots;
                internal global::spine_cpp.Spine.Vector.__Internal _drawOrder;
                internal global::spine_cpp.Spine.Vector.__Internal _ikConstraints;
                internal global::spine_cpp.Spine.Vector.__Internal _transformConstraints;
                internal global::spine_cpp.Spine.Vector.__Internal _pathConstraints;
                internal global::spine_cpp.Spine.Vector.__Internal _updateCache;
                internal __IntPtr _skin;
                internal global::spine_cpp.Spine.Color.__Internal _color;
                internal float _scaleX;
                internal float _scaleY;
                internal float _x;
                internal float _y;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Skeleton@spine@@QEAA@PEAVSkeletonData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr skeletonData);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Skeleton@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?updateCache@Skeleton@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateCache(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?printUpdateCache@Skeleton@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PrintUpdateCache(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?updateWorldTransform@Skeleton@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateWorldTransform(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?updateWorldTransform@Skeleton@spine@@QEAAXPEAVBone@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateWorldTransform(__IntPtr __instance, __IntPtr parent);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setToSetupPose@Skeleton@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetToSetupPose(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setBonesToSetupPose@Skeleton@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBonesToSetupPose(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSlotsToSetupPose@Skeleton@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSlotsToSetupPose(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?findBone@Skeleton@spine@@QEAAPEAVBone@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindBone(__IntPtr __instance, __IntPtr boneName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?findSlot@Skeleton@spine@@QEAAPEAVSlot@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindSlot(__IntPtr __instance, __IntPtr slotName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSkin@Skeleton@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSkin(__IntPtr __instance, __IntPtr skinName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAttachment@Skeleton@spine@@QEAAPEAVAttachment@2@AEBVString@2@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAttachment(__IntPtr __instance, __IntPtr slotName, __IntPtr attachmentName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAttachment@Skeleton@spine@@QEAAPEAVAttachment@2@HAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAttachment(__IntPtr __instance, int slotIndex, __IntPtr attachmentName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAttachment@Skeleton@spine@@QEAAXAEBVString@2@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAttachment(__IntPtr __instance, __IntPtr slotName, __IntPtr attachmentName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?findIkConstraint@Skeleton@spine@@QEAAPEAVIkConstraint@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindIkConstraint(__IntPtr __instance, __IntPtr constraintName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?findTransformConstraint@Skeleton@spine@@QEAAPEAVTransformConstraint@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindTransformConstraint(__IntPtr __instance, __IntPtr constraintName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?findPathConstraint@Skeleton@spine@@QEAAPEAVPathConstraint@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindPathConstraint(__IntPtr __instance, __IntPtr constraintName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBounds@Skeleton@spine@@QEAAXAEAM000AEAV?$Vector@M@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetBounds(__IntPtr __instance, float* outX, float* outY, float* outWidth, float* outHeight, __IntPtr outVertexBuffer);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setColor@Skeleton@spine@@QEAAXMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetColor(__IntPtr __instance, float r, float g, float b, float a);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setPosition@Skeleton@spine@@QEAAXMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPosition(__IntPtr __instance, float x, float y);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSkin@Skeleton@spine@@QEAAPEAVSkin@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSkin(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setSkin@Skeleton@spine@@QEAAXPEAVSkin@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSkin_1(__IntPtr __instance, __IntPtr newSkin);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getRootBone@Skeleton@spine@@QEAAPEAVBone@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRootBone(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getData@Skeleton@spine@@QEAAPEAVSkeletonData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBones@Skeleton@spine@@QEAAAEAV?$Vector@PEAVBone@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBones(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getUpdateCacheList@Skeleton@spine@@QEAAAEAV?$Vector@PEAVUpdatable@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetUpdateCacheList(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSlots@Skeleton@spine@@QEAAAEAV?$Vector@PEAVSlot@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSlots(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getDrawOrder@Skeleton@spine@@QEAAAEAV?$Vector@PEAVSlot@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDrawOrder(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getIkConstraints@Skeleton@spine@@QEAAAEAV?$Vector@PEAVIkConstraint@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetIkConstraints(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getPathConstraints@Skeleton@spine@@QEAAAEAV?$Vector@PEAVPathConstraint@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetPathConstraints(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTransformConstraints@Skeleton@spine@@QEAAAEAV?$Vector@PEAVTransformConstraint@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTransformConstraints(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getColor@Skeleton@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getX@Skeleton@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setX@Skeleton@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getY@Skeleton@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setY@Skeleton@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getScaleX@Skeleton@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScaleX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setScaleX@Skeleton@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScaleX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getScaleY@Skeleton@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScaleY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setScaleY@Skeleton@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScaleY(__IntPtr __instance, float inValue);
            }

            internal static new Skeleton __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Skeleton(native.ToPointer(), skipVTables);
            }

            internal static new Skeleton __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Skeleton)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Skeleton __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Skeleton)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Skeleton __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Skeleton(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Skeleton.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Skeleton(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Skeleton(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Skeleton(global::spine_cpp.Spine.SkeletonData skeletonData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Skeleton.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = skeletonData is null ? __IntPtr.Zero : skeletonData.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Skeleton");
            }

            public Skeleton(global::spine_cpp.Spine.Skeleton _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Skeleton.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Skeleton");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Caches information about bones and constraints. Must be called if bones, constraints or weighted path attachments are added</para>
            /// <para>or removed.</para>
            /// </summary>
            public void UpdateCache()
            {
                __Internal.UpdateCache(__Instance);
            }

            public void PrintUpdateCache()
            {
                __Internal.PrintUpdateCache(__Instance);
            }

            /// <summary>Updates the world transform for each bone and applies constraints.</summary>
            public void UpdateWorldTransform()
            {
                __Internal.UpdateWorldTransform(__Instance);
            }

            public void UpdateWorldTransform(global::spine_cpp.Spine.Bone parent)
            {
                var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
                __Internal.UpdateWorldTransform(__Instance, __arg0);
            }

            /// <summary>Sets the bones, constraints, and slots to their setup pose values.</summary>
            public void SetToSetupPose()
            {
                __Internal.SetToSetupPose(__Instance);
            }

            /// <summary>Sets the bones and constraints to their setup pose values.</summary>
            public void SetBonesToSetupPose()
            {
                __Internal.SetBonesToSetupPose(__Instance);
            }

            public void SetSlotsToSetupPose()
            {
                __Internal.SetSlotsToSetupPose(__Instance);
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.Bone FindBone(global::spine_cpp.Spine.String boneName)
            {
                if (ReferenceEquals(boneName, null))
                    throw new global::System.ArgumentNullException("boneName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = boneName.__Instance;
                var ___ret = __Internal.FindBone(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.Bone.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.Slot FindSlot(global::spine_cpp.Spine.String slotName)
            {
                if (ReferenceEquals(slotName, null))
                    throw new global::System.ArgumentNullException("slotName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slotName.__Instance;
                var ___ret = __Internal.FindSlot(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Sets a skin by name (see setSkin).</summary>
            public void SetSkin(global::spine_cpp.Spine.String skinName)
            {
                if (ReferenceEquals(skinName, null))
                    throw new global::System.ArgumentNullException("skinName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skinName.__Instance;
                __Internal.SetSkin(__Instance, __arg0);
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.Attachment GetAttachment(global::spine_cpp.Spine.String slotName, global::spine_cpp.Spine.String attachmentName)
            {
                if (ReferenceEquals(slotName, null))
                    throw new global::System.ArgumentNullException("slotName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slotName.__Instance;
                if (ReferenceEquals(attachmentName, null))
                    throw new global::System.ArgumentNullException("attachmentName", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = attachmentName.__Instance;
                var ___ret = __Internal.GetAttachment(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.Attachment GetAttachment(int slotIndex, global::spine_cpp.Spine.String attachmentName)
            {
                if (ReferenceEquals(attachmentName, null))
                    throw new global::System.ArgumentNullException("attachmentName", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = attachmentName.__Instance;
                var ___ret = __Internal.GetAttachment(__Instance, slotIndex, __arg1);
                var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <param name="attachmentName">May be empty.</param>
            public void SetAttachment(global::spine_cpp.Spine.String slotName, global::spine_cpp.Spine.String attachmentName)
            {
                if (ReferenceEquals(slotName, null))
                    throw new global::System.ArgumentNullException("slotName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slotName.__Instance;
                if (ReferenceEquals(attachmentName, null))
                    throw new global::System.ArgumentNullException("attachmentName", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = attachmentName.__Instance;
                __Internal.SetAttachment(__Instance, __arg0, __arg1);
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.IkConstraint FindIkConstraint(global::spine_cpp.Spine.String constraintName)
            {
                if (ReferenceEquals(constraintName, null))
                    throw new global::System.ArgumentNullException("constraintName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = constraintName.__Instance;
                var ___ret = __Internal.FindIkConstraint(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.IkConstraint.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.TransformConstraint FindTransformConstraint(global::spine_cpp.Spine.String constraintName)
            {
                if (ReferenceEquals(constraintName, null))
                    throw new global::System.ArgumentNullException("constraintName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = constraintName.__Instance;
                var ___ret = __Internal.FindTransformConstraint(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.TransformConstraint.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.PathConstraint FindPathConstraint(global::spine_cpp.Spine.String constraintName)
            {
                if (ReferenceEquals(constraintName, null))
                    throw new global::System.ArgumentNullException("constraintName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = constraintName.__Instance;
                var ___ret = __Internal.FindPathConstraint(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.PathConstraint.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.</summary>
            /// <param name="outX">The horizontal distance between the skeleton origin and the left side of the AABB.</param>
            /// <param name="outY">The vertical distance between the skeleton origin and the bottom side of the AABB.</param>
            /// <param name="outWidth">The width of the AABB</param>
            /// <param name="outHeight">The height of the AABB.</param>
            /// <param name="outVertexBuffer">Reference to hold a Vector of floats. This method will assign it with new floats as needed.</param>
            public void GetBounds(ref float outX, ref float outY, ref float outWidth, ref float outHeight, global::spine_cpp.Spine.Vector<float> outVertexBuffer)
            {
                fixed (float* __outX0 = &outX)
                {
                    var __arg0 = __outX0;
                    fixed (float* __outY1 = &outY)
                    {
                        var __arg1 = __outY1;
                        fixed (float* __outWidth2 = &outWidth)
                        {
                            var __arg2 = __outWidth2;
                            fixed (float* __outHeight3 = &outHeight)
                            {
                                var __arg3 = __outHeight3;
                                if (ReferenceEquals(outVertexBuffer, null))
                                    throw new global::System.ArgumentNullException("outVertexBuffer", "Cannot be null because it is a C++ reference (&).");
                                var __arg4 = outVertexBuffer.__Instance;
                                __Internal.GetBounds(__Instance, __arg0, __arg1, __arg2, __arg3, __arg4);
                            }
                        }
                    }
                }
            }

            public void SetColor(float r, float g, float b, float a)
            {
                __Internal.SetColor(__Instance, r, g, b, a);
            }

            public void SetPosition(float x, float y)
            {
                __Internal.SetPosition(__Instance, x, y);
            }

            public static explicit operator global::spine_cpp.Spine.Skeleton(global::spine_cpp.Spine.SkeletonData skeletonData)
            {
                return new global::spine_cpp.Spine.Skeleton(skeletonData);
            }

            public global::spine_cpp.Spine.Skin Skin
            {
                get
                {
                    var ___ret = __Internal.GetSkin(__Instance);
                    var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetSkin_1(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.Bone RootBone
            {
                get
                {
                    var ___ret = __Internal.GetRootBone(__Instance);
                    var __result0 = global::spine_cpp.Spine.Bone.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.SkeletonData Data
            {
                get
                {
                    var ___ret = __Internal.GetData(__Instance);
                    var __result0 = global::spine_cpp.Spine.SkeletonData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Bone> Bones
            {
                get
                {
                    var ___ret = __Internal.GetBones(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Bone>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Updatable> UpdateCacheList
            {
                get
                {
                    var ___ret = __Internal.GetUpdateCacheList(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Updatable>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Slot> Slots
            {
                get
                {
                    var ___ret = __Internal.GetSlots(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Slot>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Slot> DrawOrder
            {
                get
                {
                    var ___ret = __Internal.GetDrawOrder(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Slot>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.IkConstraint> IkConstraints
            {
                get
                {
                    var ___ret = __Internal.GetIkConstraints(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.IkConstraint>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.PathConstraint> PathConstraints
            {
                get
                {
                    var ___ret = __Internal.GetPathConstraints(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.PathConstraint>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.TransformConstraint> TransformConstraints
            {
                get
                {
                    var ___ret = __Internal.GetTransformConstraints(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.TransformConstraint>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public float X
            {
                get
                {
                    var ___ret = __Internal.GetX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetX(__Instance, value);
                }
            }

            public float Y
            {
                get
                {
                    var ___ret = __Internal.GetY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetY(__Instance, value);
                }
            }

            public float ScaleX
            {
                get
                {
                    var ___ret = __Internal.GetScaleX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetScaleX(__Instance, value);
                }
            }

            public float ScaleY
            {
                get
                {
                    var ___ret = __Internal.GetScaleY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetScaleY(__Instance, value);
                }
            }

            #region Virtual table interop

            // ~Skeleton()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Skeleton.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class SkeletonBinary : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 88)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _attachmentLoader;
                internal global::spine_cpp.Spine.Vector.__Internal _linkedMeshes;
                internal global::spine_cpp.Spine.String.__Internal _error;
                internal float _scale;
                internal byte _ownsLoader;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SkeletonBinary@spine@@QEAA@PEAVAtlas@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr atlasArray);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SkeletonBinary@spine@@QEAA@PEAVAttachmentLoader@1@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr attachmentLoader, bool ownsLoader);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SkeletonBinary@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?readSkeletonData@SkeletonBinary@spine@@QEAAPEAVSkeletonData@2@PEBEH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ReadSkeletonData(__IntPtr __instance, byte* binary, int length);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?readSkeletonDataFile@SkeletonBinary@spine@@QEAAPEAVSkeletonData@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ReadSkeletonDataFile(__IntPtr __instance, __IntPtr path);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setScale@SkeletonBinary@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScale(__IntPtr __instance, float scale);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getError@SkeletonBinary@spine@@QEAAAEAVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetError(__IntPtr __instance);
            }

            internal static new SkeletonBinary __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SkeletonBinary(native.ToPointer(), skipVTables);
            }

            internal static new SkeletonBinary __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SkeletonBinary)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new SkeletonBinary __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (SkeletonBinary)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static SkeletonBinary __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SkeletonBinary(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.SkeletonBinary.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private SkeletonBinary(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SkeletonBinary(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public SkeletonBinary(global::spine_cpp.Spine.Atlas atlasArray)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonBinary.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = atlasArray is null ? __IntPtr.Zero : atlasArray.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonBinary");
            }

            public SkeletonBinary(global::spine_cpp.Spine.AttachmentLoader attachmentLoader, bool ownsLoader)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonBinary.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = attachmentLoader is null ? __IntPtr.Zero : attachmentLoader.__Instance;
                __Internal.ctor(__Instance, __arg0, ownsLoader);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonBinary");
            }

            public SkeletonBinary(global::spine_cpp.Spine.SkeletonBinary _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonBinary.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonBinary");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::spine_cpp.Spine.SkeletonData ReadSkeletonData(byte* binary, int length)
            {
                var ___ret = __Internal.ReadSkeletonData(__Instance, binary, length);
                var __result0 = global::spine_cpp.Spine.SkeletonData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.SkeletonData ReadSkeletonDataFile(global::spine_cpp.Spine.String path)
            {
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = path.__Instance;
                var ___ret = __Internal.ReadSkeletonDataFile(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.SkeletonData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public void SetScale(float scale)
            {
                __Internal.SetScale(__Instance, scale);
            }

            public static explicit operator global::spine_cpp.Spine.SkeletonBinary(global::spine_cpp.Spine.Atlas atlasArray)
            {
                return new global::spine_cpp.Spine.SkeletonBinary(atlasArray);
            }

            public const int BONE_ROTATE = 0;
            public const int BONE_TRANSLATE = 1;
            public const int BONE_TRANSLATEX = 2;
            public const int BONE_TRANSLATEY = 3;
            public const int BONE_SCALE = 4;
            public const int BONE_SCALEX = 5;
            public const int BONE_SCALEY = 6;
            public const int BONE_SHEAR = 7;
            public const int BONE_SHEARX = 8;
            public const int BONE_SHEARY = 9;
            public const int SLOT_ATTACHMENT = 0;
            public const int SLOT_RGBA = 1;
            public const int SLOT_RGB = 2;
            public const int SLOT_RGBA2 = 3;
            public const int SLOT_RGB2 = 4;
            public const int SLOT_ALPHA = 5;
            public const int ATTACHMENT_DEFORM = 0;
            public const int ATTACHMENT_SEQUENCE = 1;
            public const int PATH_POSITION = 0;
            public const int PATH_SPACING = 1;
            public const int PATH_MIX = 2;
            public const int CURVE_LINEAR = 0;
            public const int CURVE_STEPPED = 1;
            public const int CURVE_BEZIER = 2;
            public global::spine_cpp.Spine.String Error
            {
                get
                {
                    var ___ret = __Internal.GetError(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // ~SkeletonBinary()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.SkeletonBinary.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>
        /// <para>Collects each BoundingBoxAttachment that is visible and computes the world vertices for its polygon.</para>
        /// <para>The polygon vertices are provided along with convenience methods for doing hit detection.</para>
        /// </summary>
        public unsafe partial class SkeletonBounds : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 128)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Pool.__Internalc__N_spine_S_Pool____N_spine_S_Polygon _polygonPool;
                internal global::spine_cpp.Spine.Vector.__Internal _boundingBoxes;
                internal global::spine_cpp.Spine.Vector.__Internal _polygons;
                internal float _minX;
                internal float _minY;
                internal float _maxX;
                internal float _maxY;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SkeletonBounds@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SkeletonBounds@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?update@SkeletonBounds@spine@@QEAAXAEAVSkeleton@2@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Update(__IntPtr __instance, __IntPtr skeleton, bool updateAabb);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?aabbcontainsPoint@SkeletonBounds@spine@@QEAA_NMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool AabbcontainsPoint(__IntPtr __instance, float x, float y);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?aabbintersectsSegment@SkeletonBounds@spine@@QEAA_NMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool AabbintersectsSegment(__IntPtr __instance, float x1, float y1, float x2, float y2);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?aabbIntersectsSkeleton@SkeletonBounds@spine@@QEAA_NV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool AabbIntersectsSkeleton(__IntPtr __instance, __IntPtr bounds);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?containsPoint@SkeletonBounds@spine@@QEAA_NPEAVPolygon@2@MM@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ContainsPoint(__IntPtr __instance, __IntPtr polygon, float x, float y);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?containsPoint@SkeletonBounds@spine@@QEAAPEAVBoundingBoxAttachment@2@MM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ContainsPoint(__IntPtr __instance, float x, float y);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?intersectsSegment@SkeletonBounds@spine@@QEAAPEAVBoundingBoxAttachment@2@MMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr IntersectsSegment(__IntPtr __instance, float x1, float y1, float x2, float y2);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?intersectsSegment@SkeletonBounds@spine@@QEAA_NPEAVPolygon@2@MMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IntersectsSegment(__IntPtr __instance, __IntPtr polygon, float x1, float y1, float x2, float y2);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getPolygon@SkeletonBounds@spine@@QEAAPEAVPolygon@2@PEAVBoundingBoxAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetPolygon(__IntPtr __instance, __IntPtr attachment);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBoundingBox@SkeletonBounds@spine@@QEAAPEAVBoundingBoxAttachment@2@PEAVPolygon@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBoundingBox(__IntPtr __instance, __IntPtr polygon);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getPolygons@SkeletonBounds@spine@@QEAAAEAV?$Vector@PEAVPolygon@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetPolygons(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBoundingBoxes@SkeletonBounds@spine@@QEAAAEAV?$Vector@PEAVBoundingBoxAttachment@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBoundingBoxes(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getWidth@SkeletonBounds@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWidth(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getHeight@SkeletonBounds@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetHeight(__IntPtr __instance);
            }

            internal static new SkeletonBounds __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SkeletonBounds(native.ToPointer(), skipVTables);
            }

            internal static new SkeletonBounds __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SkeletonBounds)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new SkeletonBounds __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (SkeletonBounds)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static SkeletonBounds __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SkeletonBounds(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.SkeletonBounds.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private SkeletonBounds(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SkeletonBounds(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public SkeletonBounds()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonBounds.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonBounds");
            }

            public SkeletonBounds(global::spine_cpp.Spine.SkeletonBounds _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonBounds.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonBounds");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Clears any previous polygons, finds all visible bounding box attachments,</para>
            /// <para>and computes the world vertices for each bounding box's polygon.</para>
            /// </summary>
            /// <param name="skeleton">The skeleton.</param>
            /// <param name="updateAabb">
            /// <para>If true, the axis aligned bounding box containing all the polygons is computed.</para>
            /// <para>If false, the SkeletonBounds AABB methods will always return true.</para>
            /// </param>
            public void Update(global::spine_cpp.Spine.Skeleton skeleton, bool updateAabb)
            {
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                __Internal.Update(__Instance, __arg0, updateAabb);
            }

            /// <summary>Returns true if the axis aligned bounding box contains the point.</summary>
            public bool AabbcontainsPoint(float x, float y)
            {
                var ___ret = __Internal.AabbcontainsPoint(__Instance, x, y);
                return ___ret;
            }

            /// <summary>Returns true if the axis aligned bounding box intersects the line segment.</summary>
            public bool AabbintersectsSegment(float x1, float y1, float x2, float y2)
            {
                var ___ret = __Internal.AabbintersectsSegment(__Instance, x1, y1, x2, y2);
                return ___ret;
            }

            /// <summary>Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds.</summary>
            public bool AabbIntersectsSkeleton(global::spine_cpp.Spine.SkeletonBounds bounds)
            {
                if (ReferenceEquals(bounds, null))
                    throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
                var __arg0 = bounds.__Instance;
                var ___ret = __Internal.AabbIntersectsSkeleton(__Instance, __arg0);
                return ___ret;
            }

            /// <summary>Returns true if the polygon contains the point.</summary>
            public bool ContainsPoint(global::spine_cpp.Spine.Polygon polygon, float x, float y)
            {
                var __arg0 = polygon is null ? __IntPtr.Zero : polygon.__Instance;
                var ___ret = __Internal.ContainsPoint(__Instance, __arg0, x, y);
                return ___ret;
            }

            /// <summary>
            /// <para>Returns the first bounding box attachment that contains the point, or NULL. When doing many checks, it is usually more</para>
            /// <para>efficient to only call this method if {</para>
            /// </summary>
            public global::spine_cpp.Spine.BoundingBoxAttachment ContainsPoint(float x, float y)
            {
                var ___ret = __Internal.ContainsPoint(__Instance, x, y);
                var __result0 = global::spine_cpp.Spine.BoundingBoxAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>
            /// <para>Returns the first bounding box attachment that contains the line segment, or NULL. When doing many checks, it is usually</para>
            /// <para>more efficient to only call this method if {</para>
            /// </summary>
            public global::spine_cpp.Spine.BoundingBoxAttachment IntersectsSegment(float x1, float y1, float x2, float y2)
            {
                var ___ret = __Internal.IntersectsSegment(__Instance, x1, y1, x2, y2);
                var __result0 = global::spine_cpp.Spine.BoundingBoxAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Returns true if the polygon contains the line segment.</summary>
            public bool IntersectsSegment(global::spine_cpp.Spine.Polygon polygon, float x1, float y1, float x2, float y2)
            {
                var __arg0 = polygon is null ? __IntPtr.Zero : polygon.__Instance;
                var ___ret = __Internal.IntersectsSegment(__Instance, __arg0, x1, y1, x2, y2);
                return ___ret;
            }

            /// <summary>
            /// <para>Returns the polygon for the given bounding box attachment or null if no</para>
            /// <para>polygon can be found for the attachment. Requires a call to update() first.</para>
            /// </summary>
            public global::spine_cpp.Spine.Polygon GetPolygon(global::spine_cpp.Spine.BoundingBoxAttachment attachment)
            {
                var __arg0 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
                var ___ret = __Internal.GetPolygon(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.Polygon.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Returns the bounding box for the given polygon or null. Requires a call to update() first.</summary>
            public global::spine_cpp.Spine.BoundingBoxAttachment GetBoundingBox(global::spine_cpp.Spine.Polygon polygon)
            {
                var __arg0 = polygon is null ? __IntPtr.Zero : polygon.__Instance;
                var ___ret = __Internal.GetBoundingBox(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.BoundingBoxAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Returns all polygons or an empty vector. Requires a call to update() first.</summary>
            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Polygon> Polygons
            {
                get
                {
                    var ___ret = __Internal.GetPolygons(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Polygon>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>Returns all bounding boxes. Requires a call to update() first.</summary>
            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.BoundingBoxAttachment> BoundingBoxes
            {
                get
                {
                    var ___ret = __Internal.GetBoundingBoxes(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.BoundingBoxAttachment>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public float Width
            {
                get
                {
                    var ___ret = __Internal.GetWidth(__Instance);
                    return ___ret;
                }
            }

            public float Height
            {
                get
                {
                    var ___ret = __Internal.GetHeight(__Instance);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // ~SkeletonBounds()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.SkeletonBounds.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class Polygon : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 48)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _vertices;
                internal int _count;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Polygon@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Polygon@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new Polygon __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Polygon(native.ToPointer(), skipVTables);
            }

            internal static new Polygon __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Polygon)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Polygon __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Polygon)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Polygon __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Polygon(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Polygon.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Polygon(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Polygon(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Polygon()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Polygon.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Polygon");
            }

            public Polygon(global::spine_cpp.Spine.Polygon _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Polygon.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Polygon");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::spine_cpp.Spine.Vector<float> Vertices
            {
                get
                {
                    return global::spine_cpp.Spine.Vector<float>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_vertices));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->_vertices = *(global::spine_cpp.Spine.Vector.__Internal*) value.__Instance;
                }
            }

            public int Count
            {
                get
                {
                    return ((__Internal*)__Instance)->_count;
                }

                set
                {
                    ((__Internal*)__Instance)->_count = value;
                }
            }

            #region Virtual table interop

            // Polygon
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Polygon.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class Triangulator : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 248)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _convexPolygons;
                internal global::spine_cpp.Spine.Vector.__Internal _convexPolygonsIndices;
                internal global::spine_cpp.Spine.Vector.__Internal _indices;
                internal global::spine_cpp.Spine.Vector.__Internal _isConcaveArray;
                internal global::spine_cpp.Spine.Vector.__Internal _triangles;
                internal global::spine_cpp.Spine.Pool.__Internalc__N_spine_S_Pool____N_spine_S_Vector__f _polygonPool;
                internal global::spine_cpp.Spine.Pool.__Internalc__N_spine_S_Pool____N_spine_S_Vector__I _polygonIndicesPool;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Triangulator@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Triangulator@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?triangulate@Triangulator@spine@@QEAAAEAV?$Vector@H@2@AEAV?$Vector@M@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Triangulate(__IntPtr __instance, __IntPtr vertices);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?decompose@Triangulator@spine@@QEAAAEAV?$Vector@PEAV?$Vector@M@spine@@@2@AEAV?$Vector@M@2@AEAV?$Vector@H@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Decompose(__IntPtr __instance, __IntPtr vertices, __IntPtr triangles);
            }

            internal static new Triangulator __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Triangulator(native.ToPointer(), skipVTables);
            }

            internal static new Triangulator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Triangulator)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Triangulator __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Triangulator)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Triangulator __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Triangulator(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Triangulator.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Triangulator(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Triangulator(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Triangulator(global::spine_cpp.Spine.Triangulator _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Triangulator.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Triangulator");
            }

            public Triangulator()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Triangulator.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Triangulator");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::spine_cpp.Spine.Vector<int> Triangulate(global::spine_cpp.Spine.Vector<float> vertices)
            {
                if (ReferenceEquals(vertices, null))
                    throw new global::System.ArgumentNullException("vertices", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = vertices.__Instance;
                var ___ret = __Internal.Triangulate(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.Vector<int>.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Vector<float>> Decompose(global::spine_cpp.Spine.Vector<float> vertices, global::spine_cpp.Spine.Vector<int> triangles)
            {
                if (ReferenceEquals(vertices, null))
                    throw new global::System.ArgumentNullException("vertices", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = vertices.__Instance;
                if (ReferenceEquals(triangles, null))
                    throw new global::System.ArgumentNullException("triangles", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = triangles.__Instance;
                var ___ret = __Internal.Decompose(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Vector<float>>.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            #region Virtual table interop

            // ~Triangulator()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Triangulator.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class SkeletonClipping : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 464)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Triangulator.__Internal _triangulator;
                internal global::spine_cpp.Spine.Vector.__Internal _clippingPolygon;
                internal global::spine_cpp.Spine.Vector.__Internal _clipOutput;
                internal global::spine_cpp.Spine.Vector.__Internal _clippedVertices;
                internal global::spine_cpp.Spine.Vector.__Internal _clippedTriangles;
                internal global::spine_cpp.Spine.Vector.__Internal _clippedUVs;
                internal global::spine_cpp.Spine.Vector.__Internal _scratch;
                internal __IntPtr _clipAttachment;
                internal __IntPtr _clippingPolygons;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SkeletonClipping@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SkeletonClipping@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clipStart@SkeletonClipping@spine@@QEAA_KAEAVSlot@2@PEAVClippingAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong ClipStart(__IntPtr __instance, __IntPtr slot, __IntPtr clip);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clipEnd@SkeletonClipping@spine@@QEAAXAEAVSlot@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClipEnd(__IntPtr __instance, __IntPtr slot);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clipEnd@SkeletonClipping@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClipEnd(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clipTriangles@SkeletonClipping@spine@@QEAAXPEAMPEAG_K02@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClipTriangles(__IntPtr __instance, float* vertices, ushort* triangles, ulong trianglesLength, float* uvs, ulong stride);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?clipTriangles@SkeletonClipping@spine@@QEAAXAEAV?$Vector@M@2@AEAV?$Vector@G@2@0_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClipTriangles(__IntPtr __instance, __IntPtr vertices, __IntPtr triangles, __IntPtr uvs, ulong stride);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?isClipping@SkeletonClipping@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsClipping(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getClippedVertices@SkeletonClipping@spine@@QEAAAEAV?$Vector@M@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetClippedVertices(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getClippedTriangles@SkeletonClipping@spine@@QEAAAEAV?$Vector@G@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetClippedTriangles(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getClippedUVs@SkeletonClipping@spine@@QEAAAEAV?$Vector@M@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetClippedUVs(__IntPtr __instance);
            }

            internal static new SkeletonClipping __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SkeletonClipping(native.ToPointer(), skipVTables);
            }

            internal static new SkeletonClipping __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SkeletonClipping)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new SkeletonClipping __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (SkeletonClipping)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static SkeletonClipping __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SkeletonClipping(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.SkeletonClipping.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private SkeletonClipping(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SkeletonClipping(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public SkeletonClipping()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonClipping.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonClipping");
            }

            public SkeletonClipping(global::spine_cpp.Spine.SkeletonClipping _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonClipping.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonClipping");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public ulong ClipStart(global::spine_cpp.Spine.Slot slot, global::spine_cpp.Spine.ClippingAttachment clip)
            {
                if (ReferenceEquals(slot, null))
                    throw new global::System.ArgumentNullException("slot", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slot.__Instance;
                var __arg1 = clip is null ? __IntPtr.Zero : clip.__Instance;
                var ___ret = __Internal.ClipStart(__Instance, __arg0, __arg1);
                return ___ret;
            }

            public void ClipEnd(global::spine_cpp.Spine.Slot slot)
            {
                if (ReferenceEquals(slot, null))
                    throw new global::System.ArgumentNullException("slot", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slot.__Instance;
                __Internal.ClipEnd(__Instance, __arg0);
            }

            public void ClipEnd()
            {
                __Internal.ClipEnd(__Instance);
            }

            public void ClipTriangles(ref float vertices, ref ushort triangles, ulong trianglesLength, ref float uvs, ulong stride)
            {
                fixed (float* __vertices0 = &vertices)
                {
                    var __arg0 = __vertices0;
                    fixed (ushort* __triangles1 = &triangles)
                    {
                        var __arg1 = __triangles1;
                        fixed (float* __uvs3 = &uvs)
                        {
                            var __arg3 = __uvs3;
                            __Internal.ClipTriangles(__Instance, __arg0, __arg1, trianglesLength, __arg3, stride);
                        }
                    }
                }
            }

            public void ClipTriangles(global::spine_cpp.Spine.Vector<float> vertices, global::spine_cpp.Spine.Vector<ushort> triangles, global::spine_cpp.Spine.Vector<float> uvs, ulong stride)
            {
                if (ReferenceEquals(vertices, null))
                    throw new global::System.ArgumentNullException("vertices", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = vertices.__Instance;
                if (ReferenceEquals(triangles, null))
                    throw new global::System.ArgumentNullException("triangles", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = triangles.__Instance;
                if (ReferenceEquals(uvs, null))
                    throw new global::System.ArgumentNullException("uvs", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = uvs.__Instance;
                __Internal.ClipTriangles(__Instance, __arg0, __arg1, __arg2, stride);
            }

            public bool IsClipping
            {
                get
                {
                    var ___ret = __Internal.IsClipping(__Instance);
                    return ___ret;
                }
            }

            public global::spine_cpp.Spine.Vector<float> ClippedVertices
            {
                get
                {
                    var ___ret = __Internal.GetClippedVertices(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<float>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<ushort> ClippedTriangles
            {
                get
                {
                    var ___ret = __Internal.GetClippedTriangles(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<ushort>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<float> ClippedUVs
            {
                get
                {
                    var ___ret = __Internal.GetClippedUVs(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<float>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // SkeletonClipping
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.SkeletonClipping.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>Stores the setup pose and all of the stateless data for a skeleton.</summary>
        public unsafe partial class SkeletonData : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 488)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal global::spine_cpp.Spine.Vector.__Internal _slots;
                internal global::spine_cpp.Spine.Vector.__Internal _skins;
                internal __IntPtr _defaultSkin;
                internal global::spine_cpp.Spine.Vector.__Internal _events;
                internal global::spine_cpp.Spine.Vector.__Internal _animations;
                internal global::spine_cpp.Spine.Vector.__Internal _ikConstraints;
                internal global::spine_cpp.Spine.Vector.__Internal _transformConstraints;
                internal global::spine_cpp.Spine.Vector.__Internal _pathConstraints;
                internal float _x;
                internal float _y;
                internal float _width;
                internal float _height;
                internal global::spine_cpp.Spine.String.__Internal _version;
                internal global::spine_cpp.Spine.String.__Internal _hash;
                internal global::spine_cpp.Spine.Vector.__Internal _strings;
                internal float _fps;
                internal global::spine_cpp.Spine.String.__Internal _imagesPath;
                internal global::spine_cpp.Spine.String.__Internal _audioPath;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SkeletonData@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SkeletonData@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?findBone@SkeletonData@spine@@QEAAPEAVBoneData@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindBone(__IntPtr __instance, __IntPtr boneName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?findSlot@SkeletonData@spine@@QEAAPEAVSlotData@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindSlot(__IntPtr __instance, __IntPtr slotName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?findSkin@SkeletonData@spine@@QEAAPEAVSkin@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindSkin(__IntPtr __instance, __IntPtr skinName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?findEvent@SkeletonData@spine@@QEAAPEAVEventData@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindEvent(__IntPtr __instance, __IntPtr eventDataName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?findAnimation@SkeletonData@spine@@QEAAPEAVAnimation@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindAnimation(__IntPtr __instance, __IntPtr animationName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?findIkConstraint@SkeletonData@spine@@QEAAPEAVIkConstraintData@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindIkConstraint(__IntPtr __instance, __IntPtr constraintName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?findTransformConstraint@SkeletonData@spine@@QEAAPEAVTransformConstraintData@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindTransformConstraint(__IntPtr __instance, __IntPtr constraintName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?findPathConstraint@SkeletonData@spine@@QEAAPEAVPathConstraintData@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindPathConstraint(__IntPtr __instance, __IntPtr constraintName);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getName@SkeletonData@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setName@SkeletonData@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetName(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBones@SkeletonData@spine@@QEAAAEAV?$Vector@PEAVBoneData@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBones(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSlots@SkeletonData@spine@@QEAAAEAV?$Vector@PEAVSlotData@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSlots(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getSkins@SkeletonData@spine@@QEAAAEAV?$Vector@PEAVSkin@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSkins(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getDefaultSkin@SkeletonData@spine@@QEAAPEAVSkin@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDefaultSkin(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setDefaultSkin@SkeletonData@spine@@QEAAXPEAVSkin@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDefaultSkin(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getEvents@SkeletonData@spine@@QEAAAEAV?$Vector@PEAVEventData@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetEvents(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAnimations@SkeletonData@spine@@QEAAAEAV?$Vector@PEAVAnimation@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAnimations(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getIkConstraints@SkeletonData@spine@@QEAAAEAV?$Vector@PEAVIkConstraintData@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetIkConstraints(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTransformConstraints@SkeletonData@spine@@QEAAAEAV?$Vector@PEAVTransformConstraintData@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTransformConstraints(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getPathConstraints@SkeletonData@spine@@QEAAAEAV?$Vector@PEAVPathConstraintData@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetPathConstraints(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getX@SkeletonData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setX@SkeletonData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getY@SkeletonData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setY@SkeletonData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getWidth@SkeletonData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWidth(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setWidth@SkeletonData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWidth(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getHeight@SkeletonData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetHeight(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setHeight@SkeletonData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHeight(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getVersion@SkeletonData@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetVersion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setVersion@SkeletonData@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVersion(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getHash@SkeletonData@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetHash(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setHash@SkeletonData@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHash(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getImagesPath@SkeletonData@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetImagesPath(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setImagesPath@SkeletonData@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetImagesPath(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAudioPath@SkeletonData@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAudioPath(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAudioPath@SkeletonData@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAudioPath(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getFps@SkeletonData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetFps(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setFps@SkeletonData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFps(__IntPtr __instance, float inValue);
            }

            internal static new SkeletonData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SkeletonData(native.ToPointer(), skipVTables);
            }

            internal static new SkeletonData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SkeletonData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new SkeletonData __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (SkeletonData)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static SkeletonData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SkeletonData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.SkeletonData.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private SkeletonData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SkeletonData(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public SkeletonData()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonData");
            }

            public SkeletonData(global::spine_cpp.Spine.SkeletonData _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonData");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Finds a bone by comparing each bone's name.</para>
            /// <para>It is more efficient to cache the results of this method than to call it multiple times.</para>
            /// </summary>
            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.BoneData FindBone(global::spine_cpp.Spine.String boneName)
            {
                if (ReferenceEquals(boneName, null))
                    throw new global::System.ArgumentNullException("boneName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = boneName.__Instance;
                var ___ret = __Internal.FindBone(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.BoneData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.SlotData FindSlot(global::spine_cpp.Spine.String slotName)
            {
                if (ReferenceEquals(slotName, null))
                    throw new global::System.ArgumentNullException("slotName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slotName.__Instance;
                var ___ret = __Internal.FindSlot(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.SlotData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.Skin FindSkin(global::spine_cpp.Spine.String skinName)
            {
                if (ReferenceEquals(skinName, null))
                    throw new global::System.ArgumentNullException("skinName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skinName.__Instance;
                var ___ret = __Internal.FindSkin(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.EventData FindEvent(global::spine_cpp.Spine.String eventDataName)
            {
                if (ReferenceEquals(eventDataName, null))
                    throw new global::System.ArgumentNullException("eventDataName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = eventDataName.__Instance;
                var ___ret = __Internal.FindEvent(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.EventData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.Animation FindAnimation(global::spine_cpp.Spine.String animationName)
            {
                if (ReferenceEquals(animationName, null))
                    throw new global::System.ArgumentNullException("animationName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = animationName.__Instance;
                var ___ret = __Internal.FindAnimation(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.Animation.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.IkConstraintData FindIkConstraint(global::spine_cpp.Spine.String constraintName)
            {
                if (ReferenceEquals(constraintName, null))
                    throw new global::System.ArgumentNullException("constraintName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = constraintName.__Instance;
                var ___ret = __Internal.FindIkConstraint(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.IkConstraintData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.TransformConstraintData FindTransformConstraint(global::spine_cpp.Spine.String constraintName)
            {
                if (ReferenceEquals(constraintName, null))
                    throw new global::System.ArgumentNullException("constraintName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = constraintName.__Instance;
                var ___ret = __Internal.FindTransformConstraint(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.TransformConstraintData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.PathConstraintData FindPathConstraint(global::spine_cpp.Spine.String constraintName)
            {
                if (ReferenceEquals(constraintName, null))
                    throw new global::System.ArgumentNullException("constraintName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = constraintName.__Instance;
                var ___ret = __Internal.FindPathConstraint(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.PathConstraintData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetName(__Instance, __arg0);
                }
            }

            /// <summary>The skeleton's bones, sorted parent first. The root bone is always the first bone.</summary>
            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.BoneData> Bones
            {
                get
                {
                    var ___ret = __Internal.GetBones(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.BoneData>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SlotData> Slots
            {
                get
                {
                    var ___ret = __Internal.GetSlots(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SlotData>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>All skins, including the default skin.</summary>
            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Skin> Skins
            {
                get
                {
                    var ___ret = __Internal.GetSkins(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Skin>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>
            /// <para>The skeleton's default skin.</para>
            /// <para>By default this skin contains all attachments that were not in a skin in Spine.</para>
            /// </summary>
            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.Skin DefaultSkin
            {
                get
                {
                    var ___ret = __Internal.GetDefaultSkin(__Instance);
                    var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetDefaultSkin(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.EventData> Events
            {
                get
                {
                    var ___ret = __Internal.GetEvents(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.EventData>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Animation> Animations
            {
                get
                {
                    var ___ret = __Internal.GetAnimations(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Animation>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.IkConstraintData> IkConstraints
            {
                get
                {
                    var ___ret = __Internal.GetIkConstraints(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.IkConstraintData>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.TransformConstraintData> TransformConstraints
            {
                get
                {
                    var ___ret = __Internal.GetTransformConstraints(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.TransformConstraintData>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.PathConstraintData> PathConstraints
            {
                get
                {
                    var ___ret = __Internal.GetPathConstraints(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.PathConstraintData>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public float X
            {
                get
                {
                    var ___ret = __Internal.GetX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetX(__Instance, value);
                }
            }

            public float Y
            {
                get
                {
                    var ___ret = __Internal.GetY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetY(__Instance, value);
                }
            }

            public float Width
            {
                get
                {
                    var ___ret = __Internal.GetWidth(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetWidth(__Instance, value);
                }
            }

            public float Height
            {
                get
                {
                    var ___ret = __Internal.GetHeight(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHeight(__Instance, value);
                }
            }

            /// <summary>The Spine version used to export this data, or NULL.</summary>
            public global::spine_cpp.Spine.String Version
            {
                get
                {
                    var ___ret = __Internal.GetVersion(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetVersion(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.String Hash
            {
                get
                {
                    var ___ret = __Internal.GetHash(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetHash(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.String ImagesPath
            {
                get
                {
                    var ___ret = __Internal.GetImagesPath(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetImagesPath(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.String AudioPath
            {
                get
                {
                    var ___ret = __Internal.GetAudioPath(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetAudioPath(__Instance, __arg0);
                }
            }

            /// <summary>The dopesheet FPS in Spine. Available only when nonessential data was exported.</summary>
            public float Fps
            {
                get
                {
                    var ___ret = __Internal.GetFps(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetFps(__Instance, value);
                }
            }

            #region Virtual table interop

            // ~SkeletonData()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.SkeletonData.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class SkeletonJson : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 88)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _attachmentLoader;
                internal global::spine_cpp.Spine.Vector.__Internal _linkedMeshes;
                internal float _scale;
                internal byte _ownsLoader;
                internal global::spine_cpp.Spine.String.__Internal _error;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SkeletonJson@spine@@QEAA@PEAVAtlas@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr atlas);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SkeletonJson@spine@@QEAA@PEAVAttachmentLoader@1@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr attachmentLoader, bool ownsLoader);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SkeletonJson@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?readSkeletonDataFile@SkeletonJson@spine@@QEAAPEAVSkeletonData@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ReadSkeletonDataFile(__IntPtr __instance, __IntPtr path);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?readSkeletonData@SkeletonJson@spine@@QEAAPEAVSkeletonData@2@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ReadSkeletonData(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string json);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setScale@SkeletonJson@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScale(__IntPtr __instance, float scale);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getError@SkeletonJson@spine@@QEAAAEAVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetError(__IntPtr __instance);
            }

            internal static new SkeletonJson __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SkeletonJson(native.ToPointer(), skipVTables);
            }

            internal static new SkeletonJson __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SkeletonJson)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new SkeletonJson __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (SkeletonJson)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static SkeletonJson __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SkeletonJson(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.SkeletonJson.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private SkeletonJson(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SkeletonJson(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public SkeletonJson(global::spine_cpp.Spine.Atlas atlas)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonJson.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = atlas is null ? __IntPtr.Zero : atlas.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonJson");
            }

            public SkeletonJson(global::spine_cpp.Spine.AttachmentLoader attachmentLoader, bool ownsLoader)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonJson.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = attachmentLoader is null ? __IntPtr.Zero : attachmentLoader.__Instance;
                __Internal.ctor(__Instance, __arg0, ownsLoader);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonJson");
            }

            public SkeletonJson(global::spine_cpp.Spine.SkeletonJson _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonJson.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonJson");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::spine_cpp.Spine.SkeletonData ReadSkeletonDataFile(global::spine_cpp.Spine.String path)
            {
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = path.__Instance;
                var ___ret = __Internal.ReadSkeletonDataFile(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.SkeletonData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.SkeletonData ReadSkeletonData(string json)
            {
                var ___ret = __Internal.ReadSkeletonData(__Instance, json);
                var __result0 = global::spine_cpp.Spine.SkeletonData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public void SetScale(float scale)
            {
                __Internal.SetScale(__Instance, scale);
            }

            public static explicit operator global::spine_cpp.Spine.SkeletonJson(global::spine_cpp.Spine.Atlas atlas)
            {
                return new global::spine_cpp.Spine.SkeletonJson(atlas);
            }

            public global::spine_cpp.Spine.String Error
            {
                get
                {
                    var ___ret = __Internal.GetError(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // ~SkeletonJson()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.SkeletonJson.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class SkinEntry : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 48)]
            public partial struct __Internal
            {
                internal ulong _slotIndex;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal __IntPtr _attachment;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SkinEntry@spine@@QEAA@_KAEBVString@1@PEAVAttachment@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong slotIndex, __IntPtr name, __IntPtr attachment);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SkinEntry@spine@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??1SkinEntry@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.SkinEntry> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.SkinEntry>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.Spine.SkinEntry managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.Spine.SkinEntry managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static SkinEntry __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SkinEntry(native.ToPointer(), skipVTables);
            }

            internal static SkinEntry __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SkinEntry)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static SkinEntry __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SkinEntry(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.SkinEntry.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private SkinEntry(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SkinEntry(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public SkinEntry(ulong slotIndex, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.Attachment attachment)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkinEntry.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var __arg2 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
                __Internal.ctor(__Instance, slotIndex, __arg1, __arg2);
            }

            public SkinEntry(global::spine_cpp.Spine.SkinEntry _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkinEntry.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public ulong SlotIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_slotIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_slotIndex = value;
                }
            }

            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    return global::spine_cpp.Spine.String.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_name));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->_name = *(global::spine_cpp.Spine.String.__Internal*) value.__Instance;
                }
            }

            public global::spine_cpp.Spine.Attachment Attachment
            {
                get
                {
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(((__Internal*)__Instance)->_attachment, true);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->_attachment = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }
        }

        public unsafe partial class SkinEntries : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public partial struct __Internal
            {
                internal __IntPtr _buckets;
                internal ulong _slotIndex;
                internal ulong _bucketIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SkinEntries@spine@@QEAA@AEAV?$Vector@V?$Vector@USkinEntry@spine@@@spine@@@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr buckets);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SkinEntries@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?hasNext@SkinEntries@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasNext(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?next@SkinEntries@spine@@QEAAAEAUSkinEntry@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Next(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.SkinEntries> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.SkinEntries>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.Spine.SkinEntries managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.Spine.SkinEntries managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static SkinEntries __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SkinEntries(native.ToPointer(), skipVTables);
            }

            internal static SkinEntries __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SkinEntries)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static SkinEntries __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SkinEntries(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private SkinEntries(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SkinEntries(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public SkinEntries(global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>> buckets)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkinEntries.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(buckets, null))
                    throw new global::System.ArgumentNullException("buckets", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = buckets.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            public SkinEntries(global::spine_cpp.Spine.SkinEntries _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkinEntries.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::spine_cpp.Spine.SkinEntries.__Internal*) __Instance) = *((global::spine_cpp.Spine.SkinEntries.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static implicit operator global::spine_cpp.Spine.SkinEntries(global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.SkinEntry>> buckets)
            {
                return new global::spine_cpp.Spine.SkinEntries(buckets);
            }

            public bool HasNext
            {
                get
                {
                    var ___ret = __Internal.HasNext(__Instance);
                    return ___ret;
                }
            }

            public global::spine_cpp.Spine.SkinEntry Next
            {
                get
                {
                    var ___ret = __Internal.Next(__Instance);
                    var __result0 = global::spine_cpp.Spine.SkinEntry.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }

        /// <summary>
        /// <para>Stores attachments by slot index and attachment name.</para>
        /// <para>See SkeletonData::getDefaultSkin, Skeleton::getSkin, and</para>
        /// <para>http://esotericsoftware.com/spine-runtime-skins in the Spine Runtimes Guide.</para>
        /// </summary>
        public unsafe partial class Skin : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 144)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal global::spine_cpp.Spine.Skin.AttachmentMap.__Internal _attachments;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal global::spine_cpp.Spine.Vector.__Internal _constraints;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Skin@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Skin@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAttachment@Skin@spine@@QEAAX_KAEBVString@2@PEAVAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAttachment(__IntPtr __instance, ulong slotIndex, __IntPtr name, __IntPtr attachment);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAttachment@Skin@spine@@QEAAPEAVAttachment@2@_KAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAttachment(__IntPtr __instance, ulong slotIndex, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?removeAttachment@Skin@spine@@QEAAX_KAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAttachment(__IntPtr __instance, ulong slotIndex, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?findNamesForSlot@Skin@spine@@QEAAX_KAEAV?$Vector@VString@spine@@@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void FindNamesForSlot(__IntPtr __instance, ulong slotIndex, __IntPtr names);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?findAttachmentsForSlot@Skin@spine@@QEAAX_KAEAV?$Vector@PEAVAttachment@spine@@@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void FindAttachmentsForSlot(__IntPtr __instance, ulong slotIndex, __IntPtr attachments);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?addSkin@Skin@spine@@QEAAXPEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddSkin(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?copySkin@Skin@spine@@QEAAXPEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CopySkin(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getName@Skin@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAttachments@Skin@spine@@QEAA?AVSkinEntries@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetAttachments(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBones@Skin@spine@@QEAAAEAV?$Vector@PEAVBoneData@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBones(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getConstraints@Skin@spine@@QEAAAEAV?$Vector@PEAVConstraintData@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetConstraints(__IntPtr __instance);
            }

            public unsafe partial class AttachmentMap : global::spine_cpp.Spine.SpineObject, IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public new partial struct __Internal
                {
                    internal __IntPtr vfptr_SpineObject;
                    internal global::spine_cpp.Spine.Vector.__Internal _buckets;

                    [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AttachmentMap@Skin@spine@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern __IntPtr ctor(__IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0AttachmentMap@Skin@spine@@QEAA@AEBV012@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                    [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?put@AttachmentMap@Skin@spine@@QEAAX_KAEBVString@3@PEAVAttachment@3@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern void Put(__IntPtr __instance, ulong slotIndex, __IntPtr attachmentName, __IntPtr attachment);

                    [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?get@AttachmentMap@Skin@spine@@QEAAPEAVAttachment@3@_KAEBVString@3@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern __IntPtr Get(__IntPtr __instance, ulong slotIndex, __IntPtr attachmentName);

                    [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?remove@AttachmentMap@Skin@spine@@QEAAX_KAEBVString@3@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern void Remove(__IntPtr __instance, ulong slotIndex, __IntPtr attachmentName);

                    [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getEntries@AttachmentMap@Skin@spine@@QEAA?AVSkinEntries@3@XZ", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern void GetEntries(__IntPtr __instance, __IntPtr @return);
                }

                internal static new AttachmentMap __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new AttachmentMap(native.ToPointer(), skipVTables);
                }

                internal static new AttachmentMap __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (AttachmentMap)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static new AttachmentMap __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (AttachmentMap)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static AttachmentMap __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new AttachmentMap(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    global::spine_cpp.Spine.Skin.AttachmentMap.__Internal.cctor(ret, new __IntPtr(&native));
                    return ret.ToPointer();
                }

                private AttachmentMap(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected AttachmentMap(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                    if (native == null)
                        return;
                    if (!skipVTables)
                        SetupVTables(true);
                }

                protected AttachmentMap()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Skin.AttachmentMap.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    __Internal.ctor(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Skin.AttachmentMap");
                }

                public AttachmentMap(global::spine_cpp.Spine.Skin.AttachmentMap _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Skin.AttachmentMap.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Skin.AttachmentMap");
                }

                partial void DisposePartial(bool disposing);

                internal protected override void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (callNativeDtor)
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                        ___dtorDelegate(__Instance, 0);
                    }
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public void Put(ulong slotIndex, global::spine_cpp.Spine.String attachmentName, global::spine_cpp.Spine.Attachment attachment)
                {
                    if (ReferenceEquals(attachmentName, null))
                        throw new global::System.ArgumentNullException("attachmentName", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = attachmentName.__Instance;
                    var __arg2 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
                    __Internal.Put(__Instance, slotIndex, __arg1, __arg2);
                }

                public global::spine_cpp.Spine.Attachment Get(ulong slotIndex, global::spine_cpp.Spine.String attachmentName)
                {
                    if (ReferenceEquals(attachmentName, null))
                        throw new global::System.ArgumentNullException("attachmentName", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = attachmentName.__Instance;
                    var ___ret = __Internal.Get(__Instance, slotIndex, __arg1);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                public void Remove(ulong slotIndex, global::spine_cpp.Spine.String attachmentName)
                {
                    if (ReferenceEquals(attachmentName, null))
                        throw new global::System.ArgumentNullException("attachmentName", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = attachmentName.__Instance;
                    __Internal.Remove(__Instance, slotIndex, __arg1);
                }

                public global::spine_cpp.Spine.SkinEntries Entries
                {
                    get
                    {
                        var ___ret = new global::spine_cpp.Spine.SkinEntries.__Internal();
                        __Internal.GetEntries(__Instance, new IntPtr(&___ret));
                        return global::spine_cpp.Spine.SkinEntries.__CreateInstance(___ret);
                    }
                }

                #region Virtual table interop

                // AttachmentMap
                private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::spine_cpp.Spine.Skin.AttachmentMap.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static new class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[1];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                internal override CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal override void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            internal static new Skin __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Skin(native.ToPointer(), skipVTables);
            }

            internal static new Skin __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Skin)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Skin __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Skin)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Skin __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Skin(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Skin.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Skin(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Skin(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Skin(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Skin.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Skin");
            }

            public Skin(global::spine_cpp.Spine.Skin _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Skin.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Skin");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Adds an attachment to the skin for the specified slot index and name.</para>
            /// <para>If the name already exists for the slot, the previous value is replaced.</para>
            /// </summary>
            public void SetAttachment(ulong slotIndex, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.Attachment attachment)
            {
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var __arg2 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
                __Internal.SetAttachment(__Instance, slotIndex, __arg1, __arg2);
            }

            /// <summary>Returns the attachment for the specified slot index and name, or NULL.</summary>
            public global::spine_cpp.Spine.Attachment GetAttachment(ulong slotIndex, global::spine_cpp.Spine.String name)
            {
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var ___ret = __Internal.GetAttachment(__Instance, slotIndex, __arg1);
                var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public void RemoveAttachment(ulong slotIndex, global::spine_cpp.Spine.String name)
            {
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                __Internal.RemoveAttachment(__Instance, slotIndex, __arg1);
            }

            /// <summary>Finds the skin keys for a given slot. The results are added to the passed array of names.</summary>
            /// <param name="slotIndex">The target slotIndex. To find the slot index, use SkeletonData::findSlot and SlotData::getIndex.</param>
            /// <param name="names">Found skin key names will be added to this array.</param>
            public void FindNamesForSlot(ulong slotIndex, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.String> names)
            {
                if (ReferenceEquals(names, null))
                    throw new global::System.ArgumentNullException("names", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = names.__Instance;
                __Internal.FindNamesForSlot(__Instance, slotIndex, __arg1);
            }

            /// <summary>Finds the attachments for a given slot. The results are added to the passed array of Attachments.</summary>
            /// <param name="slotIndex">The target slotIndex. To find the slot index, use SkeletonData::findSlot and SlotData::getIndex.</param>
            /// <param name="attachments">Found Attachments will be added to this array.</param>
            public void FindAttachmentsForSlot(ulong slotIndex, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Attachment> attachments)
            {
                if (ReferenceEquals(attachments, null))
                    throw new global::System.ArgumentNullException("attachments", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = attachments.__Instance;
                __Internal.FindAttachmentsForSlot(__Instance, slotIndex, __arg1);
            }

            /// <summary>Adds all attachments, bones, and constraints from the specified skin to this skin.</summary>
            public void AddSkin(global::spine_cpp.Spine.Skin other)
            {
                var __arg0 = other is null ? __IntPtr.Zero : other.__Instance;
                __Internal.AddSkin(__Instance, __arg0);
            }

            /// <summary>Adds all attachments, bones, and constraints from the specified skin to this skin. Attachments are deep copied.</summary>
            public void CopySkin(global::spine_cpp.Spine.Skin other)
            {
                var __arg0 = other is null ? __IntPtr.Zero : other.__Instance;
                __Internal.CopySkin(__Instance, __arg0);
            }

            public static explicit operator global::spine_cpp.Spine.Skin(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.Skin(name);
            }

            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.SkinEntries Attachments
            {
                get
                {
                    var ___ret = new global::spine_cpp.Spine.SkinEntries.__Internal();
                    __Internal.GetAttachments(__Instance, new IntPtr(&___ret));
                    return global::spine_cpp.Spine.SkinEntries.__CreateInstance(___ret);
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.BoneData> Bones
            {
                get
                {
                    var ___ret = __Internal.GetBones(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.BoneData>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.ConstraintData> Constraints
            {
                get
                {
                    var ___ret = __Internal.GetConstraints(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.ConstraintData>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // ~Skin()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Skin.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class SlotData : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 152)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal int _index;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal __IntPtr _boneData;
                internal global::spine_cpp.Spine.Color.__Internal _color;
                internal global::spine_cpp.Spine.Color.__Internal _darkColor;
                internal byte _hasDarkColor;
                internal global::spine_cpp.Spine.String.__Internal _attachmentName;
                internal global::spine_cpp.Spine.BlendMode _blendMode;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SlotData@spine@@QEAA@HAEBVString@1@AEAVBoneData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, int index, __IntPtr name, __IntPtr boneData);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SlotData@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getIndex@SlotData@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getName@SlotData@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBoneData@SlotData@spine@@QEAAAEAVBoneData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBoneData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getColor@SlotData@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getDarkColor@SlotData@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDarkColor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?hasDarkColor@SlotData@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasDarkColor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setHasDarkColor@SlotData@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHasDarkColor(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getAttachmentName@SlotData@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAttachmentName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setAttachmentName@SlotData@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAttachmentName(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBlendMode@SlotData@spine@@QEAA?AW4BlendMode@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::spine_cpp.Spine.BlendMode GetBlendMode(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setBlendMode@SlotData@spine@@QEAAXW4BlendMode@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBlendMode(__IntPtr __instance, global::spine_cpp.Spine.BlendMode inValue);
            }

            internal static new SlotData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SlotData(native.ToPointer(), skipVTables);
            }

            internal static new SlotData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SlotData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new SlotData __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (SlotData)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static SlotData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SlotData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.SlotData.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private SlotData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SlotData(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public SlotData(int index, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.BoneData boneData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SlotData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                if (ReferenceEquals(boneData, null))
                    throw new global::System.ArgumentNullException("boneData", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = boneData.__Instance;
                __Internal.ctor(__Instance, index, __arg1, __arg2);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SlotData");
            }

            public SlotData(global::spine_cpp.Spine.SlotData _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SlotData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SlotData");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public int Index
            {
                get
                {
                    var ___ret = __Internal.GetIndex(__Instance);
                    return ___ret;
                }
            }

            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.BoneData BoneData
            {
                get
                {
                    var ___ret = __Internal.GetBoneData(__Instance);
                    var __result0 = global::spine_cpp.Spine.BoneData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Color DarkColor
            {
                get
                {
                    var ___ret = __Internal.GetDarkColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public bool HasDarkColor
            {
                get
                {
                    var ___ret = __Internal.HasDarkColor(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHasDarkColor(__Instance, value);
                }
            }

            /// <summary>May be empty.</summary>
            public global::spine_cpp.Spine.String AttachmentName
            {
                get
                {
                    var ___ret = __Internal.GetAttachmentName(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetAttachmentName(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.BlendMode BlendMode
            {
                get
                {
                    var ___ret = __Internal.GetBlendMode(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBlendMode(__Instance, value);
                }
            }

            #region Virtual table interop

            // SlotData
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.SlotData.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe abstract partial class TextureLoader : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0TextureLoader@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0TextureLoader@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new TextureLoader __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TextureLoaderInternal(native.ToPointer(), skipVTables);
            }

            internal static new TextureLoader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TextureLoader)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new TextureLoader __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (TextureLoader)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static TextureLoader __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TextureLoaderInternal(native, skipVTables);
            }

            protected TextureLoader(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected TextureLoader()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TextureLoader.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TextureLoader");
            }

            protected TextureLoader(global::spine_cpp.Spine.TextureLoader _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TextureLoader.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TextureLoader");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract void Load(global::spine_cpp.Spine.AtlasPage page, global::spine_cpp.Spine.String path);

            public abstract void Unload(__IntPtr texture);

            #region Virtual table interop

            // virtual ~TextureLoader()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.TextureLoader.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void load(AtlasPage &page, const String &path) = 0
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr___IntPtr _LoadDelegateInstance;

            private static void _LoadDelegateHook(__IntPtr __instance, __IntPtr page, __IntPtr path)
            {
                var __target = global::spine_cpp.Spine.TextureLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.AtlasPage.__GetOrCreateInstance(page, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(path, false, skipVTables: true);
                __target.Load(__result0, __result1);
            }

            // void unload(void *texture) = 0
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr _UnloadDelegateInstance;

            private static void _UnloadDelegateHook(__IntPtr __instance, __IntPtr texture)
            {
                var __target = global::spine_cpp.Spine.TextureLoader.__GetInstance(__instance);
                __target.Unload(texture);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _LoadDelegateInstance += _LoadDelegateHook;
                    _UnloadDelegateInstance += _UnloadDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_UnloadDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class TextureLoaderInternal : global::spine_cpp.Spine.TextureLoader, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal TextureLoaderInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal TextureLoaderInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override void Load(global::spine_cpp.Spine.AtlasPage page, global::spine_cpp.Spine.String path)
            {
                var ___LoadDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 1);
                if (ReferenceEquals(page, null))
                    throw new global::System.ArgumentNullException("page", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = page.__Instance;
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = path.__Instance;
                ___LoadDelegate(__Instance, __arg0, __arg1);
            }

            public override void Unload(__IntPtr texture)
            {
                var ___UnloadDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr>(0, 2);
                ___UnloadDelegate(__Instance, texture);
            }
        }
    }

    namespace Spine
    {
        public unsafe partial class TransformConstraint : global::spine_cpp.Spine.Updatable, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 88)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _data;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal __IntPtr _target;
                internal float _mixRotate;
                internal float _mixX;
                internal float _mixY;
                internal float _mixScaleX;
                internal float _mixScaleY;
                internal float _mixShearY;
                internal byte _active;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0TransformConstraint@spine@@QEAA@AEAVTransformConstraintData@1@AEAVSkeleton@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr data, __IntPtr skeleton);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0TransformConstraint@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getData@TransformConstraint@spine@@QEAAAEAVTransformConstraintData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBones@TransformConstraint@spine@@QEAAAEAV?$Vector@PEAVBone@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBones(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTarget@TransformConstraint@spine@@QEAAPEAVBone@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTarget(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setTarget@TransformConstraint@spine@@QEAAXPEAVBone@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTarget(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixRotate@TransformConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixRotate(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixRotate@TransformConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixRotate(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixX@TransformConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixX@TransformConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixY@TransformConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixY@TransformConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixScaleX@TransformConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixScaleX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixScaleX@TransformConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixScaleX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixScaleY@TransformConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixScaleY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixScaleY@TransformConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixScaleY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixShearY@TransformConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixShearY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixShearY@TransformConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixShearY(__IntPtr __instance, float inValue);
            }

            internal static new TransformConstraint __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TransformConstraint(native.ToPointer(), skipVTables);
            }

            internal static new TransformConstraint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TransformConstraint)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new TransformConstraint __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (TransformConstraint)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static TransformConstraint __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TransformConstraint(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.TransformConstraint.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private TransformConstraint(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TransformConstraint(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public TransformConstraint(global::spine_cpp.Spine.TransformConstraintData data, global::spine_cpp.Spine.Skeleton skeleton)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TransformConstraint.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(data, null))
                    throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = data.__Instance;
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = skeleton.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TransformConstraint");
            }

            public TransformConstraint(global::spine_cpp.Spine.TransformConstraint _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TransformConstraint.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TransformConstraint");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Update()
            {
                var ___UpdateDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr>(0, 2);
                ___UpdateDelegate(__Instance);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_TransformConstraint_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public virtual int Order
            {
                get
                {
                    var ___GetOrderDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_int___IntPtr>(0, 5);
                    var ___ret = ___GetOrderDelegate(__Instance);
                    return ___ret;
                }
            }

            public global::spine_cpp.Spine.TransformConstraintData Data
            {
                get
                {
                    var ___ret = __Internal.GetData(__Instance);
                    var __result0 = global::spine_cpp.Spine.TransformConstraintData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Bone> Bones
            {
                get
                {
                    var ___ret = __Internal.GetBones(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Bone>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Bone Target
            {
                get
                {
                    var ___ret = __Internal.GetTarget(__Instance);
                    var __result0 = global::spine_cpp.Spine.Bone.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetTarget(__Instance, __arg0);
                }
            }

            public float MixRotate
            {
                get
                {
                    var ___ret = __Internal.GetMixRotate(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixRotate(__Instance, value);
                }
            }

            public float MixX
            {
                get
                {
                    var ___ret = __Internal.GetMixX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixX(__Instance, value);
                }
            }

            public float MixY
            {
                get
                {
                    var ___ret = __Internal.GetMixY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixY(__Instance, value);
                }
            }

            public float MixScaleX
            {
                get
                {
                    var ___ret = __Internal.GetMixScaleX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixScaleX(__Instance, value);
                }
            }

            public float MixScaleY
            {
                get
                {
                    var ___ret = __Internal.GetMixScaleY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixScaleY(__Instance, value);
                }
            }

            public float MixShearY
            {
                get
                {
                    var ___ret = __Internal.GetMixShearY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixShearY(__Instance, value);
                }
            }

            public override bool Active
            {
                get
                {
                    var ___IsActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_bool___IntPtr>(0, 3);
                    var ___ret = ___IsActiveDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_bool>(0, 4);
                    ___SetActiveDelegate(__Instance, value);
                }
            }

            #region Virtual table interop

            // TransformConstraint
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.TransformConstraint.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TransformConstraint.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void update()
            private static global::spine_cpp.Delegates.Action___IntPtr _UpdateDelegateInstance;

            private static void _UpdateDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TransformConstraint.__GetInstance(__instance);
                __target.Update();
            }

            // bool isActive()
            private static global::spine_cpp.Delegates.Func_bool___IntPtr _IsActiveDelegateInstance;

            private static bool _IsActiveDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TransformConstraint.__GetInstance(__instance);
                var ___ret = __target.Active;
                return ___ret;
            }

            // void setActive(bool inValue)
            private static global::spine_cpp.Delegates.Action___IntPtr_bool _SetActiveDelegateInstance;

            private static void _SetActiveDelegateHook(__IntPtr __instance, bool inValue)
            {
                var __target = global::spine_cpp.Spine.TransformConstraint.__GetInstance(__instance);
                __target.Active = inValue;
            }

            // int getOrder()
            private static global::spine_cpp.Delegates.Func_int___IntPtr _GetOrderDelegateInstance;

            private static int _GetOrderDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TransformConstraint.__GetInstance(__instance);
                var ___ret = __target.Order;
                return ___ret;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[6];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _UpdateDelegateInstance += _UpdateDelegateHook;
                    _IsActiveDelegateInstance += _IsActiveDelegateHook;
                    _SetActiveDelegateInstance += _SetActiveDelegateHook;
                    _GetOrderDelegateInstance += _GetOrderDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_IsActiveDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetActiveDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetOrderDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                VTables.Methods[0] = new Delegate[6];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class TransformConstraintData : global::spine_cpp.Spine.ConstraintData, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 152)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal ulong _order;
                internal byte _skinRequired;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal __IntPtr _target;
                internal float _mixRotate;
                internal float _mixX;
                internal float _mixY;
                internal float _mixScaleX;
                internal float _mixScaleY;
                internal float _mixShearY;
                internal float _offsetRotation;
                internal float _offsetX;
                internal float _offsetY;
                internal float _offsetScaleX;
                internal float _offsetScaleY;
                internal float _offsetShearY;
                internal byte _relative;
                internal byte _local;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0TransformConstraintData@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0TransformConstraintData@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getBones@TransformConstraintData@spine@@QEAAAEAV?$Vector@PEAVBoneData@spine@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBones(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTarget@TransformConstraintData@spine@@QEAAPEAVBoneData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTarget(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setTarget@TransformConstraintData@spine@@QEAAXPEAVBoneData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTarget(__IntPtr __instance, __IntPtr target);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixRotate@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixRotate(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixRotate@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixRotate(__IntPtr __instance, float mixRotate);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixX@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixX@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixX(__IntPtr __instance, float mixX);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixY@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixY@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixY(__IntPtr __instance, float mixY);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixScaleX@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixScaleX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixScaleX@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixScaleX(__IntPtr __instance, float mixScaleX);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixScaleY@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixScaleY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixScaleY@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixScaleY(__IntPtr __instance, float mixScaleY);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getMixShearY@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixShearY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setMixShearY@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixShearY(__IntPtr __instance, float mixShearY);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getOffsetRotation@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetOffsetRotation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setOffsetRotation@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetOffsetRotation(__IntPtr __instance, float offsetRotation);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getOffsetX@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetOffsetX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setOffsetX@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetOffsetX(__IntPtr __instance, float offsetX);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getOffsetY@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetOffsetY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setOffsetY@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetOffsetY(__IntPtr __instance, float offsetY);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getOffsetScaleX@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetOffsetScaleX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setOffsetScaleX@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetOffsetScaleX(__IntPtr __instance, float offsetScaleX);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getOffsetScaleY@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetOffsetScaleY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setOffsetScaleY@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetOffsetScaleY(__IntPtr __instance, float offsetScaleY);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getOffsetShearY@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetOffsetShearY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setOffsetShearY@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetOffsetShearY(__IntPtr __instance, float offsetShearY);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?isRelative@TransformConstraintData@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsRelative(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setRelative@TransformConstraintData@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRelative(__IntPtr __instance, bool isRelative);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?isLocal@TransformConstraintData@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsLocal(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setLocal@TransformConstraintData@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetLocal(__IntPtr __instance, bool isLocal);
            }

            internal static new TransformConstraintData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TransformConstraintData(native.ToPointer(), skipVTables);
            }

            internal static new TransformConstraintData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TransformConstraintData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new TransformConstraintData __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (TransformConstraintData)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static TransformConstraintData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TransformConstraintData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.TransformConstraintData.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private TransformConstraintData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TransformConstraintData(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public TransformConstraintData(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TransformConstraintData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TransformConstraintData");
            }

            public TransformConstraintData(global::spine_cpp.Spine.TransformConstraintData _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TransformConstraintData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TransformConstraintData");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.TransformConstraintData(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.TransformConstraintData(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_TransformConstraintData_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.BoneData> Bones
            {
                get
                {
                    var ___ret = __Internal.GetBones(__Instance);
                    var __result0 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.BoneData>.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.BoneData Target
            {
                get
                {
                    var ___ret = __Internal.GetTarget(__Instance);
                    var __result0 = global::spine_cpp.Spine.BoneData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetTarget(__Instance, __arg0);
                }
            }

            public float MixRotate
            {
                get
                {
                    var ___ret = __Internal.GetMixRotate(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixRotate(__Instance, value);
                }
            }

            public float MixX
            {
                get
                {
                    var ___ret = __Internal.GetMixX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixX(__Instance, value);
                }
            }

            public float MixY
            {
                get
                {
                    var ___ret = __Internal.GetMixY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixY(__Instance, value);
                }
            }

            public float MixScaleX
            {
                get
                {
                    var ___ret = __Internal.GetMixScaleX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixScaleX(__Instance, value);
                }
            }

            public float MixScaleY
            {
                get
                {
                    var ___ret = __Internal.GetMixScaleY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixScaleY(__Instance, value);
                }
            }

            public float MixShearY
            {
                get
                {
                    var ___ret = __Internal.GetMixShearY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixShearY(__Instance, value);
                }
            }

            public float OffsetRotation
            {
                get
                {
                    var ___ret = __Internal.GetOffsetRotation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOffsetRotation(__Instance, value);
                }
            }

            public float OffsetX
            {
                get
                {
                    var ___ret = __Internal.GetOffsetX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOffsetX(__Instance, value);
                }
            }

            public float OffsetY
            {
                get
                {
                    var ___ret = __Internal.GetOffsetY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOffsetY(__Instance, value);
                }
            }

            public float OffsetScaleX
            {
                get
                {
                    var ___ret = __Internal.GetOffsetScaleX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOffsetScaleX(__Instance, value);
                }
            }

            public float OffsetScaleY
            {
                get
                {
                    var ___ret = __Internal.GetOffsetScaleY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOffsetScaleY(__Instance, value);
                }
            }

            public float OffsetShearY
            {
                get
                {
                    var ___ret = __Internal.GetOffsetShearY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOffsetShearY(__Instance, value);
                }
            }

            public bool Relative
            {
                get
                {
                    var ___ret = __Internal.IsRelative(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetRelative(__Instance, value);
                }
            }

            public bool Local
            {
                get
                {
                    var ___ret = __Internal.IsLocal(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetLocal(__Instance, value);
                }
            }

            #region Virtual table interop

            // TransformConstraintData
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.TransformConstraintData.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TransformConstraintData.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class TransformConstraintTimeline : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _transformConstraintIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0TransformConstraintTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int transformConstraintIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0TransformConstraintTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setFrame@TransformConstraintTimeline@spine@@QEAAX_KMMMMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, ulong frameIndex, float time, float mixRotate, float mixX, float mixY, float mixScaleX, float mixScaleY, float mixShearY);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getTransformConstraintIndex@TransformConstraintTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetTransformConstraintIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setTransformConstraintIndex@TransformConstraintTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTransformConstraintIndex(__IntPtr __instance, int inValue);
            }

            internal static new TransformConstraintTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TransformConstraintTimeline(native.ToPointer(), skipVTables);
            }

            internal static new TransformConstraintTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TransformConstraintTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new TransformConstraintTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (TransformConstraintTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static TransformConstraintTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TransformConstraintTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.TransformConstraintTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private TransformConstraintTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TransformConstraintTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public TransformConstraintTimeline(ulong frameCount, ulong bezierCount, int transformConstraintIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TransformConstraintTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, transformConstraintIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TransformConstraintTimeline");
            }

            public TransformConstraintTimeline(global::spine_cpp.Spine.TransformConstraintTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TransformConstraintTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TransformConstraintTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Apply(global::spine_cpp.Spine.Skeleton skeleton, float lastTime, float time, global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event> pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var ___ApplyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection>(0, 2);
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var __arg3 = pEvents is null ? __IntPtr.Zero : pEvents.__Instance;
                ___ApplyDelegate(__Instance, __arg0, lastTime, time, __arg3, alpha, blend, direction);
            }

            public void SetFrame(ulong frameIndex, float time, float mixRotate, float mixX, float mixY, float mixScaleX, float mixScaleY, float mixShearY)
            {
                __Internal.SetFrame(__Instance, frameIndex, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.spine_cpp._rtti_TransformConstraintTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int TransformConstraintIndex
            {
                get
                {
                    var ___ret = __Internal.GetTransformConstraintIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetTransformConstraintIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // TransformConstraintTimeline
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.TransformConstraintTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TransformConstraintTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void apply(Skeleton &skeleton, float lastTime, float time, Vector<Event *> *pEvents, float alpha, MixBlend blend, MixDirection direction)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection _ApplyDelegateInstance;

            private static void _ApplyDelegateHook(__IntPtr __instance, __IntPtr skeleton, float lastTime, float time, __IntPtr pEvents, float alpha, global::spine_cpp.Spine.MixBlend blend, global::spine_cpp.Spine.MixDirection direction)
            {
                var __target = global::spine_cpp.Spine.TransformConstraintTimeline.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(skeleton, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Vector<global::spine_cpp.Spine.Event>.__GetOrCreateInstance(pEvents, false, skipVTables: true);
                __target.Apply(__result0, lastTime, time, __result3, alpha, blend, direction);
            }

            // Vector <PropertyId> &getPropertyIds()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetPropertyIdsDelegateInstance;

            private static __IntPtr _GetPropertyIdsDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TransformConstraintTimeline.__GetInstance(__instance);
                var ___ret = __target.PropertyIds;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.TransformConstraintTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _ApplyDelegateInstance += _ApplyDelegateHook;
                    _GetPropertyIdsDelegateInstance += _GetPropertyIdsDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ApplyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPropertyIdsDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class Vertices : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 72)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal global::spine_cpp.Spine.Vector.__Internal _vertices;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Vertices@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Vertices@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new Vertices __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Vertices(native.ToPointer(), skipVTables);
            }

            internal static new Vertices __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Vertices)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Vertices __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Vertices)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Vertices __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Vertices(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Vertices.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Vertices(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Vertices(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Vertices(global::spine_cpp.Spine.Vertices _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vertices.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Vertices");
            }

            public Vertices()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vertices.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Vertices");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::spine_cpp.Spine.Vector<int> Bones
            {
                get
                {
                    return global::spine_cpp.Spine.Vector<int>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_bones));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->_bones = *(global::spine_cpp.Spine.Vector.__Internal*) value.__Instance;
                }
            }

            public global::spine_cpp.Spine.Vector<float> _vertices
            {
                get
                {
                    return global::spine_cpp.Spine.Vector<float>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_vertices));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->_vertices = *(global::spine_cpp.Spine.Vector.__Internal*) value.__Instance;
                }
            }

            #region Virtual table interop

            // Vertices
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Vertices.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>
        /// <para>Controls how a timeline is mixed with the setup or current pose.</para>
        /// <para>See also Timeline::apply(Skeleton&amp;, float, float, Vector&amp;, float, Blend, MixDirection)</para>
        /// </summary>
        public enum MixBlend
        {
            MixBlendSetup = 0,
            MixBlendFirst = 1,
            MixBlendReplace = 2,
            MixBlendAdd = 3
        }
    }

    namespace Spine
    {
        /// <summary>
        /// <para>Indicates whether a timeline's alpha is mixing out over time toward 0 (the setup or current pose) or mixing in toward 1 (the timeline's pose).</para>
        /// <para>See also Timeline::apply(Skeleton&amp;, float, float, Vector&amp;, float, MixPose, MixDirection)</para>
        /// </summary>
        public enum MixDirection
        {
            MixDirectionIn = 0,
            MixDirectionOut = 1
        }
    }

    namespace Spine
    {
        [Flags]
        public enum Property
        {
            PropertyRotate = 1,
            PropertyX = 2,
            PropertyY = 4,
            PropertyScaleX = 8,
            PropertyScaleY = 16,
            PropertyShearX = 32,
            PropertyShearY = 64,
            PropertyRgb = 128,
            PropertyAlpha = 256,
            PropertyRgb2 = 512,
            PropertyAttachment = 1024,
            PropertyDeform = 2048,
            PropertyEvent = 4096,
            PropertyDrawOrder = 8192,
            PropertyIkConstraint = 16384,
            PropertyTransformConstraint = 32768,
            PropertyPathConstraintPosition = 65536,
            PropertyPathConstraintSpacing = 131072,
            PropertyPathConstraintMix = 262144,
            PropertySequence = 524288
        }
    }

    namespace Spine
    {
        public enum TransformMode
        {
            TransformModeNormal = 0,
            TransformModeOnlyTranslation = 1,
            TransformModeNoRotationOrReflection = 2,
            TransformModeNoScale = 3,
            TransformModeNoScaleOrReflection = 4
        }
    }

    namespace Spine
    {
        public enum BlendMode
        {
            BlendModeNormal = 0,
            BlendModeAdditive = 1,
            BlendModeMultiply = 2,
            BlendModeScreen = 3
        }
    }

    namespace Spine
    {
        public enum PositionMode
        {
            PositionModeFixed = 0,
            PositionModePercent = 1
        }
    }

    namespace Spine
    {
        public enum SpacingMode
        {
            SpacingModeLength = 0,
            SpacingModeFixed = 1,
            SpacingModePercent = 2,
            SpacingModeProportional = 3
        }
    }

    namespace Spine
    {
        public enum RotateMode
        {
            RotateModeTangent = 0,
            RotateModeChain = 1,
            RotateModeChainScale = 2
        }
    }

    namespace Spine
    {
        public enum AttachmentType
        {
            AttachmentTypeRegion = 0,
            AttachmentTypeBoundingbox = 1,
            AttachmentTypeMesh = 2,
            AttachmentTypeLinkedmesh = 3,
            AttachmentTypePath = 4,
            AttachmentTypePoint = 5,
            AttachmentTypeClipping = 6
        }
    }

    namespace Spine
    {
        public unsafe partial class UnitySpineCppTextureLoader : global::spine_cpp.Spine.TextureLoader, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr loadFuncPtr;
                internal __IntPtr unloadFuncPtr;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0UnitySpineCppTextureLoader@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0UnitySpineCppTextureLoader@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setLoadFuncPtr@UnitySpineCppTextureLoader@spine@@QEAAXPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetLoadFuncPtr(__IntPtr __instance, __IntPtr ptr);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?setUnloadFuncPtr@UnitySpineCppTextureLoader@spine@@QEAAXPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetUnloadFuncPtr(__IntPtr __instance, __IntPtr ptr);
            }

            internal static new UnitySpineCppTextureLoader __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new UnitySpineCppTextureLoader(native.ToPointer(), skipVTables);
            }

            internal static new UnitySpineCppTextureLoader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (UnitySpineCppTextureLoader)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new UnitySpineCppTextureLoader __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (UnitySpineCppTextureLoader)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static UnitySpineCppTextureLoader __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new UnitySpineCppTextureLoader(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.UnitySpineCppTextureLoader.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private UnitySpineCppTextureLoader(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected UnitySpineCppTextureLoader(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public UnitySpineCppTextureLoader()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.UnitySpineCppTextureLoader.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.UnitySpineCppTextureLoader");
            }

            public UnitySpineCppTextureLoader(global::spine_cpp.Spine.UnitySpineCppTextureLoader _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.UnitySpineCppTextureLoader.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.UnitySpineCppTextureLoader");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void SetLoadFuncPtr(__IntPtr ptr)
            {
                __Internal.SetLoadFuncPtr(__Instance, ptr);
            }

            public void SetUnloadFuncPtr(__IntPtr ptr)
            {
                __Internal.SetUnloadFuncPtr(__Instance, ptr);
            }

            public override void Load(global::spine_cpp.Spine.AtlasPage page, global::spine_cpp.Spine.String path)
            {
                var ___LoadDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 1);
                if (ReferenceEquals(page, null))
                    throw new global::System.ArgumentNullException("page", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = page.__Instance;
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = path.__Instance;
                ___LoadDelegate(__Instance, __arg0, __arg1);
            }

            public override void Unload(__IntPtr texture)
            {
                var ___UnloadDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr>(0, 2);
                ___UnloadDelegate(__Instance, texture);
            }

            public __IntPtr LoadFuncPtr
            {
                get
                {
                    return ((__Internal*)__Instance)->loadFuncPtr;
                }

                set
                {
                    ((__Internal*)__Instance)->loadFuncPtr = (__IntPtr) value;
                }
            }

            public __IntPtr UnloadFuncPtr
            {
                get
                {
                    return ((__Internal*)__Instance)->unloadFuncPtr;
                }

                set
                {
                    ((__Internal*)__Instance)->unloadFuncPtr = (__IntPtr) value;
                }
            }

            #region Virtual table interop

            // virtual ~UnitySpineCppTextureLoader()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.UnitySpineCppTextureLoader.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void load(spine::AtlasPage& page, const spine::String& path) override
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr___IntPtr _LoadDelegateInstance;

            private static void _LoadDelegateHook(__IntPtr __instance, __IntPtr page, __IntPtr path)
            {
                var __target = global::spine_cpp.Spine.UnitySpineCppTextureLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.AtlasPage.__GetOrCreateInstance(page, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(path, false, skipVTables: true);
                __target.Load(__result0, __result1);
            }

            // void unload(void* texture) override
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr _UnloadDelegateInstance;

            private static void _UnloadDelegateHook(__IntPtr __instance, __IntPtr texture)
            {
                var __target = global::spine_cpp.Spine.UnitySpineCppTextureLoader.__GetInstance(__instance);
                __target.Unload(texture);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _LoadDelegateInstance += _LoadDelegateHook;
                    _UnloadDelegateInstance += _UnloadDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_UnloadDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace SpineUnity
    {
        public unsafe partial class SpineMesh : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SpineMesh@SpineUnity@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.SpineUnity.SpineMesh> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.SpineUnity.SpineMesh>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.SpineUnity.SpineMesh managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.SpineUnity.SpineMesh managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static SpineMesh __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SpineMesh(native.ToPointer(), skipVTables);
            }

            internal static SpineMesh __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SpineMesh)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static SpineMesh __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SpineMesh(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private SpineMesh(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SpineMesh(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public SpineMesh()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.SpineUnity.SpineMesh.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public SpineMesh(global::spine_cpp.SpineUnity.SpineMesh _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.SpineUnity.SpineMesh.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::spine_cpp.SpineUnity.SpineMesh.__Internal*) __Instance) = *((global::spine_cpp.SpineUnity.SpineMesh.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        public unsafe partial class SubmeshInstruction : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 80)]
            public partial struct __Internal
            {
                internal global::Std.SharedPtr.__Internal skeleton;
                internal int startSlot;
                internal int endSlot;
//                internal global::spine_cpp.UnityEngine.Material.__Internal material; //comment by 'SpineCppGenBindings' program
                internal byte forceSeparate;
                internal int preActiveClippingSlotSource;
                internal int rawTriangleCount;
                internal int rawVertexCount;
                internal int rawFirstVertexIndex;
                internal byte hasClipping;
                internal byte hasPMAAdditiveSlot;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SubmeshInstruction@SpineUnity@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SubmeshInstruction@SpineUnity@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??1SubmeshInstruction@SpineUnity@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?SlotCount@SubmeshInstruction@SpineUnity@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int SlotCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?Default@SubmeshInstruction@SpineUnity@@SA?AU12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Default(__IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.SpineUnity.SubmeshInstruction> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.SpineUnity.SubmeshInstruction>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.SpineUnity.SubmeshInstruction managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.SpineUnity.SubmeshInstruction managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static SubmeshInstruction __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SubmeshInstruction(native.ToPointer(), skipVTables);
            }

            internal static SubmeshInstruction __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SubmeshInstruction)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static SubmeshInstruction __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SubmeshInstruction(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.SpineUnity.SubmeshInstruction.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private SubmeshInstruction(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SubmeshInstruction(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public SubmeshInstruction()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.SpineUnity.SubmeshInstruction.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public SubmeshInstruction(global::spine_cpp.SpineUnity.SubmeshInstruction _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.SpineUnity.SubmeshInstruction.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public int StartSlot
            {
                get
                {
                    return ((__Internal*)__Instance)->startSlot;
                }

                set
                {
                    ((__Internal*)__Instance)->startSlot = value;
                }
            }

            public int EndSlot
            {
                get
                {
                    return ((__Internal*)__Instance)->endSlot;
                }

                set
                {
                    ((__Internal*)__Instance)->endSlot = value;
                }
            }

            public bool ForceSeparate
            {
                get
                {
                    return ((__Internal*)__Instance)->forceSeparate != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->forceSeparate = (byte) (value ? 1 : 0);
                }
            }

            public int PreActiveClippingSlotSource
            {
                get
                {
                    return ((__Internal*)__Instance)->preActiveClippingSlotSource;
                }

                set
                {
                    ((__Internal*)__Instance)->preActiveClippingSlotSource = value;
                }
            }

            public int RawTriangleCount
            {
                get
                {
                    return ((__Internal*)__Instance)->rawTriangleCount;
                }

                set
                {
                    ((__Internal*)__Instance)->rawTriangleCount = value;
                }
            }

            public int RawVertexCount
            {
                get
                {
                    return ((__Internal*)__Instance)->rawVertexCount;
                }

                set
                {
                    ((__Internal*)__Instance)->rawVertexCount = value;
                }
            }

            public int RawFirstVertexIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->rawFirstVertexIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->rawFirstVertexIndex = value;
                }
            }

            public bool HasClipping
            {
                get
                {
                    return ((__Internal*)__Instance)->hasClipping != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->hasClipping = (byte) (value ? 1 : 0);
                }
            }

            public bool HasPMAAdditiveSlot
            {
                get
                {
                    return ((__Internal*)__Instance)->hasPMAAdditiveSlot != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->hasPMAAdditiveSlot = (byte) (value ? 1 : 0);
                }
            }

            public int SlotCount
            {
                get
                {
                    var ___ret = __Internal.SlotCount(__Instance);
                    return ___ret;
                }
            }

            public static global::spine_cpp.SpineUnity.SubmeshInstruction Default
            {
                get
                {
                    var ___ret = new global::spine_cpp.SpineUnity.SubmeshInstruction.__Internal();
                    __Internal.Default(new IntPtr(&___ret));
                    var _____ret = global::spine_cpp.SpineUnity.SubmeshInstruction.__CreateInstance(___ret);
                    global::spine_cpp.SpineUnity.SubmeshInstruction.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }
        }
    }

    namespace SpineUnity
    {
        public unsafe partial class SkeletonRendererInstruction : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public partial struct __Internal
            {
                internal global::Std.SharedPtr.__Internal submeshInstructions;
                internal byte immutableTriangles;
                internal byte hasActiveClipping;
                internal int rawVertexCount;
                internal global::Std.SharedPtr.__Internal attachments;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SkeletonRendererInstruction@SpineUnity@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SkeletonRendererInstruction@SpineUnity@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??1SkeletonRendererInstruction@SpineUnity@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?Clear@SkeletonRendererInstruction@SpineUnity@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clear(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?DoDispose@SkeletonRendererInstruction@SpineUnity@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DoDispose(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?SetWithSubset@SkeletonRendererInstruction@SpineUnity@@QEAAXAEAV?$Vector@USubmeshInstruction@SpineUnity@@@spine@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWithSubset(__IntPtr __instance, __IntPtr instructions, int startSubmesh, int endSubmesh);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?Set@SkeletonRendererInstruction@SpineUnity@@QEAAXAEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Set(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?GeometryNotEqual@SkeletonRendererInstruction@SpineUnity@@SA_NAEAV12@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GeometryNotEqual(__IntPtr a, __IntPtr b);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.SpineUnity.SkeletonRendererInstruction> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.SpineUnity.SkeletonRendererInstruction>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.SpineUnity.SkeletonRendererInstruction managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.SpineUnity.SkeletonRendererInstruction managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static SkeletonRendererInstruction __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SkeletonRendererInstruction(native.ToPointer(), skipVTables);
            }

            internal static SkeletonRendererInstruction __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SkeletonRendererInstruction)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static SkeletonRendererInstruction __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SkeletonRendererInstruction(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.SpineUnity.SkeletonRendererInstruction.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private SkeletonRendererInstruction(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SkeletonRendererInstruction(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public SkeletonRendererInstruction(global::spine_cpp.SpineUnity.SkeletonRendererInstruction _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.SpineUnity.SkeletonRendererInstruction.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public SkeletonRendererInstruction()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.SpineUnity.SkeletonRendererInstruction.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Clear()
            {
                __Internal.Clear(__Instance);
            }

            public void DoDispose()
            {
                __Internal.DoDispose(__Instance);
            }

            public void SetWithSubset(global::spine_cpp.Spine.Vector<global::spine_cpp.SpineUnity.SubmeshInstruction> instructions, int startSubmesh, int endSubmesh)
            {
                if (ReferenceEquals(instructions, null))
                    throw new global::System.ArgumentNullException("instructions", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = instructions.__Instance;
                __Internal.SetWithSubset(__Instance, __arg0, startSubmesh, endSubmesh);
            }

            public void Set(global::spine_cpp.SpineUnity.SkeletonRendererInstruction other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.Set(__Instance, __arg0);
            }

            public static bool GeometryNotEqual(global::spine_cpp.SpineUnity.SkeletonRendererInstruction a, global::spine_cpp.SpineUnity.SkeletonRendererInstruction b)
            {
                if (ReferenceEquals(a, null))
                    throw new global::System.ArgumentNullException("a", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = a.__Instance;
                if (ReferenceEquals(b, null))
                    throw new global::System.ArgumentNullException("b", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = b.__Instance;
                var ___ret = __Internal.GeometryNotEqual(__arg0, __arg1);
                return ___ret;
            }

            public bool ImmutableTriangles
            {
                get
                {
                    return ((__Internal*)__Instance)->immutableTriangles != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->immutableTriangles = (byte) (value ? 1 : 0);
                }
            }

            public bool HasActiveClipping
            {
                get
                {
                    return ((__Internal*)__Instance)->hasActiveClipping != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->hasActiveClipping = (byte) (value ? 1 : 0);
                }
            }

            public int RawVertexCount
            {
                get
                {
                    return ((__Internal*)__Instance)->rawVertexCount;
                }

                set
                {
                    ((__Internal*)__Instance)->rawVertexCount = value;
                }
            }
        }
    }

    namespace SpineUnity
    {
        public unsafe partial class SmartMesh : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 56)]
            public partial struct __Internal
            {
//                internal global::spine_cpp.UnityEngine.Mesh.__Internal mesh; //comment by 'SpineCppGenBindings' program
                internal global::Std.SharedPtr.__Internal instructionUsed;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SmartMesh@SpineUnity@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0SmartMesh@SpineUnity@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??1SmartMesh@SpineUnity@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?Clear@SmartMesh@SpineUnity@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clear(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?DoDispose@SmartMesh@SpineUnity@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DoDispose(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?GetMesh@SmartMesh@SpineUnity@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetMesh(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.SpineUnity.SmartMesh> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.SpineUnity.SmartMesh>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.SpineUnity.SmartMesh managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.SpineUnity.SmartMesh managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static SmartMesh __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SmartMesh(native.ToPointer(), skipVTables);
            }

            internal static SmartMesh __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SmartMesh)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static SmartMesh __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SmartMesh(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.SpineUnity.SmartMesh.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private SmartMesh(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SmartMesh(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public SmartMesh(global::spine_cpp.SpineUnity.SmartMesh _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.SpineUnity.SmartMesh.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public SmartMesh()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.SpineUnity.SmartMesh.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Clear()
            {
                __Internal.Clear(__Instance);
            }

            public void DoDispose()
            {
                __Internal.DoDispose(__Instance);
            }

            public int Mesh
            {
                get
                {
                    var ___ret = __Internal.GetMesh(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class MeshRendererBuffers : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 48)]
            public partial struct __Internal
            {
                internal global::Std.SharedPtr.__Internal doubleBufferedMesh;
                internal global::Std.SharedPtr.__Internal submeshMaterials;
                internal global::Std.SharedPtr.__Internal sharedMaterials;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0MeshRendererBuffers@SpineUnity@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0MeshRendererBuffers@SpineUnity@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??1MeshRendererBuffers@SpineUnity@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?Initialize@MeshRendererBuffers@SpineUnity@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Initialize(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?UpdateSharedMaterials@MeshRendererBuffers@SpineUnity@@QEAAXAEAV?$Vector@USubmeshInstruction@SpineUnity@@@spine@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateSharedMaterials(__IntPtr __instance, __IntPtr instructions);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?Clear@MeshRendererBuffers@SpineUnity@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clear(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?DoDispose@MeshRendererBuffers@SpineUnity@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DoDispose(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?GetUpdatedSharedMaterialsArray_Handles@MeshRendererBuffers@SpineUnity@@QEAA?AV?$Vector@H@spine@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetUpdatedSharedMaterialsArrayHandles(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?MaterialsChangedInLastUpdate@MeshRendererBuffers@SpineUnity@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool MaterialsChangedInLastUpdate(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?GetNextMesh_CSharp@MeshRendererBuffers@SpineUnity@@QEAAAEAVSmartMesh@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetNextMeshCSharp(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.SpineUnity.MeshRendererBuffers> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.SpineUnity.MeshRendererBuffers>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.SpineUnity.MeshRendererBuffers managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.SpineUnity.MeshRendererBuffers managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static MeshRendererBuffers __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new MeshRendererBuffers(native.ToPointer(), skipVTables);
            }

            internal static MeshRendererBuffers __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (MeshRendererBuffers)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static MeshRendererBuffers __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new MeshRendererBuffers(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.SpineUnity.MeshRendererBuffers.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private MeshRendererBuffers(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected MeshRendererBuffers(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public MeshRendererBuffers(global::spine_cpp.SpineUnity.MeshRendererBuffers _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.SpineUnity.MeshRendererBuffers.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public MeshRendererBuffers()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.SpineUnity.MeshRendererBuffers.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Initialize()
            {
                __Internal.Initialize(__Instance);
            }

            public void UpdateSharedMaterials(global::spine_cpp.Spine.Vector<global::spine_cpp.SpineUnity.SubmeshInstruction> instructions)
            {
                if (ReferenceEquals(instructions, null))
                    throw new global::System.ArgumentNullException("instructions", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = instructions.__Instance;
                __Internal.UpdateSharedMaterials(__Instance, __arg0);
            }

            public void Clear()
            {
                __Internal.Clear(__Instance);
            }

            public void DoDispose()
            {
                __Internal.DoDispose(__Instance);
            }

            public global::spine_cpp.Spine.Vector<int> UpdatedSharedMaterialsArrayHandles
            {
                get
                {
                    var ___ret = new global::spine_cpp.Spine.Vector.__Internal();
                    __Internal.GetUpdatedSharedMaterialsArrayHandles(__Instance, new IntPtr(&___ret));
                    var _____ret = global::spine_cpp.Spine.Vector<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::spine_cpp.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            public bool MaterialsChangedInLastUpdate
            {
                get
                {
                    var ___ret = __Internal.MaterialsChangedInLastUpdate(__Instance);
                    return ___ret;
                }
            }

            public global::spine_cpp.SpineUnity.SmartMesh NextMeshCSharp
            {
                get
                {
                    var ___ret = __Internal.GetNextMeshCSharp(__Instance);
                    var __result0 = global::spine_cpp.SpineUnity.SmartMesh.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }
    }

    namespace SpineUnity
    {
        namespace DoubleBuffered
        {
            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public unsafe partial struct __Internalc__N_SpineUnity_S_DoubleBuffered____N_SpineUnity_S_SmartMesh
            {
                internal global::Std.SharedPtr.__Internal a;
                internal global::Std.SharedPtr.__Internal b;
                internal byte usingA;
            }
        }
    }

    namespace SpineUnity
    {
        public unsafe partial class MeshGenerator : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 240)]
            public partial struct __Internal
            {
                internal float BoundsMinDefault;
                internal float BoundsMaxDefault;
                internal global::Std.SharedPtr.__Internal vertexBuffer;
                internal global::Std.SharedPtr.__Internal uvBuffer;
                internal global::Std.SharedPtr.__Internal colorBuffer;
                internal global::Std.SharedPtr.__Internal submeshes;
//                internal global::spine_cpp.UnityEngine.Vector2.__Internal meshBoundsMin; //comment by 'SpineCppGenBindings' program
//                internal global::spine_cpp.UnityEngine.Vector2.__Internal meshBoundsMax; //comment by 'SpineCppGenBindings' program
                internal float meshBoundsThickness;
                internal int submeshIndex;
                internal global::Std.SharedPtr.__Internal clipper;
                internal global::Std.SharedPtr.__Internal tempVerts;
                internal global::Std.SharedPtr.__Internal regionTriangles;
                internal global::Std.SharedPtr.__Internal normals;
                internal global::Std.SharedPtr.__Internal tangents;
                internal global::Std.SharedPtr.__Internal tempTanBuffer;
                internal global::Std.SharedPtr.__Internal uv2;
                internal global::Std.SharedPtr.__Internal uv3;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0MeshGenerator@SpineUnity@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??1MeshGenerator@SpineUnity@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?SubmeshIndexCount@MeshGenerator@SpineUnity@@QEAAHH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int SubmeshIndexCount(__IntPtr __instance, int submeshIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?GenerateSingleSubmeshInstruction@MeshGenerator@SpineUnity@@SAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GenerateSingleSubmeshInstruction();

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?VertexCount@MeshGenerator@SpineUnity@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int VertexCount(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.SpineUnity.MeshGenerator> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.SpineUnity.MeshGenerator>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.SpineUnity.MeshGenerator managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.SpineUnity.MeshGenerator managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static MeshGenerator __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new MeshGenerator(native.ToPointer(), skipVTables);
            }

            internal static MeshGenerator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (MeshGenerator)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static MeshGenerator __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new MeshGenerator(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private MeshGenerator(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected MeshGenerator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public MeshGenerator()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.SpineUnity.MeshGenerator.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public int SubmeshIndexCount(int submeshIndex)
            {
                var ___ret = __Internal.SubmeshIndexCount(__Instance, submeshIndex);
                return ___ret;
            }

            public static void GenerateSingleSubmeshInstruction()
            {
                __Internal.GenerateSingleSubmeshInstruction();
            }

            public float BoundsMinDefault
            {
                get
                {
                    return ((__Internal*)__Instance)->BoundsMinDefault;
                }
            }

            public float BoundsMaxDefault
            {
                get
                {
                    return ((__Internal*)__Instance)->BoundsMaxDefault;
                }
            }

            public int VertexCount
            {
                get
                {
                    var ___ret = __Internal.VertexCount(__Instance);
                    return ___ret;
                }
            }
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int(__IntPtr __instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_ulong_string8_int(__IntPtr __instance, ulong arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2, int arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr___IntPtr_ulong_string8_int(__IntPtr __instance, __IntPtr arg1, ulong arg2, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg3, int arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_string8_int(__IntPtr __instance, __IntPtr arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2, int arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate sbyte* Func_sbytePtr___IntPtr___IntPtr_intPtr(__IntPtr __instance, __IntPtr arg1, int* arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_float_float___IntPtr_float_spine_cpp_spine_MixBlend_spine_cpp_spine_MixDirection(__IntPtr __instance, __IntPtr arg1, float arg2, float arg3, __IntPtr arg4, float arg5, global::spine_cpp.Spine.MixBlend arg6, global::spine_cpp.Spine.MixDirection arg7);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate int Func_int___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_bool(__IntPtr __instance, [MarshalAs(UnmanagedType.I1)] bool arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_spine_cpp_spine_EventType___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, global::spine_cpp.Spine.EventType arg2, __IntPtr arg3, __IntPtr arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_ulong_ulong_floatPtr_ulong_ulong(__IntPtr __instance, __IntPtr arg1, ulong arg2, ulong arg3, float* arg4, ulong arg5, ulong arg6);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2, __IntPtr arg3, __IntPtr arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_ulong_ulong___IntPtr_ulong_ulong(__IntPtr __instance, __IntPtr arg1, ulong arg2, ulong arg3, __IntPtr arg4, ulong arg5, ulong arg6);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float(__IntPtr __instance, ulong arg1, ulong arg2, float arg3, float arg4, float arg5, float arg6, float arg7, float arg8, float arg9, float arg10, float arg11);
    }
}
namespace spine_cpp.__Symbols
{
    internal class spine_cpp
    {
        public static IntPtr _rtti_AttachmentLoader_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_AtlasAttachmentLoader_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_Attachment_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_Timeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_AttachmentTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_Updatable_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_Bone_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_VertexAttachment_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_BoundingBoxAttachment_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_ClippingAttachment_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_CurveTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_CurveTimeline1_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_CurveTimeline2_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_RGBATimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_RGBTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_AlphaTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_RGBA2Timeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_RGB2Timeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_ConstraintData_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_DeformTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_DrawOrderTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_EventTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_IkConstraint_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_IkConstraintData_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_IkConstraintTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _JSON_FALSE_Json_spine__2HB { get; }
        public static IntPtr _JSON_TRUE_Json_spine__2HB { get; }
        public static IntPtr _JSON_NULL_Json_spine__2HB { get; }
        public static IntPtr _JSON_NUMBER_Json_spine__2HB { get; }
        public static IntPtr _JSON_STRING_Json_spine__2HB { get; }
        public static IntPtr _JSON_ARRAY_Json_spine__2HB { get; }
        public static IntPtr _JSON_OBJECT_Json_spine__2HB { get; }
        public static IntPtr _rtti_MeshAttachment_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_PathAttachment_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_PathConstraint_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_PathConstraintData_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_PathConstraintMixTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_PathConstraintPositionTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _ENTRIES_PathConstraintPositionTimeline_spine__2HB { get; }
        public static IntPtr _rtti_PathConstraintSpacingTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_PointAttachment_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_RegionAttachment_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_RotateTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_TranslateTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_TranslateXTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_TranslateYTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_ScaleTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_ScaleXTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_ScaleYTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_ShearTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_ShearXTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_ShearYTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_TransformConstraint_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_TransformConstraintData_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_TransformConstraintTimeline_spine__2VRTTI_2_B { get; }
        static spine_cpp()
        {
            var path = "spine_cpp";
            var image = CppSharp.SymbolResolver.LoadImage(ref path);
            if (image == IntPtr.Zero) throw new global::System.DllNotFoundException(path);
            _rtti_AttachmentLoader_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@AttachmentLoader@spine@@2VRTTI@2@B");
            _rtti_AtlasAttachmentLoader_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@AtlasAttachmentLoader@spine@@2VRTTI@2@B");
            _rtti_Attachment_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@Attachment@spine@@2VRTTI@2@B");
            _rtti_Timeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@Timeline@spine@@2VRTTI@2@B");
            _rtti_AttachmentTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@AttachmentTimeline@spine@@2VRTTI@2@B");
            _rtti_Updatable_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@Updatable@spine@@2VRTTI@2@B");
            _rtti_Bone_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@Bone@spine@@2VRTTI@2@B");
            _rtti_VertexAttachment_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@VertexAttachment@spine@@2VRTTI@2@B");
            _rtti_BoundingBoxAttachment_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@BoundingBoxAttachment@spine@@2VRTTI@2@B");
            _rtti_ClippingAttachment_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@ClippingAttachment@spine@@2VRTTI@2@B");
            _rtti_CurveTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@CurveTimeline@spine@@2VRTTI@2@B");
            _rtti_CurveTimeline1_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@CurveTimeline1@spine@@2VRTTI@2@B");
            _rtti_CurveTimeline2_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@CurveTimeline2@spine@@2VRTTI@2@B");
            _rtti_RGBATimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@RGBATimeline@spine@@2VRTTI@2@B");
            _rtti_RGBTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@RGBTimeline@spine@@2VRTTI@2@B");
            _rtti_AlphaTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@AlphaTimeline@spine@@2VRTTI@2@B");
            _rtti_RGBA2Timeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@RGBA2Timeline@spine@@2VRTTI@2@B");
            _rtti_RGB2Timeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@RGB2Timeline@spine@@2VRTTI@2@B");
            _rtti_ConstraintData_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@ConstraintData@spine@@2VRTTI@2@B");
            _rtti_DeformTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@DeformTimeline@spine@@2VRTTI@2@B");
            _rtti_DrawOrderTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@DrawOrderTimeline@spine@@2VRTTI@2@B");
            _rtti_EventTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@EventTimeline@spine@@2VRTTI@2@B");
            _rtti_IkConstraint_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@IkConstraint@spine@@2VRTTI@2@B");
            _rtti_IkConstraintData_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@IkConstraintData@spine@@2VRTTI@2@B");
            _rtti_IkConstraintTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@IkConstraintTimeline@spine@@2VRTTI@2@B");
            _JSON_FALSE_Json_spine__2HB = CppSharp.SymbolResolver.ResolveSymbol(image, "?JSON_FALSE@Json@spine@@2HB");
            _JSON_TRUE_Json_spine__2HB = CppSharp.SymbolResolver.ResolveSymbol(image, "?JSON_TRUE@Json@spine@@2HB");
            _JSON_NULL_Json_spine__2HB = CppSharp.SymbolResolver.ResolveSymbol(image, "?JSON_NULL@Json@spine@@2HB");
            _JSON_NUMBER_Json_spine__2HB = CppSharp.SymbolResolver.ResolveSymbol(image, "?JSON_NUMBER@Json@spine@@2HB");
            _JSON_STRING_Json_spine__2HB = CppSharp.SymbolResolver.ResolveSymbol(image, "?JSON_STRING@Json@spine@@2HB");
            _JSON_ARRAY_Json_spine__2HB = CppSharp.SymbolResolver.ResolveSymbol(image, "?JSON_ARRAY@Json@spine@@2HB");
            _JSON_OBJECT_Json_spine__2HB = CppSharp.SymbolResolver.ResolveSymbol(image, "?JSON_OBJECT@Json@spine@@2HB");
            _rtti_MeshAttachment_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@MeshAttachment@spine@@2VRTTI@2@B");
            _rtti_PathAttachment_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@PathAttachment@spine@@2VRTTI@2@B");
            _rtti_PathConstraint_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@PathConstraint@spine@@2VRTTI@2@B");
            _rtti_PathConstraintData_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@PathConstraintData@spine@@2VRTTI@2@B");
            _rtti_PathConstraintMixTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@PathConstraintMixTimeline@spine@@2VRTTI@2@B");
            _rtti_PathConstraintPositionTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@PathConstraintPositionTimeline@spine@@2VRTTI@2@B");
            _ENTRIES_PathConstraintPositionTimeline_spine__2HB = CppSharp.SymbolResolver.ResolveSymbol(image, "?ENTRIES@PathConstraintPositionTimeline@spine@@2HB");
            _rtti_PathConstraintSpacingTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@PathConstraintSpacingTimeline@spine@@2VRTTI@2@B");
            _rtti_PointAttachment_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@PointAttachment@spine@@2VRTTI@2@B");
            _rtti_RegionAttachment_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@RegionAttachment@spine@@2VRTTI@2@B");
            _rtti_RotateTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@RotateTimeline@spine@@2VRTTI@2@B");
            _rtti_TranslateTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@TranslateTimeline@spine@@2VRTTI@2@B");
            _rtti_TranslateXTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@TranslateXTimeline@spine@@2VRTTI@2@B");
            _rtti_TranslateYTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@TranslateYTimeline@spine@@2VRTTI@2@B");
            _rtti_ScaleTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@ScaleTimeline@spine@@2VRTTI@2@B");
            _rtti_ScaleXTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@ScaleXTimeline@spine@@2VRTTI@2@B");
            _rtti_ScaleYTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@ScaleYTimeline@spine@@2VRTTI@2@B");
            _rtti_ShearTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@ShearTimeline@spine@@2VRTTI@2@B");
            _rtti_ShearXTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@ShearXTimeline@spine@@2VRTTI@2@B");
            _rtti_ShearYTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@ShearYTimeline@spine@@2VRTTI@2@B");
            _rtti_TransformConstraint_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@TransformConstraint@spine@@2VRTTI@2@B");
            _rtti_TransformConstraintData_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@TransformConstraintData@spine@@2VRTTI@2@B");
            _rtti_TransformConstraintTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@TransformConstraintTimeline@spine@@2VRTTI@2@B");
        }
    }
}

