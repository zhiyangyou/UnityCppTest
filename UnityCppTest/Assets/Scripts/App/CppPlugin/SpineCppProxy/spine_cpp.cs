// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace spine_cpp
{
    namespace Spine
    {
        public unsafe abstract partial class SpineExtension : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_SpineExtension;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0SpineExtension@spine@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0SpineExtension@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?readFile@SpineExtension@spine@@SAPEADAEBVString@2@PEAH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern sbyte* ReadFile(__IntPtr path, int* length);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getInstance@SpineExtension@spine@@SAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetInstance();

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setInstance@SpineExtension@spine@@SAXPEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetInstance(__IntPtr inSpineExtension);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.SpineExtension> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.SpineExtension>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.Spine.SpineExtension managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.Spine.SpineExtension managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static SpineExtension __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SpineExtensionInternal(native.ToPointer(), skipVTables);
            }

            internal static SpineExtension __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SpineExtension)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static SpineExtension __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (SpineExtension)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static SpineExtension __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SpineExtensionInternal(native, skipVTables);
            }

            protected SpineExtension(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected SpineExtension()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SpineExtension.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SpineExtension");
            }

            protected SpineExtension(global::spine_cpp.Spine.SpineExtension _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SpineExtension.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SpineExtension");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Implement this function to use your own memory allocator</summary>
            public abstract __IntPtr Alloc(ulong size, string file, int line);

            public abstract __IntPtr Calloc(ulong size, string file, int line);

            public abstract __IntPtr Realloc(__IntPtr ptr, ulong size, string file, int line);

            /// <summary>If you provide a spineAllocFunc, you should also provide a spineFreeFunc</summary>
            public abstract void Free(__IntPtr mem, string file, int line);

            public abstract sbyte* _readFile(global::spine_cpp.Spine.String path, ref int length);

            public virtual void BeforeFree(__IntPtr ptr)
            {
                var ___BeforeFreeDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr>(0, 6);
                ___BeforeFreeDelegate(__Instance, ptr);
            }

            public static sbyte* ReadFile(global::spine_cpp.Spine.String path, ref int length)
            {
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = path.__Instance;
                fixed (int* __length1 = &length)
                {
                    var __arg1 = __length1;
                    var ___ret = __Internal.ReadFile(__arg0, __arg1);
                    return ___ret;
                }
            }

            public static global::spine_cpp.Spine.SpineExtension instance
            {
                get
                {
                    var ___ret = __Internal.GetInstance();
                    var __result0 = global::spine_cpp.Spine.SpineExtension.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetInstance(__arg0);
                }
            }

            #region Virtual table interop

            // virtual ~SpineExtension()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.SpineExtension.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void *_alloc(size_t size, const char *file, int line) = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr_ulong_string8_int _AllocDelegateInstance;

            private static __IntPtr _AllocDelegateHook(__IntPtr __instance, ulong size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line)
            {
                var __target = global::spine_cpp.Spine.SpineExtension.__GetInstance(__instance);
                var ___ret = __target.Alloc(size, file, line);
                return ___ret;
            }

            // void *_calloc(size_t size, const char *file, int line) = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr_ulong_string8_int _CallocDelegateInstance;

            private static __IntPtr _CallocDelegateHook(__IntPtr __instance, ulong size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line)
            {
                var __target = global::spine_cpp.Spine.SpineExtension.__GetInstance(__instance);
                var ___ret = __target.Calloc(size, file, line);
                return ___ret;
            }

            // void *_realloc(void *ptr, size_t size, const char *file, int line) = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr_ulong_string8_int _ReallocDelegateInstance;

            private static __IntPtr _ReallocDelegateHook(__IntPtr __instance, __IntPtr ptr, ulong size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line)
            {
                var __target = global::spine_cpp.Spine.SpineExtension.__GetInstance(__instance);
                var ___ret = __target.Realloc(ptr, size, file, line);
                return ___ret;
            }

            // void _free(void *mem, const char *file, int line) = 0
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_string8_int _FreeDelegateInstance;

            private static void _FreeDelegateHook(__IntPtr __instance, __IntPtr mem, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line)
            {
                var __target = global::spine_cpp.Spine.SpineExtension.__GetInstance(__instance);
                __target.Free(mem, file, line);
            }

            // char *_readFile(const String &path, int *length) = 0
            private static global::spine_cpp.Delegates.Func_sbytePtr___IntPtr___IntPtr_intPtr __readFileDelegateInstance;

            private static sbyte* __readFileDelegateHook(__IntPtr __instance, __IntPtr path, int* length)
            {
                var __target = global::spine_cpp.Spine.SpineExtension.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(path, false, skipVTables: true);
                var ___ret = __target._readFile(__result0, ref *length);
                return ___ret;
            }

            // void _beforeFree(void *ptr)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr _BeforeFreeDelegateInstance;

            private static void _BeforeFreeDelegateHook(__IntPtr __instance, __IntPtr ptr)
            {
                var __target = global::spine_cpp.Spine.SpineExtension.__GetInstance(__instance);
                __target.BeforeFree(ptr);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[7];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _AllocDelegateInstance += _AllocDelegateHook;
                    _CallocDelegateInstance += _CallocDelegateHook;
                    _ReallocDelegateInstance += _ReallocDelegateHook;
                    _FreeDelegateInstance += _FreeDelegateHook;
                    __readFileDelegateInstance += __readFileDelegateHook;
                    _BeforeFreeDelegateInstance += _BeforeFreeDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AllocDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CallocDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ReallocDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_FreeDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(__readFileDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_BeforeFreeDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 7, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 7, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                VTables.Methods[0] = new Delegate[7];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class DefaultSpineExtension : global::spine_cpp.Spine.SpineExtension, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineExtension;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0DefaultSpineExtension@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0DefaultSpineExtension@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new DefaultSpineExtension __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new DefaultSpineExtension(native.ToPointer(), skipVTables);
            }

            internal static new DefaultSpineExtension __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (DefaultSpineExtension)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new DefaultSpineExtension __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (DefaultSpineExtension)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static DefaultSpineExtension __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new DefaultSpineExtension(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.DefaultSpineExtension.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private DefaultSpineExtension(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected DefaultSpineExtension(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public DefaultSpineExtension()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.DefaultSpineExtension.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.DefaultSpineExtension");
            }

            public DefaultSpineExtension(global::spine_cpp.Spine.DefaultSpineExtension _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.DefaultSpineExtension.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.DefaultSpineExtension");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override __IntPtr Alloc(ulong size, string file, int line)
            {
                var ___AllocDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr_ulong_string8_int>(0, 1);
                var ___ret = ___AllocDelegate(__Instance, size, file, line);
                return ___ret;
            }

            public override __IntPtr Calloc(ulong size, string file, int line)
            {
                var ___CallocDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr_ulong_string8_int>(0, 2);
                var ___ret = ___CallocDelegate(__Instance, size, file, line);
                return ___ret;
            }

            public override __IntPtr Realloc(__IntPtr ptr, ulong size, string file, int line)
            {
                var ___ReallocDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr_ulong_string8_int>(0, 3);
                var ___ret = ___ReallocDelegate(__Instance, ptr, size, file, line);
                return ___ret;
            }

            public override void Free(__IntPtr mem, string file, int line)
            {
                var ___FreeDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_string8_int>(0, 4);
                ___FreeDelegate(__Instance, mem, file, line);
            }

            public override sbyte* _readFile(global::spine_cpp.Spine.String path, ref int length)
            {
                var ____readFileDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_sbytePtr___IntPtr___IntPtr_intPtr>(0, 5);
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = path.__Instance;
                fixed (int* __length1 = &length)
                {
                    var __arg1 = __length1;
                    var ___ret = ____readFileDelegate(__Instance, __arg0, __arg1);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // virtual ~DefaultSpineExtension()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.DefaultSpineExtension.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void *_alloc(size_t size, const char *file, int line) override
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr_ulong_string8_int _AllocDelegateInstance;

            private static __IntPtr _AllocDelegateHook(__IntPtr __instance, ulong size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line)
            {
                var __target = global::spine_cpp.Spine.DefaultSpineExtension.__GetInstance(__instance);
                var ___ret = __target.Alloc(size, file, line);
                return ___ret;
            }

            // void *_calloc(size_t size, const char *file, int line) override
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr_ulong_string8_int _CallocDelegateInstance;

            private static __IntPtr _CallocDelegateHook(__IntPtr __instance, ulong size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line)
            {
                var __target = global::spine_cpp.Spine.DefaultSpineExtension.__GetInstance(__instance);
                var ___ret = __target.Calloc(size, file, line);
                return ___ret;
            }

            // void *_realloc(void *ptr, size_t size, const char *file, int line) override
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr_ulong_string8_int _ReallocDelegateInstance;

            private static __IntPtr _ReallocDelegateHook(__IntPtr __instance, __IntPtr ptr, ulong size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line)
            {
                var __target = global::spine_cpp.Spine.DefaultSpineExtension.__GetInstance(__instance);
                var ___ret = __target.Realloc(ptr, size, file, line);
                return ___ret;
            }

            // void _free(void *mem, const char *file, int line) override
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_string8_int _FreeDelegateInstance;

            private static void _FreeDelegateHook(__IntPtr __instance, __IntPtr mem, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line)
            {
                var __target = global::spine_cpp.Spine.DefaultSpineExtension.__GetInstance(__instance);
                __target.Free(mem, file, line);
            }

            // char *_readFile(const String &path, int *length) override
            private static global::spine_cpp.Delegates.Func_sbytePtr___IntPtr___IntPtr_intPtr __readFileDelegateInstance;

            private static sbyte* __readFileDelegateHook(__IntPtr __instance, __IntPtr path, int* length)
            {
                var __target = global::spine_cpp.Spine.DefaultSpineExtension.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(path, false, skipVTables: true);
                var ___ret = __target._readFile(__result0, ref *length);
                return ___ret;
            }

            // void _beforeFree(void *ptr)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr _BeforeFreeDelegateInstance;

            private static void _BeforeFreeDelegateHook(__IntPtr __instance, __IntPtr ptr)
            {
                var __target = global::spine_cpp.Spine.DefaultSpineExtension.__GetInstance(__instance);
                __target.BeforeFree(ptr);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[7];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _AllocDelegateInstance += _AllocDelegateHook;
                    _CallocDelegateInstance += _CallocDelegateHook;
                    _ReallocDelegateInstance += _ReallocDelegateHook;
                    _FreeDelegateInstance += _FreeDelegateHook;
                    __readFileDelegateInstance += __readFileDelegateHook;
                    _BeforeFreeDelegateInstance += _BeforeFreeDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AllocDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CallocDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ReallocDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_FreeDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(__readFileDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_BeforeFreeDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 7, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 7, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                VTables.Methods[0] = new Delegate[7];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class SpineExtensionInternal : global::spine_cpp.Spine.SpineExtension, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal SpineExtensionInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal SpineExtensionInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Implement this function to use your own memory allocator</summary>
            public override __IntPtr Alloc(ulong size, string file, int line)
            {
                var ___AllocDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr_ulong_string8_int>(0, 1);
                var ___ret = ___AllocDelegate(__Instance, size, file, line);
                return ___ret;
            }

            public override __IntPtr Calloc(ulong size, string file, int line)
            {
                var ___CallocDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr_ulong_string8_int>(0, 2);
                var ___ret = ___CallocDelegate(__Instance, size, file, line);
                return ___ret;
            }

            public override __IntPtr Realloc(__IntPtr ptr, ulong size, string file, int line)
            {
                var ___ReallocDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr_ulong_string8_int>(0, 3);
                var ___ret = ___ReallocDelegate(__Instance, ptr, size, file, line);
                return ___ret;
            }

            /// <summary>If you provide a spineAllocFunc, you should also provide a spineFreeFunc</summary>
            public override void Free(__IntPtr mem, string file, int line)
            {
                var ___FreeDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_string8_int>(0, 4);
                ___FreeDelegate(__Instance, mem, file, line);
            }

            public override sbyte* _readFile(global::spine_cpp.Spine.String path, ref int length)
            {
                var ____readFileDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_sbytePtr___IntPtr___IntPtr_intPtr>(0, 5);
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = path.__Instance;
                fixed (int* __length1 = &length)
                {
                    var __arg1 = __length1;
                    var ___ret = ____readFileDelegate(__Instance, __arg0, __arg1);
                    return ___ret;
                }
            }
        }

        public unsafe partial class Extension
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getDefaultExtension@spine@@YAPEAVSpineExtension@1@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDefaultExtension();
            }

            public static global::spine_cpp.Spine.SpineExtension GetDefaultExtension()
            {
                var ___ret = __Internal.GetDefaultExtension();
                var __result0 = global::spine_cpp.Spine.SpineExtension.__GetOrCreateInstance(___ret, true);
                return __result0;
            }
        }
    }

    namespace Spine
    {
        public unsafe partial class SpineObject : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0SpineObject@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0SpineObject@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.SpineObject> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.SpineObject>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.Spine.SpineObject managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.Spine.SpineObject managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static SpineObject __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SpineObject(native.ToPointer(), skipVTables);
            }

            internal static SpineObject __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SpineObject)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static SpineObject __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (SpineObject)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static SpineObject __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SpineObject(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.SpineObject.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private SpineObject(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SpineObject(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            public SpineObject()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SpineObject.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SpineObject");
            }

            public SpineObject(global::spine_cpp.Spine.SpineObject _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SpineObject.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SpineObject");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // virtual ~SpineObject()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.SpineObject.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class String : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal ulong _length;
                internal __IntPtr _buffer;
                internal byte _tempowner;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0String@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0String@spine@@QEAA@PEBD_N1@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string chars, bool own, bool tofree);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0String@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?own@String@spine@@QEAAXAEBV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Own(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?own@String@spine@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Own(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string chars);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?unown@String@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Unown(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?append@String@spine@@QEAAAEAV12@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Append(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string chars);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?append@String@spine@@QEAAAEAV12@AEBV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Append(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?append@String@spine@@QEAAAEAV12@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Append_1(__IntPtr __instance, int other);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?append@String@spine@@QEAAAEAV12@M@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Append_2(__IntPtr __instance, float other);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?startsWith@String@spine@@QEAA_NAEBV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool StartsWith(__IntPtr __instance, __IntPtr needle);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??8spine@@YA_NAEBVString@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr a, __IntPtr b);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??9spine@@YA_NAEBVString@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr a, __IntPtr b);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?length@String@spine@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Length(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?isEmpty@String@spine@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsEmpty(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?buffer@String@spine@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Buffer(__IntPtr __instance);
            }

            internal static new String __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new String(native.ToPointer(), skipVTables);
            }

            internal static new String __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (String)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new String __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (String)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static String __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new String(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.String.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private String(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected String(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public String()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.String.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.String");
            }

            public String(string chars, bool own, bool tofree)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.String.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, chars, own, tofree);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.String");
            }

            public String(global::spine_cpp.Spine.String other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.String.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.String");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Own(global::spine_cpp.Spine.String other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.Own(__Instance, __arg0);
            }

            public void Own(string chars)
            {
                __Internal.Own(__Instance, chars);
            }

            public void Unown()
            {
                __Internal.Unown(__Instance);
            }

            public global::spine_cpp.Spine.String Append(string chars)
            {
                var ___ret = __Internal.Append(__Instance, chars);
                var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.String Append(global::spine_cpp.Spine.String other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = __Internal.Append(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.String Append(int other)
            {
                var ___ret = __Internal.Append_1(__Instance, other);
                var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.String Append(float other)
            {
                var ___ret = __Internal.Append_2(__Instance, other);
                var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public bool StartsWith(global::spine_cpp.Spine.String needle)
            {
                if (ReferenceEquals(needle, null))
                    throw new global::System.ArgumentNullException("needle", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = needle.__Instance;
                var ___ret = __Internal.StartsWith(__Instance, __arg0);
                return ___ret;
            }

            public static bool operator ==(global::spine_cpp.Spine.String a, global::spine_cpp.Spine.String b)
            {
                bool aNull = ReferenceEquals(a, null);
                bool bNull = ReferenceEquals(b, null);
                if (aNull || bNull)
                    return aNull && bNull;
                var __arg0 = a.__Instance;
                var __arg1 = b.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::spine_cpp.Spine.String;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::spine_cpp.Spine.String.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::spine_cpp.Spine.String a, global::spine_cpp.Spine.String b)
            {
                bool aNull = ReferenceEquals(a, null);
                bool bNull = ReferenceEquals(b, null);
                if (aNull || bNull)
                    return !(aNull && bNull);
                var __arg0 = a.__Instance;
                var __arg1 = b.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public ulong Length
            {
                get
                {
                    var ___ret = __Internal.Length(__Instance);
                    return ___ret;
                }
            }

            public bool IsEmpty
            {
                get
                {
                    var ___ret = __Internal.IsEmpty(__Instance);
                    return ___ret;
                }
            }

            public string Buffer
            {
                get
                {
                    var ___ret = __Internal.Buffer(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            #region Virtual table interop

            // ~String()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.String.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        namespace Vector
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public unsafe partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal ulong _size;
                internal ulong _capacity;
                internal __IntPtr _buffer;
            }
        }
    }

    namespace Spine
    {
        namespace HashMap
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public unsafe partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _head;
                internal ulong _size;
            }

            namespace Entry
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public unsafe partial struct __Internalc__N_spine_S_HashMap__K_b
                {
                    internal __IntPtr vfptr_SpineObject;
                    internal long _key;
                    internal byte _value;
                    internal __IntPtr next;
                    internal __IntPtr prev;
                }

                [StructLayout(LayoutKind.Sequential, Size = 56)]
                public unsafe partial struct __Internalc__N_spine_S_HashMap____N_spine_S_AnimationStateData_S_AnimationPair_f
                {
                    internal __IntPtr vfptr_SpineObject;
                    internal global::spine_cpp.Spine.AnimationStateData.AnimationPair.__Internal _key;
                    internal float _value;
                    internal __IntPtr next;
                    internal __IntPtr prev;
                }
            }

        }
    }

    namespace Spine
    {
        public unsafe partial class Animation : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 104)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _timelines;
                internal global::spine_cpp.Spine.HashMap.__Internal _timelineIds;
                internal float _duration;
                internal global::spine_cpp.Spine.String.__Internal _name;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Animation@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getName@Animation@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getDuration@Animation@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetDuration(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setDuration@Animation@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDuration(__IntPtr __instance, float inValue);
            }

            internal static new Animation __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Animation(native.ToPointer(), skipVTables);
            }

            internal static new Animation __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Animation)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Animation __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Animation)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Animation __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Animation(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Animation.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Animation(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Animation(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Animation(global::spine_cpp.Spine.Animation _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Animation.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Animation");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public float Duration
            {
                get
                {
                    var ___ret = __Internal.GetDuration(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetDuration(__Instance, value);
                }
            }

            #region Virtual table interop

            // ~Animation()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Animation.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        namespace Pool
        {
            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public unsafe partial struct __Internalc__N_spine_S_Pool____N_spine_S_TrackEntry
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _objects;
            }

            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public unsafe partial struct __Internalc__N_spine_S_Pool____N_spine_S_Polygon
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _objects;
            }

            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public unsafe partial struct __Internalc__N_spine_S_Pool____N_spine_S_Vector__f
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _objects;
            }

            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public unsafe partial struct __Internalc__N_spine_S_Pool____N_spine_S_Vector__I
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _objects;
            }
        }
    }

    namespace Spine
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void DisposeRendererObject(__IntPtr rendererObject);

        public unsafe partial interface IHasRendererObject : IDisposable
        {
            void SetRendererObject(__IntPtr rendererObject, global::spine_cpp.Spine.DisposeRendererObject dispose);

            __IntPtr __Instance { get; }

            __IntPtr __PointerToHasRendererObject { get; }

            __IntPtr RendererObject { get; }
        }

        public unsafe partial class HasRendererObject : global::spine_cpp.Spine.IHasRendererObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_HasRendererObject;
                internal __IntPtr _rendererObject;
                internal __IntPtr _dispose;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0HasRendererObject@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0HasRendererObject@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setRendererObject@HasRendererObject@spine@@QEAAXPEAXP6AX0@Z@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRendererObject(__IntPtr __instance, __IntPtr rendererObject, __IntPtr dispose);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getRendererObject@HasRendererObject@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRendererObject(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.IHasRendererObject> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.IHasRendererObject>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.Spine.IHasRendererObject managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.Spine.IHasRendererObject managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static HasRendererObject __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new HasRendererObject(native.ToPointer(), skipVTables);
            }

            internal static HasRendererObject __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (HasRendererObject)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static HasRendererObject __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (HasRendererObject)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static HasRendererObject __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new HasRendererObject(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.HasRendererObject.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private HasRendererObject(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected HasRendererObject(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            public HasRendererObject()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.HasRendererObject.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.HasRendererObject");
            }

            public HasRendererObject(global::spine_cpp.Spine.IHasRendererObject _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.HasRendererObject.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__PointerToHasRendererObject;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.HasRendererObject");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void SetRendererObject(__IntPtr rendererObject, global::spine_cpp.Spine.DisposeRendererObject dispose)
            {
                var __arg1 = dispose == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(dispose);
                __Internal.SetRendererObject(__Instance, rendererObject, __arg1);
            }

            public __IntPtr __PointerToHasRendererObject
            {
                get
                {
                    return __Instance + 0;
                }
            }

            public __IntPtr RendererObject
            {
                get
                {
                    var ___ret = __Internal.GetRendererObject(__Instance);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // virtual ~HasRendererObject()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.HasRendererObject.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class Color : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal float r;
                internal float g;
                internal float b;
                internal float a;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Color@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Color@spine@@QEAA@MMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, float r, float g, float b, float a);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Color@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?set@Color@spine@@QEAAAEAV12@MMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Set(__IntPtr __instance, float _r, float _g, float _b, float _a);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?set@Color@spine@@QEAAAEAV12@MMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Set(__IntPtr __instance, float _r, float _g, float _b);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?set@Color@spine@@QEAAAEAV12@AEBV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Set(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?add@Color@spine@@QEAAAEAV12@MMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Add(__IntPtr __instance, float _r, float _g, float _b, float _a);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?add@Color@spine@@QEAAAEAV12@MMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Add(__IntPtr __instance, float _r, float _g, float _b);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?add@Color@spine@@QEAAAEAV12@AEBV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Add(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?clamp@Color@spine@@QEAAAEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Clamp(__IntPtr __instance);
            }

            internal static new Color __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Color(native.ToPointer(), skipVTables);
            }

            internal static new Color __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Color)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Color __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Color)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Color __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Color(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Color.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Color(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Color(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Color()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Color.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Color");
            }

            public Color(float r, float g, float b, float a)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Color.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, r, g, b, a);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Color");
            }

            public Color(global::spine_cpp.Spine.Color _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Color.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Color");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::spine_cpp.Spine.Color Set(float _r, float _g, float _b, float _a)
            {
                var ___ret = __Internal.Set(__Instance, _r, _g, _b, _a);
                var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.Color Set(float _r, float _g, float _b)
            {
                var ___ret = __Internal.Set(__Instance, _r, _g, _b);
                var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.Color Set(global::spine_cpp.Spine.Color other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = __Internal.Set(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.Color Add(float _r, float _g, float _b, float _a)
            {
                var ___ret = __Internal.Add(__Instance, _r, _g, _b, _a);
                var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.Color Add(float _r, float _g, float _b)
            {
                var ___ret = __Internal.Add(__Instance, _r, _g, _b);
                var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.Color Add(global::spine_cpp.Spine.Color other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = __Internal.Add(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public float R
            {
                get
                {
                    return ((__Internal*)__Instance)->r;
                }

                set
                {
                    ((__Internal*)__Instance)->r = value;
                }
            }

            public float G
            {
                get
                {
                    return ((__Internal*)__Instance)->g;
                }

                set
                {
                    ((__Internal*)__Instance)->g = value;
                }
            }

            public float B
            {
                get
                {
                    return ((__Internal*)__Instance)->b;
                }

                set
                {
                    ((__Internal*)__Instance)->b = value;
                }
            }

            public float A
            {
                get
                {
                    return ((__Internal*)__Instance)->a;
                }

                set
                {
                    ((__Internal*)__Instance)->a = value;
                }
            }

            public global::spine_cpp.Spine.Color Clamp
            {
                get
                {
                    var ___ret = __Internal.Clamp(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // Color
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Color.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class Slot : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 136)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _data;
                internal __IntPtr _bone;
                internal __IntPtr _skeleton;
                internal global::spine_cpp.Spine.Color.__Internal _color;
                internal global::spine_cpp.Spine.Color.__Internal _darkColor;
                internal byte _hasDarkColor;
                internal __IntPtr _attachment;
                internal int _attachmentState;
                internal int _sequenceIndex;
                internal global::spine_cpp.Spine.Vector.__Internal _deform;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Slot@spine@@QEAA@AEAVSlotData@1@AEAVBone@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr data, __IntPtr bone);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Slot@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setToSetupPose@Slot@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetToSetupPose(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getData@Slot@spine@@QEAAAEAVSlotData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBone@Slot@spine@@QEAAAEAVBone@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBone(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSkeleton@Slot@spine@@QEAAAEAVSkeleton@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSkeleton(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getColor@Slot@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getDarkColor@Slot@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDarkColor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?hasDarkColor@Slot@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasDarkColor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAttachment@Slot@spine@@QEAAPEAVAttachment@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAttachment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAttachment@Slot@spine@@QEAAXPEAVAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAttachment(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAttachmentState@Slot@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetAttachmentState(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAttachmentState@Slot@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAttachmentState(__IntPtr __instance, int state);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSequenceIndex@Slot@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetSequenceIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSequenceIndex@Slot@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSequenceIndex(__IntPtr __instance, int index);
            }

            internal static new Slot __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Slot(native.ToPointer(), skipVTables);
            }

            internal static new Slot __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Slot)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Slot __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Slot)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Slot __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Slot(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Slot.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Slot(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Slot(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Slot(global::spine_cpp.Spine.SlotData data, global::spine_cpp.Spine.Bone bone)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Slot.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(data, null))
                    throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = data.__Instance;
                if (ReferenceEquals(bone, null))
                    throw new global::System.ArgumentNullException("bone", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = bone.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Slot");
            }

            public Slot(global::spine_cpp.Spine.Slot _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Slot.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Slot");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void SetToSetupPose()
            {
                __Internal.SetToSetupPose(__Instance);
            }

            public global::spine_cpp.Spine.SlotData Data
            {
                get
                {
                    var ___ret = __Internal.GetData(__Instance);
                    var __result0 = global::spine_cpp.Spine.SlotData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Bone Bone
            {
                get
                {
                    var ___ret = __Internal.GetBone(__Instance);
                    var __result0 = global::spine_cpp.Spine.Bone.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Skeleton Skeleton
            {
                get
                {
                    var ___ret = __Internal.GetSkeleton(__Instance);
                    var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Color DarkColor
            {
                get
                {
                    var ___ret = __Internal.GetDarkColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public bool HasDarkColor
            {
                get
                {
                    var ___ret = __Internal.HasDarkColor(__Instance);
                    return ___ret;
                }
            }

            /// <summary>May be NULL.</summary>
            public global::spine_cpp.Spine.Attachment Attachment
            {
                get
                {
                    var ___ret = __Internal.GetAttachment(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetAttachment(__Instance, __arg0);
                }
            }

            public int AttachmentState
            {
                get
                {
                    var ___ret = __Internal.GetAttachmentState(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAttachmentState(__Instance, value);
                }
            }

            public int SequenceIndex
            {
                get
                {
                    var ___ret = __Internal.GetSequenceIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSequenceIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // Slot
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Slot.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public enum EventType
        {
            EventTypeStart = 0,
            EventTypeInterrupt = 1,
            EventTypeEnd = 2,
            EventTypeComplete = 3,
            EventTypeDispose = 4,
            EventTypeEvent = 5
        }

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void AnimationStateListener(__IntPtr state, global::spine_cpp.Spine.EventType type, __IntPtr entry, __IntPtr @event);

        /// <summary>Abstract class to inherit from to create a callback object</summary>
        public unsafe abstract partial class AnimationStateListenerObject : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_AnimationStateListenerObject;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AnimationStateListenerObject@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AnimationStateListenerObject@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.AnimationStateListenerObject> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.AnimationStateListenerObject>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.Spine.AnimationStateListenerObject managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.Spine.AnimationStateListenerObject managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static AnimationStateListenerObject __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AnimationStateListenerObjectInternal(native.ToPointer(), skipVTables);
            }

            internal static AnimationStateListenerObject __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AnimationStateListenerObject)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static AnimationStateListenerObject __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AnimationStateListenerObject)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AnimationStateListenerObject __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AnimationStateListenerObjectInternal(native, skipVTables);
            }

            protected AnimationStateListenerObject(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected AnimationStateListenerObject()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AnimationStateListenerObject.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AnimationStateListenerObject");
            }

            protected AnimationStateListenerObject(global::spine_cpp.Spine.AnimationStateListenerObject _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AnimationStateListenerObject.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AnimationStateListenerObject");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>The callback function to be called</summary>
            public abstract void Callback(global::spine_cpp.Spine.AnimationState state, global::spine_cpp.Spine.EventType type, global::spine_cpp.Spine.TrackEntry entry, global::spine_cpp.Spine.Event @event);

            #region Virtual table interop

            // virtual ~AnimationStateListenerObject()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.AnimationStateListenerObject.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void callback(AnimationState *state, EventType type, TrackEntry *entry, Event *event) = 0
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_spine_cpp_spine_EventType___IntPtr___IntPtr _CallbackDelegateInstance;

            private static void _CallbackDelegateHook(__IntPtr __instance, __IntPtr state, global::spine_cpp.Spine.EventType type, __IntPtr entry, __IntPtr @event)
            {
                var __target = global::spine_cpp.Spine.AnimationStateListenerObject.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.AnimationState.__GetOrCreateInstance(state, false, skipVTables: true);
                var __result2 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(entry, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Event.__GetOrCreateInstance(@event, false, skipVTables: true);
                __target.Callback(__result0, type, __result2, __result3);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _CallbackDelegateInstance += _CallbackDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CallbackDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>State for the playback of an animation</summary>
        public unsafe partial class TrackEntry : global::spine_cpp.Spine.SpineObject, global::spine_cpp.Spine.IHasRendererObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 272)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr vfptr_HasRendererObject;
                internal __IntPtr _rendererObject;
                internal __IntPtr _dispose;
                internal __IntPtr _animation;
                internal __IntPtr _previous;
                internal __IntPtr _next;
                internal __IntPtr _mixingFrom;
                internal __IntPtr _mixingTo;
                internal int _trackIndex;
                internal byte _loop;
                internal byte _holdPrevious;
                internal byte _reverse;
                internal byte _shortestRotation;
                internal float _eventThreshold;
                internal float _attachmentThreshold;
                internal float _drawOrderThreshold;
                internal float _animationStart;
                internal float _animationEnd;
                internal float _animationLast;
                internal float _nextAnimationLast;
                internal float _delay;
                internal float _trackTime;
                internal float _trackLast;
                internal float _nextTrackLast;
                internal float _trackEnd;
                internal float _timeScale;
                internal float _alpha;
                internal float _mixTime;
                internal float _mixDuration;
                internal float _interruptAlpha;
                internal float _totalAlpha;
                internal global::spine_cpp.Spine.MixBlend _mixBlend;
                internal global::spine_cpp.Spine.Vector.__Internal _timelineMode;
                internal global::spine_cpp.Spine.Vector.__Internal _timelineHoldMix;
                internal global::spine_cpp.Spine.Vector.__Internal _timelinesRotation;
                internal __IntPtr _listener;
                internal __IntPtr _listenerObject;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0TrackEntry@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0TrackEntry@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?resetRotationDirections@TrackEntry@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ResetRotationDirections(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setListener@TrackEntry@spine@@QEAAXP6AXPEAVAnimationState@2@W4EventType@2@PEAV12@PEAVEvent@2@@Z@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetListener(__IntPtr __instance, __IntPtr listener);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setListener@TrackEntry@spine@@QEAAXPEAVAnimationStateListenerObject@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetListener_1(__IntPtr __instance, __IntPtr listener);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setRendererObject@HasRendererObject@spine@@QEAAXPEAXP6AX0@Z@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRendererObject(__IntPtr __instance, __IntPtr rendererObject, __IntPtr dispose);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getTrackIndex@TrackEntry@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetTrackIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAnimation@TrackEntry@spine@@QEAAPEAVAnimation@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAnimation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getPrevious@TrackEntry@spine@@QEAAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetPrevious(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getLoop@TrackEntry@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetLoop(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setLoop@TrackEntry@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetLoop(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getHoldPrevious@TrackEntry@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetHoldPrevious(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setHoldPrevious@TrackEntry@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHoldPrevious(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getReverse@TrackEntry@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetReverse(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setReverse@TrackEntry@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetReverse(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getShortestRotation@TrackEntry@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetShortestRotation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setShortestRotation@TrackEntry@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetShortestRotation(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getDelay@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetDelay(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setDelay@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDelay(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getTrackTime@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetTrackTime(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setTrackTime@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTrackTime(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getTrackEnd@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetTrackEnd(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setTrackEnd@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTrackEnd(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAnimationStart@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAnimationStart(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAnimationStart@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAnimationStart(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAnimationEnd@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAnimationEnd(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAnimationEnd@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAnimationEnd(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAnimationLast@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAnimationLast(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAnimationLast@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAnimationLast(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAnimationTime@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAnimationTime(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getTimeScale@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetTimeScale(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setTimeScale@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTimeScale(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAlpha@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAlpha(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAlpha@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAlpha(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getEventThreshold@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetEventThreshold(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setEventThreshold@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetEventThreshold(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAttachmentThreshold@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAttachmentThreshold(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAttachmentThreshold@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAttachmentThreshold(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getDrawOrderThreshold@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetDrawOrderThreshold(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setDrawOrderThreshold@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDrawOrderThreshold(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getNext@TrackEntry@spine@@QEAAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetNext(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?isComplete@TrackEntry@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsComplete(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixTime@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixTime(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixTime@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixTime(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixDuration@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixDuration(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixDuration@TrackEntry@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixDuration(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixBlend@TrackEntry@spine@@QEAA?AW4MixBlend@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::spine_cpp.Spine.MixBlend GetMixBlend(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixBlend@TrackEntry@spine@@QEAAXW4MixBlend@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixBlend(__IntPtr __instance, global::spine_cpp.Spine.MixBlend blend);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixingFrom@TrackEntry@spine@@QEAAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetMixingFrom(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixingTo@TrackEntry@spine@@QEAAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetMixingTo(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getTrackComplete@TrackEntry@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetTrackComplete(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getRendererObject@HasRendererObject@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRendererObject(__IntPtr __instance);
            }

            internal static new TrackEntry __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TrackEntry(native.ToPointer(), skipVTables);
            }

            internal static new TrackEntry __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TrackEntry)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new TrackEntry __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (TrackEntry)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static TrackEntry __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TrackEntry(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.TrackEntry.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private TrackEntry(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TrackEntry(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public TrackEntry()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TrackEntry.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TrackEntry");
            }

            public TrackEntry(global::spine_cpp.Spine.TrackEntry _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TrackEntry.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TrackEntry");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                *(IntPtr*)(__Instance + 8) = __VTables.Tables[1];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the</para>
            /// <para>long way around when using alpha and starting animations on other tracks.</para>
            /// </summary>
            /// <remarks>
            /// <para>Mixing involves finding a rotation between two others, which has two possible solutions: the short way or the long way around.</para>
            /// <para>The two rotations likely change over time, so which direction is the short or long way also changes.</para>
            /// <para>If the short way was always chosen, bones would flip to the other side when that direction became the long way.</para>
            /// <para>TrackEntry chooses the short way the first time it is applied and remembers that direction.</para>
            /// </remarks>
            public void ResetRotationDirections()
            {
                __Internal.ResetRotationDirections(__Instance);
            }

            public void SetListener(global::spine_cpp.Spine.AnimationStateListener listener)
            {
                var __arg0 = listener == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(listener);
                __Internal.SetListener(__Instance, __arg0);
            }

            public void SetListener(global::spine_cpp.Spine.AnimationStateListenerObject listener)
            {
                var __arg0 = listener is null ? __IntPtr.Zero : listener.__Instance;
                __Internal.SetListener_1(__Instance, __arg0);
            }

            public void SetRendererObject(__IntPtr rendererObject, global::spine_cpp.Spine.DisposeRendererObject dispose)
            {
                var __arg1 = dispose == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(dispose);
                __Internal.SetRendererObject(__Instance + 8, rendererObject, __arg1);
            }

            public __IntPtr __PointerToHasRendererObject
            {
                get
                {
                    return __Instance + 8;
                }
            }

            /// <summary>The index of the track where this entry is either current or queued.</summary>
            public int TrackIndex
            {
                get
                {
                    var ___ret = __Internal.GetTrackIndex(__Instance);
                    return ___ret;
                }
            }

            /// <summary>The animation to apply for this track entry.</summary>
            public global::spine_cpp.Spine.Animation Animation
            {
                get
                {
                    var ___ret = __Internal.GetAnimation(__Instance);
                    var __result0 = global::spine_cpp.Spine.Animation.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.TrackEntry Previous
            {
                get
                {
                    var ___ret = __Internal.GetPrevious(__Instance);
                    var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>If true, the animation will repeat. If false, it will not, instead its last frame is applied if played beyond its duration.</summary>
            public bool Loop
            {
                get
                {
                    var ___ret = __Internal.GetLoop(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetLoop(__Instance, value);
                }
            }

            /// <summary>
            /// <para>If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead</para>
            /// <para>of being mixed out.</para>
            /// </summary>
            /// <remarks>
            /// <para>When mixing between animations that key the same property, if a lower track also keys that property then the value will</para>
            /// <para>briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%</para>
            /// <para>while the second animation mixes from 0% to 100%. Setting holdPrevious to true applies the first animation</para>
            /// <para>at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which</para>
            /// <para>keys the property, only when a higher track also keys the property.</para>
            /// <para>Snapping will occur if holdPrevious is true and this animation does not key all the same properties as the</para>
            /// <para>previous animation.</para>
            /// </remarks>
            public bool HoldPrevious
            {
                get
                {
                    var ___ret = __Internal.GetHoldPrevious(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHoldPrevious(__Instance, value);
                }
            }

            public bool Reverse
            {
                get
                {
                    var ___ret = __Internal.GetReverse(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetReverse(__Instance, value);
                }
            }

            public bool ShortestRotation
            {
                get
                {
                    var ___ret = __Internal.GetShortestRotation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetShortestRotation(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Seconds to postpone playing the animation. When a track entry is the current track entry, delay postpones incrementing</para>
            /// <para>the track time. When a track entry is queued, delay is the time from the start of the previous animation to when the</para>
            /// <para>track entry will become the current track entry.</para>
            /// </summary>
            public float Delay
            {
                get
                {
                    var ___ret = __Internal.GetDelay(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetDelay(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Current time in seconds this track entry has been the current track entry. The track time determines</para>
            /// <para>TrackEntry.AnimationTime. The track time can be set to start the animation at a time other than 0, without affecting looping.</para>
            /// </summary>
            public float TrackTime
            {
                get
                {
                    var ___ret = __Internal.GetTrackTime(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetTrackTime(__Instance, value);
                }
            }

            /// <summary>
            /// <para>The track time in seconds when this animation will be removed from the track. Defaults to the animation duration for</para>
            /// <para>non-looping animations and to int.MaxValue for looping animations. If the track end time is reached and no</para>
            /// <para>other animations are queued for playback, and mixing from any previous animations is complete, properties keyed by the animation,</para>
            /// <para>are set to the setup pose and the track is cleared.</para>
            /// </summary>
            /// <remarks>
            /// <para>It may be desired to use AnimationState.addEmptyAnimation(int, float, float) to mix the properties back to the</para>
            /// <para>setup pose over time, rather than have it happen instantly.</para>
            /// </remarks>
            public float TrackEnd
            {
                get
                {
                    var ___ret = __Internal.GetTrackEnd(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetTrackEnd(__Instance, value);
                }
            }

            /// <summary>Seconds when this animation starts, both initially and after looping. Defaults to 0.</summary>
            /// <remarks>
            /// <para>When changing the animation start time, it often makes sense to set TrackEntry.AnimationLast to the same value to</para>
            /// <para>prevent timeline keys before the start time from triggering.</para>
            /// </remarks>
            public float AnimationStart
            {
                get
                {
                    var ___ret = __Internal.GetAnimationStart(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAnimationStart(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will</para>
            /// <para>loop back to TrackEntry.AnimationStart at this time. Defaults to the animation duration.</para>
            /// </summary>
            public float AnimationEnd
            {
                get
                {
                    var ___ret = __Internal.GetAnimationEnd(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAnimationEnd(__Instance, value);
                }
            }

            /// <summary>
            /// <para>The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this</para>
            /// <para>animation is applied, event timelines will fire all events between the animation last time (exclusive) and animation time</para>
            /// <para>(inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation is applied.</para>
            /// </summary>
            public float AnimationLast
            {
                get
                {
                    var ___ret = __Internal.GetAnimationLast(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAnimationLast(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Uses TrackEntry.TrackTime to compute the animation time between TrackEntry.AnimationStart. and</para>
            /// <para>TrackEntry.AnimationEnd. When the track time is 0, the animation time is equal to the animation start time.</para>
            /// </summary>
            public float AnimationTime
            {
                get
                {
                    var ___ret = __Internal.GetAnimationTime(__Instance);
                    return ___ret;
                }
            }

            /// <summary>
            /// <para>Multiplier for the delta time when the animation state is updated, causing time for this animation to play slower or</para>
            /// <para>faster. Defaults to 1.</para>
            /// </summary>
            public float TimeScale
            {
                get
                {
                    var ___ret = __Internal.GetTimeScale(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetTimeScale(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Values less than 1 mix this animation with the last skeleton pose. Defaults to 1, which overwrites the last skeleton pose with</para>
            /// <para>this animation.</para>
            /// </summary>
            /// <remarks>
            /// <para>Typically track 0 is used to completely pose the skeleton, then alpha can be used on higher tracks. It doesn't make sense</para>
            /// <para>to use alpha on track 0 if the skeleton pose is from the last frame render.</para>
            /// </remarks>
            public float Alpha
            {
                get
                {
                    var ___ret = __Internal.GetAlpha(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAlpha(__Instance, value);
                }
            }

            /// <summary>
            /// <para>When the mix percentage (mix time / mix duration) is less than the event threshold, event timelines for the animation</para>
            /// <para>being mixed out will be applied. Defaults to 0, so event timelines are not applied for an animation being mixed out.</para>
            /// </summary>
            public float EventThreshold
            {
                get
                {
                    var ___ret = __Internal.GetEventThreshold(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetEventThreshold(__Instance, value);
                }
            }

            /// <summary>
            /// <para>When the mix percentage (mix time / mix duration) is less than the attachment threshold, attachment timelines for the</para>
            /// <para>animation being mixed out will be applied. Defaults to 0, so attachment timelines are not applied for an animation being</para>
            /// <para>mixed out.</para>
            /// </summary>
            public float AttachmentThreshold
            {
                get
                {
                    var ___ret = __Internal.GetAttachmentThreshold(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAttachmentThreshold(__Instance, value);
                }
            }

            /// <summary>
            /// <para>When the mix percentage (mix time / mix duration) is less than the draw order threshold, draw order timelines for the</para>
            /// <para>animation being mixed out will be applied. Defaults to 0, so draw order timelines are not applied for an animation being</para>
            /// <para>mixed out.</para>
            /// </summary>
            public float DrawOrderThreshold
            {
                get
                {
                    var ___ret = __Internal.GetDrawOrderThreshold(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetDrawOrderThreshold(__Instance, value);
                }
            }

            /// <summary>The animation queued to start after this animation, or NULL.</summary>
            public global::spine_cpp.Spine.TrackEntry Next
            {
                get
                {
                    var ___ret = __Internal.GetNext(__Instance);
                    var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>Returns true if at least one loop has been completed.</summary>
            public bool IsComplete
            {
                get
                {
                    var ___ret = __Internal.IsComplete(__Instance);
                    return ___ret;
                }
            }

            /// <summary>
            /// <para>Seconds from 0 to the mix duration when mixing from the previous animation to this animation. May be slightly more than</para>
            /// <para>TrackEntry.MixDuration when the mix is complete.</para>
            /// </summary>
            public float MixTime
            {
                get
                {
                    var ___ret = __Internal.GetMixTime(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixTime(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Seconds for mixing from the previous animation to this animation. Defaults to the value provided by</para>
            /// <para>AnimationStateData based on the animation before this animation (if any).</para>
            /// </summary>
            /// <remarks>
            /// <para>The mix duration can be set manually rather than use the value from AnimationStateData.GetMix.</para>
            /// <para>In that case, the mixDuration must be set before AnimationState.update(float) is next called.</para>
            /// <para>When using AnimationState::addAnimation(int, Animation, bool, float) with a delay</para>
            /// <para>less than or equal to 0, note the Delay is set using the mix duration from the AnimationStateData</para>
            /// </remarks>
            public float MixDuration
            {
                get
                {
                    var ___ret = __Internal.GetMixDuration(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixDuration(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.MixBlend MixBlend
            {
                get
                {
                    var ___ret = __Internal.GetMixBlend(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixBlend(__Instance, value);
                }
            }

            /// <summary>
            /// <para>The track entry for the previous animation when mixing from the previous animation to this animation, or NULL if no</para>
            /// <para>mixing is currently occuring. When mixing from multiple animations, MixingFrom makes up a double linked list with MixingTo.</para>
            /// </summary>
            public global::spine_cpp.Spine.TrackEntry MixingFrom
            {
                get
                {
                    var ___ret = __Internal.GetMixingFrom(__Instance);
                    var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>
            /// <para>The track entry for the next animation when mixing from this animation, or NULL if no mixing is currently occuring.</para>
            /// <para>When mixing from multiple animations, MixingTo makes up a double linked list with MixingFrom.</para>
            /// </summary>
            public global::spine_cpp.Spine.TrackEntry MixingTo
            {
                get
                {
                    var ___ret = __Internal.GetMixingTo(__Instance);
                    var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public float TrackComplete
            {
                get
                {
                    var ___ret = __Internal.GetTrackComplete(__Instance);
                    return ___ret;
                }
            }

            public __IntPtr RendererObject
            {
                get
                {
                    var ___ret = __Internal.GetRendererObject(__Instance + 8);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // virtual ~TrackEntry()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.TrackEntry.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[2];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[2];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0), *(IntPtr*)(instance + 8) };
                                VTables.Methods = new Delegate[2][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTablesDtorOnly[1] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 8, 1, 0);
                                ManagedVTablesDtorOnly[1][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                                ManagedVTables[1] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 8, 1, 0);
                                ManagedVTables[1][0] = Thunks[0];
                                VTables.Methods[1] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        *(IntPtr**)(instance + 8) = ManagedVTablesDtorOnly[1];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        *(IntPtr**)(instance + 8) = ManagedVTables[1];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0), *(IntPtr*)(__Instance + 8) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class EventQueueEntry : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.EventType _type;
                internal __IntPtr _entry;
                internal __IntPtr _event;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0EventQueueEntry@spine@@QEAA@W4EventType@1@PEAVTrackEntry@1@PEAVEvent@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, global::spine_cpp.Spine.EventType eventType, __IntPtr trackEntry, __IntPtr @event);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0EventQueueEntry@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new EventQueueEntry __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new EventQueueEntry(native.ToPointer(), skipVTables);
            }

            internal static new EventQueueEntry __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (EventQueueEntry)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new EventQueueEntry __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (EventQueueEntry)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static EventQueueEntry __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new EventQueueEntry(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.EventQueueEntry.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private EventQueueEntry(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected EventQueueEntry(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public EventQueueEntry(global::spine_cpp.Spine.EventType eventType, global::spine_cpp.Spine.TrackEntry trackEntry, global::spine_cpp.Spine.Event @event)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.EventQueueEntry.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg1 = trackEntry is null ? __IntPtr.Zero : trackEntry.__Instance;
                var __arg2 = @event is null ? __IntPtr.Zero : @event.__Instance;
                __Internal.ctor(__Instance, eventType, __arg1, __arg2);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.EventQueueEntry");
            }

            public EventQueueEntry(global::spine_cpp.Spine.EventQueueEntry _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.EventQueueEntry.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.EventQueueEntry");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::spine_cpp.Spine.EventType Type
            {
                get
                {
                    return ((__Internal*)__Instance)->_type;
                }

                set
                {
                    ((__Internal*)__Instance)->_type = value;
                }
            }

            public global::spine_cpp.Spine.TrackEntry Entry
            {
                get
                {
                    var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(((__Internal*)__Instance)->_entry, true);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->_entry = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            public global::spine_cpp.Spine.Event Event
            {
                get
                {
                    var __result0 = global::spine_cpp.Spine.Event.__GetOrCreateInstance(((__Internal*)__Instance)->_event, true);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->_event = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            #region Virtual table interop

            // EventQueueEntry
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.EventQueueEntry.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class EventQueue : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 56)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _eventQueueEntries;
                internal __IntPtr _state;
                internal byte _drainDisabled;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0EventQueue@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new EventQueue __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new EventQueue(native.ToPointer(), skipVTables);
            }

            internal static new EventQueue __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (EventQueue)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new EventQueue __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (EventQueue)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static EventQueue __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new EventQueue(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.EventQueue.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private EventQueue(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected EventQueue(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public EventQueue(global::spine_cpp.Spine.EventQueue _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.EventQueue.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.EventQueue");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~EventQueue()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.EventQueue.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class AnimationState : global::spine_cpp.Spine.SpineObject, global::spine_cpp.Spine.IHasRendererObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 216)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr vfptr_HasRendererObject;
                internal __IntPtr _rendererObject;
                internal __IntPtr _dispose;
                internal __IntPtr _data;
                internal global::spine_cpp.Spine.Pool.__Internalc__N_spine_S_Pool____N_spine_S_TrackEntry _trackEntryPool;
                internal global::spine_cpp.Spine.Vector.__Internal _tracks;
                internal global::spine_cpp.Spine.Vector.__Internal _events;
                internal __IntPtr _queue;
                internal global::spine_cpp.Spine.HashMap.__Internal _propertyIDs;
                internal byte _animationsChanged;
                internal __IntPtr _listener;
                internal __IntPtr _listenerObject;
                internal int _unkeyedState;
                internal float _timeScale;
                internal byte _manualTrackEntryDisposal;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AnimationState@spine@@QEAA@PEAVAnimationStateData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr data);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AnimationState@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?update@AnimationState@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Update(__IntPtr __instance, float delta);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?apply@AnimationState@spine@@QEAA_NAEAVSkeleton@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Apply(__IntPtr __instance, __IntPtr skeleton);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?clearTracks@AnimationState@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearTracks(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?clearTrack@AnimationState@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearTrack(__IntPtr __instance, ulong trackIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAnimation@AnimationState@spine@@QEAAPEAVTrackEntry@2@_KAEBVString@2@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr SetAnimation(__IntPtr __instance, ulong trackIndex, __IntPtr animationName, bool loop);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAnimation@AnimationState@spine@@QEAAPEAVTrackEntry@2@_KPEAVAnimation@2@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr SetAnimation_1(__IntPtr __instance, ulong trackIndex, __IntPtr animation, bool loop);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?addAnimation@AnimationState@spine@@QEAAPEAVTrackEntry@2@_KAEBVString@2@_NM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr AddAnimation(__IntPtr __instance, ulong trackIndex, __IntPtr animationName, bool loop, float delay);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?addAnimation@AnimationState@spine@@QEAAPEAVTrackEntry@2@_KPEAVAnimation@2@_NM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr AddAnimation_1(__IntPtr __instance, ulong trackIndex, __IntPtr animation, bool loop, float delay);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setEmptyAnimation@AnimationState@spine@@QEAAPEAVTrackEntry@2@_KM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr SetEmptyAnimation(__IntPtr __instance, ulong trackIndex, float mixDuration);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?addEmptyAnimation@AnimationState@spine@@QEAAPEAVTrackEntry@2@_KMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr AddEmptyAnimation(__IntPtr __instance, ulong trackIndex, float mixDuration, float delay);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setEmptyAnimations@AnimationState@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetEmptyAnimations(__IntPtr __instance, float mixDuration);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getCurrent@AnimationState@spine@@QEAAPEAVTrackEntry@2@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetCurrent(__IntPtr __instance, ulong trackIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setListener@AnimationState@spine@@QEAAXP6AXPEAV12@W4EventType@2@PEAVTrackEntry@2@PEAVEvent@2@@Z@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetListener(__IntPtr __instance, __IntPtr listener);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setListener@AnimationState@spine@@QEAAXPEAVAnimationStateListenerObject@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetListener_1(__IntPtr __instance, __IntPtr listener);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?disableQueue@AnimationState@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DisableQueue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?enableQueue@AnimationState@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EnableQueue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?disposeTrackEntry@AnimationState@spine@@QEAAXPEAVTrackEntry@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DisposeTrackEntry(__IntPtr __instance, __IntPtr entry);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setRendererObject@HasRendererObject@spine@@QEAAXPEAXP6AX0@Z@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRendererObject(__IntPtr __instance, __IntPtr rendererObject, __IntPtr dispose);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getData@AnimationState@spine@@QEAAPEAVAnimationStateData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getTimeScale@AnimationState@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetTimeScale(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setTimeScale@AnimationState@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTimeScale(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getManualTrackEntryDisposal@AnimationState@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetManualTrackEntryDisposal(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setManualTrackEntryDisposal@AnimationState@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetManualTrackEntryDisposal(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getRendererObject@HasRendererObject@spine@@QEAAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRendererObject(__IntPtr __instance);
            }

            internal static new AnimationState __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AnimationState(native.ToPointer(), skipVTables);
            }

            internal static new AnimationState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AnimationState)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new AnimationState __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AnimationState)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AnimationState __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AnimationState(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.AnimationState.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private AnimationState(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected AnimationState(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public AnimationState(global::spine_cpp.Spine.AnimationStateData data)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AnimationState.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = data is null ? __IntPtr.Zero : data.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AnimationState");
            }

            public AnimationState(global::spine_cpp.Spine.AnimationState _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AnimationState.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AnimationState");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                *(IntPtr*)(__Instance + 8) = __VTables.Tables[1];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Increments the track entry times, setting queued animations as current if needed</summary>
            /// <param name="delta">delta time</param>
            public void Update(float delta)
            {
                __Internal.Update(__Instance, delta);
            }

            /// <summary>
            /// <para>Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the</para>
            /// <para>animation state can be applied to multiple skeletons to pose them identically.</para>
            /// </summary>
            public bool Apply(global::spine_cpp.Spine.Skeleton skeleton)
            {
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                var ___ret = __Internal.Apply(__Instance, __arg0);
                return ___ret;
            }

            /// <summary>
            /// <para>Removes all animations from all tracks, leaving skeletons in their previous pose.</para>
            /// <para>It may be desired to use AnimationState.setEmptyAnimations(float) to mix the skeletons back to the setup pose,</para>
            /// <para>rather than leaving them in their previous pose.</para>
            /// </summary>
            public void ClearTracks()
            {
                __Internal.ClearTracks(__Instance);
            }

            /// <summary>
            /// <para>Removes all animations from the tracks, leaving skeletons in their previous pose.</para>
            /// <para>It may be desired to use AnimationState.setEmptyAnimations(float) to mix the skeletons back to the setup pose,</para>
            /// <para>rather than leaving them in their previous pose.</para>
            /// </summary>
            public void ClearTrack(ulong trackIndex)
            {
                __Internal.ClearTrack(__Instance, trackIndex);
            }

            /// <summary>Sets an animation by name. setAnimation(int, Animation, bool)</summary>
            public global::spine_cpp.Spine.TrackEntry SetAnimation(ulong trackIndex, global::spine_cpp.Spine.String animationName, bool loop)
            {
                if (ReferenceEquals(animationName, null))
                    throw new global::System.ArgumentNullException("animationName", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = animationName.__Instance;
                var ___ret = __Internal.SetAnimation(__Instance, trackIndex, __arg1, loop);
                var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Sets the current animation for a track, discarding any queued animations.</summary>
            /// <param name="loop">
            /// <para>If true, the animation will repeat.</para>
            /// <para>If false, it will not, instead its last frame is applied if played beyond its duration.</para>
            /// <para>In either case TrackEntry.TrackEnd determines when the track is cleared.</para>
            /// </param>
            /// <returns>
            /// <para>A track entry to allow further customization of animation playback. References to the track entry must not be kept</para>
            /// <para>after AnimationState.Dispose.</para>
            /// </returns>
            public global::spine_cpp.Spine.TrackEntry SetAnimation(ulong trackIndex, global::spine_cpp.Spine.Animation animation, bool loop)
            {
                var __arg1 = animation is null ? __IntPtr.Zero : animation.__Instance;
                var ___ret = __Internal.SetAnimation_1(__Instance, trackIndex, __arg1, loop);
                var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>
            /// <para>Queues an animation by name.</para>
            /// <para>addAnimation(int, Animation, bool, float)</para>
            /// </summary>
            public global::spine_cpp.Spine.TrackEntry AddAnimation(ulong trackIndex, global::spine_cpp.Spine.String animationName, bool loop, float delay)
            {
                if (ReferenceEquals(animationName, null))
                    throw new global::System.ArgumentNullException("animationName", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = animationName.__Instance;
                var ___ret = __Internal.AddAnimation(__Instance, trackIndex, __arg1, loop, delay);
                var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>
            /// <para>Adds an animation to be played delay seconds after the current or last queued animation</para>
            /// <para>for a track. If the track is empty, it is equivalent to calling setAnimation.</para>
            /// </summary>
            /// <param name="delay">
            /// <para>Seconds to begin this animation after the start of the previous animation. May be&lt;= 0 to use the animation</para>
            /// <para>duration of the previous track minus any mix duration plus the negative delay.</para>
            /// </param>
            /// <returns>
            /// <para>A track entry to allow further customization of animation playback. References to the track entry must not be kept</para>
            /// <para>after AnimationState.Dispose</para>
            /// </returns>
            public global::spine_cpp.Spine.TrackEntry AddAnimation(ulong trackIndex, global::spine_cpp.Spine.Animation animation, bool loop, float delay)
            {
                var __arg1 = animation is null ? __IntPtr.Zero : animation.__Instance;
                var ___ret = __Internal.AddAnimation_1(__Instance, trackIndex, __arg1, loop, delay);
                var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Sets an empty animation for a track, discarding any queued animations, and mixes to it over the specified mix duration.</summary>
            public global::spine_cpp.Spine.TrackEntry SetEmptyAnimation(ulong trackIndex, float mixDuration)
            {
                var ___ret = __Internal.SetEmptyAnimation(__Instance, trackIndex, mixDuration);
                var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>
            /// <para>Adds an empty animation to be played after the current or last queued animation for a track, and mixes to it over the</para>
            /// <para>specified mix duration.</para>
            /// </summary>
            /// <param name="trackIndex">Track number.</param>
            /// <param name="mixDuration">Mix duration.</param>
            /// <param name="delay">
            /// <para>Seconds to begin this animation after the start of the previous animation. May be&lt;= 0 to use the animation</para>
            /// <para>duration of the previous track minus any mix duration plus the negative delay.</para>
            /// </param>
            /// <returns>A track entry to allow further customization of animation playback. References to the track entry must not be kept after AnimationState.Dispose.</returns>
            public global::spine_cpp.Spine.TrackEntry AddEmptyAnimation(ulong trackIndex, float mixDuration, float delay)
            {
                var ___ret = __Internal.AddEmptyAnimation(__Instance, trackIndex, mixDuration, delay);
                var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix duration.</summary>
            public void SetEmptyAnimations(float mixDuration)
            {
                __Internal.SetEmptyAnimations(__Instance, mixDuration);
            }

            /// <returns>The track entry for the animation currently playing on the track, or NULL if no animation is currently playing.</returns>
            public global::spine_cpp.Spine.TrackEntry GetCurrent(ulong trackIndex)
            {
                var ___ret = __Internal.GetCurrent(__Instance, trackIndex);
                var __result0 = global::spine_cpp.Spine.TrackEntry.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public void SetListener(global::spine_cpp.Spine.AnimationStateListener listener)
            {
                var __arg0 = listener == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(listener);
                __Internal.SetListener(__Instance, __arg0);
            }

            public void SetListener(global::spine_cpp.Spine.AnimationStateListenerObject listener)
            {
                var __arg0 = listener is null ? __IntPtr.Zero : listener.__Instance;
                __Internal.SetListener_1(__Instance, __arg0);
            }

            public void DisableQueue()
            {
                __Internal.DisableQueue(__Instance);
            }

            public void EnableQueue()
            {
                __Internal.EnableQueue(__Instance);
            }

            public void DisposeTrackEntry(global::spine_cpp.Spine.TrackEntry entry)
            {
                var __arg0 = entry is null ? __IntPtr.Zero : entry.__Instance;
                __Internal.DisposeTrackEntry(__Instance, __arg0);
            }

            public static explicit operator global::spine_cpp.Spine.AnimationState(global::spine_cpp.Spine.AnimationStateData data)
            {
                return new global::spine_cpp.Spine.AnimationState(data);
            }

            public void SetRendererObject(__IntPtr rendererObject, global::spine_cpp.Spine.DisposeRendererObject dispose)
            {
                var __arg1 = dispose == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(dispose);
                __Internal.SetRendererObject(__Instance + 8, rendererObject, __arg1);
            }

            public __IntPtr __PointerToHasRendererObject
            {
                get
                {
                    return __Instance + 8;
                }
            }

            public global::spine_cpp.Spine.AnimationStateData Data
            {
                get
                {
                    var ___ret = __Internal.GetData(__Instance);
                    var __result0 = global::spine_cpp.Spine.AnimationStateData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public float TimeScale
            {
                get
                {
                    var ___ret = __Internal.GetTimeScale(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetTimeScale(__Instance, value);
                }
            }

            public bool ManualTrackEntryDisposal
            {
                get
                {
                    var ___ret = __Internal.GetManualTrackEntryDisposal(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetManualTrackEntryDisposal(__Instance, value);
                }
            }

            public __IntPtr RendererObject
            {
                get
                {
                    var ___ret = __Internal.GetRendererObject(__Instance + 8);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // ~AnimationState()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.AnimationState.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[2];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[2];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0), *(IntPtr*)(instance + 8) };
                                VTables.Methods = new Delegate[2][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTablesDtorOnly[1] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 8, 1, 0);
                                ManagedVTablesDtorOnly[1][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                                ManagedVTables[1] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 8, 1, 0);
                                ManagedVTables[1][0] = Thunks[0];
                                VTables.Methods[1] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        *(IntPtr**)(instance + 8) = ManagedVTablesDtorOnly[1];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        *(IntPtr**)(instance + 8) = ManagedVTables[1];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0), *(IntPtr*)(__Instance + 8) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class AnimationStateListenerObjectInternal : global::spine_cpp.Spine.AnimationStateListenerObject, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal AnimationStateListenerObjectInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal AnimationStateListenerObjectInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>The callback function to be called</summary>
            public override void Callback(global::spine_cpp.Spine.AnimationState state, global::spine_cpp.Spine.EventType type, global::spine_cpp.Spine.TrackEntry entry, global::spine_cpp.Spine.Event @event)
            {
                var ___CallbackDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_spine_cpp_spine_EventType___IntPtr___IntPtr>(0, 1);
                var __arg0 = state is null ? __IntPtr.Zero : state.__Instance;
                var __arg2 = entry is null ? __IntPtr.Zero : entry.__Instance;
                var __arg3 = @event is null ? __IntPtr.Zero : @event.__Instance;
                ___CallbackDelegate(__Instance, __arg0, type, __arg2, __arg3);
            }
        }
    }

    namespace Spine
    {
        /// <summary>Stores mix (crossfade) durations to be applied when AnimationState animations are changed.</summary>
        public unsafe partial class AnimationStateData : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 48)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _skeletonData;
                internal float _defaultMix;
                internal global::spine_cpp.Spine.HashMap.__Internal _animationToMixTime;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AnimationStateData@spine@@QEAA@PEAVSkeletonData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr skeletonData);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AnimationStateData@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMix@AnimationStateData@spine@@QEAAXAEBVString@2@0M@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMix(__IntPtr __instance, __IntPtr fromName, __IntPtr toName, float duration);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMix@AnimationStateData@spine@@QEAAXPEAVAnimation@2@0M@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMix_1(__IntPtr __instance, __IntPtr from, __IntPtr to, float duration);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMix@AnimationStateData@spine@@QEAAMPEAVAnimation@2@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMix(__IntPtr __instance, __IntPtr from, __IntPtr to);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?clear@AnimationStateData@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clear(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSkeletonData@AnimationStateData@spine@@QEAAPEAVSkeletonData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSkeletonData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getDefaultMix@AnimationStateData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetDefaultMix(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setDefaultMix@AnimationStateData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDefaultMix(__IntPtr __instance, float inValue);
            }

            public unsafe partial class AnimationPair
            {
                [StructLayout(LayoutKind.Sequential, Size = 24)]
                public partial struct __Internal
                {
                    internal __IntPtr vfptr_SpineObject;
                    internal __IntPtr _a1;
                    internal __IntPtr _a2;
                }
            }

            internal static new AnimationStateData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AnimationStateData(native.ToPointer(), skipVTables);
            }

            internal static new AnimationStateData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AnimationStateData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new AnimationStateData __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AnimationStateData)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AnimationStateData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AnimationStateData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.AnimationStateData.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private AnimationStateData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected AnimationStateData(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public AnimationStateData(global::spine_cpp.Spine.SkeletonData skeletonData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AnimationStateData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = skeletonData is null ? __IntPtr.Zero : skeletonData.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AnimationStateData");
            }

            public AnimationStateData(global::spine_cpp.Spine.AnimationStateData _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AnimationStateData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AnimationStateData");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Sets a mix duration by animation names.</summary>
            public void SetMix(global::spine_cpp.Spine.String fromName, global::spine_cpp.Spine.String toName, float duration)
            {
                if (ReferenceEquals(fromName, null))
                    throw new global::System.ArgumentNullException("fromName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = fromName.__Instance;
                if (ReferenceEquals(toName, null))
                    throw new global::System.ArgumentNullException("toName", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = toName.__Instance;
                __Internal.SetMix(__Instance, __arg0, __arg1, duration);
            }

            /// <summary>
            /// <para>Sets a mix duration when changing from the specified animation to the other.</para>
            /// <para>See TrackEntry.MixDuration.</para>
            /// </summary>
            public void SetMix(global::spine_cpp.Spine.Animation from, global::spine_cpp.Spine.Animation to, float duration)
            {
                var __arg0 = from is null ? __IntPtr.Zero : from.__Instance;
                var __arg1 = to is null ? __IntPtr.Zero : to.__Instance;
                __Internal.SetMix_1(__Instance, __arg0, __arg1, duration);
            }

            /// <summary>
            /// <para>The mix duration to use when changing from the specified animation to the other,</para>
            /// <para>or the DefaultMix if no mix duration has been set.</para>
            /// </summary>
            public float GetMix(global::spine_cpp.Spine.Animation from, global::spine_cpp.Spine.Animation to)
            {
                var __arg0 = from is null ? __IntPtr.Zero : from.__Instance;
                var __arg1 = to is null ? __IntPtr.Zero : to.__Instance;
                var ___ret = __Internal.GetMix(__Instance, __arg0, __arg1);
                return ___ret;
            }

            /// <summary>Removes all mixes and sets the default mix to 0.</summary>
            public void Clear()
            {
                __Internal.Clear(__Instance);
            }

            public static explicit operator global::spine_cpp.Spine.AnimationStateData(global::spine_cpp.Spine.SkeletonData skeletonData)
            {
                return new global::spine_cpp.Spine.AnimationStateData(skeletonData);
            }

            /// <summary>The SkeletonData to look up animations when they are specified by name.</summary>
            public global::spine_cpp.Spine.SkeletonData SkeletonData
            {
                get
                {
                    var ___ret = __Internal.GetSkeletonData(__Instance);
                    var __result0 = global::spine_cpp.Spine.SkeletonData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>The mix duration to use when no mix duration has been specifically defined between two animations.</summary>
            public float DefaultMix
            {
                get
                {
                    var ___ret = __Internal.GetDefaultMix(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetDefaultMix(__Instance, value);
                }
            }

            #region Virtual table interop

            // AnimationStateData
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.AnimationStateData.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class TextureRegion : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 64)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr rendererObject;
                internal float u;
                internal float v;
                internal float u2;
                internal float v2;
                internal int degrees;
                internal float offsetX;
                internal float offsetY;
                internal int width;
                internal int height;
                internal int originalWidth;
                internal int originalHeight;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0TextureRegion@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0TextureRegion@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new TextureRegion __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TextureRegion(native.ToPointer(), skipVTables);
            }

            internal static new TextureRegion __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TextureRegion)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new TextureRegion __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (TextureRegion)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static TextureRegion __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TextureRegion(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.TextureRegion.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private TextureRegion(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TextureRegion(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public TextureRegion()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TextureRegion.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TextureRegion");
            }

            public TextureRegion(global::spine_cpp.Spine.TextureRegion _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TextureRegion.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TextureRegion");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public __IntPtr RendererObject
            {
                get
                {
                    return ((__Internal*)__Instance)->rendererObject;
                }

                set
                {
                    ((__Internal*)__Instance)->rendererObject = (__IntPtr) value;
                }
            }

            public float U
            {
                get
                {
                    return ((__Internal*)__Instance)->u;
                }

                set
                {
                    ((__Internal*)__Instance)->u = value;
                }
            }

            public float V
            {
                get
                {
                    return ((__Internal*)__Instance)->v;
                }

                set
                {
                    ((__Internal*)__Instance)->v = value;
                }
            }

            public float U2
            {
                get
                {
                    return ((__Internal*)__Instance)->u2;
                }

                set
                {
                    ((__Internal*)__Instance)->u2 = value;
                }
            }

            public float V2
            {
                get
                {
                    return ((__Internal*)__Instance)->v2;
                }

                set
                {
                    ((__Internal*)__Instance)->v2 = value;
                }
            }

            public int Degrees
            {
                get
                {
                    return ((__Internal*)__Instance)->degrees;
                }

                set
                {
                    ((__Internal*)__Instance)->degrees = value;
                }
            }

            public float OffsetX
            {
                get
                {
                    return ((__Internal*)__Instance)->offsetX;
                }

                set
                {
                    ((__Internal*)__Instance)->offsetX = value;
                }
            }

            public float OffsetY
            {
                get
                {
                    return ((__Internal*)__Instance)->offsetY;
                }

                set
                {
                    ((__Internal*)__Instance)->offsetY = value;
                }
            }

            public int Width
            {
                get
                {
                    return ((__Internal*)__Instance)->width;
                }

                set
                {
                    ((__Internal*)__Instance)->width = value;
                }
            }

            public int Height
            {
                get
                {
                    return ((__Internal*)__Instance)->height;
                }

                set
                {
                    ((__Internal*)__Instance)->height = value;
                }
            }

            public int OriginalWidth
            {
                get
                {
                    return ((__Internal*)__Instance)->originalWidth;
                }

                set
                {
                    ((__Internal*)__Instance)->originalWidth = value;
                }
            }

            public int OriginalHeight
            {
                get
                {
                    return ((__Internal*)__Instance)->originalHeight;
                }

                set
                {
                    ((__Internal*)__Instance)->originalHeight = value;
                }
            }

            #region Virtual table interop

            // ~TextureRegion()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.TextureRegion.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public enum Format
        {
            FormatAlpha = 0,
            FormatIntensity = 1,
            FormatLuminanceAlpha = 2,
            FormatRGB565 = 3,
            FormatRGBA4444 = 4,
            FormatRGB888 = 5,
            FormatRGBA8888 = 6
        }

        public enum TextureFilter
        {
            TextureFilterUnknown = 0,
            TextureFilterNearest = 1,
            TextureFilterLinear = 2,
            TextureFilterMipMap = 3,
            TextureFilterMipMapNearestNearest = 4,
            TextureFilterMipMapLinearNearest = 5,
            TextureFilterMipMapNearestLinear = 6,
            TextureFilterMipMapLinearLinear = 7
        }

        public enum TextureWrap
        {
            TextureWrapMirroredRepeat = 0,
            TextureWrapClampToEdge = 1,
            TextureWrapRepeat = 2
        }

        public unsafe partial class AtlasPage : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal name;
                internal global::spine_cpp.Spine.String.__Internal texturePath;
                internal global::spine_cpp.Spine.Format format;
                internal global::spine_cpp.Spine.TextureFilter minFilter;
                internal global::spine_cpp.Spine.TextureFilter magFilter;
                internal global::spine_cpp.Spine.TextureWrap uWrap;
                internal global::spine_cpp.Spine.TextureWrap vWrap;
                internal int width;
                internal int height;
                internal byte pma;
                internal int index;
                internal __IntPtr texture;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AtlasPage@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr inName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AtlasPage@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new AtlasPage __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AtlasPage(native.ToPointer(), skipVTables);
            }

            internal static new AtlasPage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AtlasPage)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new AtlasPage __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AtlasPage)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AtlasPage __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AtlasPage(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.AtlasPage.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private AtlasPage(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected AtlasPage(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public AtlasPage(global::spine_cpp.Spine.String inName)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AtlasPage.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(inName, null))
                    throw new global::System.ArgumentNullException("inName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = inName.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AtlasPage");
            }

            public AtlasPage(global::spine_cpp.Spine.AtlasPage _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AtlasPage.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AtlasPage");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.AtlasPage(global::spine_cpp.Spine.String inName)
            {
                return new global::spine_cpp.Spine.AtlasPage(inName);
            }

            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    return global::spine_cpp.Spine.String.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->name));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->name = *(global::spine_cpp.Spine.String.__Internal*) value.__Instance;
                }
            }

            public global::spine_cpp.Spine.String TexturePath
            {
                get
                {
                    return global::spine_cpp.Spine.String.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->texturePath));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->texturePath = *(global::spine_cpp.Spine.String.__Internal*) value.__Instance;
                }
            }

            public global::spine_cpp.Spine.Format Format
            {
                get
                {
                    return ((__Internal*)__Instance)->format;
                }

                set
                {
                    ((__Internal*)__Instance)->format = value;
                }
            }

            public global::spine_cpp.Spine.TextureFilter MinFilter
            {
                get
                {
                    return ((__Internal*)__Instance)->minFilter;
                }

                set
                {
                    ((__Internal*)__Instance)->minFilter = value;
                }
            }

            public global::spine_cpp.Spine.TextureFilter MagFilter
            {
                get
                {
                    return ((__Internal*)__Instance)->magFilter;
                }

                set
                {
                    ((__Internal*)__Instance)->magFilter = value;
                }
            }

            public global::spine_cpp.Spine.TextureWrap UWrap
            {
                get
                {
                    return ((__Internal*)__Instance)->uWrap;
                }

                set
                {
                    ((__Internal*)__Instance)->uWrap = value;
                }
            }

            public global::spine_cpp.Spine.TextureWrap VWrap
            {
                get
                {
                    return ((__Internal*)__Instance)->vWrap;
                }

                set
                {
                    ((__Internal*)__Instance)->vWrap = value;
                }
            }

            public int Width
            {
                get
                {
                    return ((__Internal*)__Instance)->width;
                }

                set
                {
                    ((__Internal*)__Instance)->width = value;
                }
            }

            public int Height
            {
                get
                {
                    return ((__Internal*)__Instance)->height;
                }

                set
                {
                    ((__Internal*)__Instance)->height = value;
                }
            }

            public bool Pma
            {
                get
                {
                    return ((__Internal*)__Instance)->pma != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->pma = (byte) (value ? 1 : 0);
                }
            }

            public int Index
            {
                get
                {
                    return ((__Internal*)__Instance)->index;
                }

                set
                {
                    ((__Internal*)__Instance)->index = value;
                }
            }

            public __IntPtr Texture
            {
                get
                {
                    return ((__Internal*)__Instance)->texture;
                }

                set
                {
                    ((__Internal*)__Instance)->texture = (__IntPtr) value;
                }
            }

            #region Virtual table interop

            // AtlasPage
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.AtlasPage.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class AtlasRegion : global::spine_cpp.Spine.TextureRegion, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 248)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr rendererObject;
                internal float u;
                internal float v;
                internal float u2;
                internal float v2;
                internal int degrees;
                internal float offsetX;
                internal float offsetY;
                internal int width;
                internal int height;
                internal int originalWidth;
                internal int originalHeight;
                internal __IntPtr page;
                internal global::spine_cpp.Spine.String.__Internal name;
                internal int index;
                internal int x;
                internal int y;
                internal global::spine_cpp.Spine.Vector.__Internal splits;
                internal global::spine_cpp.Spine.Vector.__Internal pads;
                internal global::spine_cpp.Spine.Vector.__Internal names;
                internal global::spine_cpp.Spine.Vector.__Internal values;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AtlasRegion@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AtlasRegion@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new AtlasRegion __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AtlasRegion(native.ToPointer(), skipVTables);
            }

            internal static new AtlasRegion __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AtlasRegion)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new AtlasRegion __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AtlasRegion)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AtlasRegion __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AtlasRegion(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.AtlasRegion.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private AtlasRegion(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected AtlasRegion(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public AtlasRegion(global::spine_cpp.Spine.AtlasRegion _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AtlasRegion.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AtlasRegion");
            }

            public AtlasRegion()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AtlasRegion.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AtlasRegion");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::spine_cpp.Spine.AtlasPage Page
            {
                get
                {
                    var __result0 = global::spine_cpp.Spine.AtlasPage.__GetOrCreateInstance(((__Internal*)__Instance)->page, true);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->page = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    return global::spine_cpp.Spine.String.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->name));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->name = *(global::spine_cpp.Spine.String.__Internal*) value.__Instance;
                }
            }

            public int Index
            {
                get
                {
                    return ((__Internal*)__Instance)->index;
                }

                set
                {
                    ((__Internal*)__Instance)->index = value;
                }
            }

            public int X
            {
                get
                {
                    return ((__Internal*)__Instance)->x;
                }

                set
                {
                    ((__Internal*)__Instance)->x = value;
                }
            }

            public int Y
            {
                get
                {
                    return ((__Internal*)__Instance)->y;
                }

                set
                {
                    ((__Internal*)__Instance)->y = value;
                }
            }

            #region Virtual table interop

            // AtlasRegion
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.AtlasRegion.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class Atlas : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 80)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _pages;
                internal global::spine_cpp.Spine.Vector.__Internal _regions;
                internal __IntPtr _textureLoader;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Atlas@spine@@QEAA@AEBVString@1@PEAVTextureLoader@1@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr path, __IntPtr textureLoader, bool createTexture);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Atlas@spine@@QEAA@PEBDH0PEAVTextureLoader@1@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string data, int length, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string dir, __IntPtr textureLoader, bool createTexture);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Atlas@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?flipV@Atlas@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void FlipV(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?findRegion@Atlas@spine@@QEAAPEAVAtlasRegion@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindRegion(__IntPtr __instance, __IntPtr name);
            }

            internal static new Atlas __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Atlas(native.ToPointer(), skipVTables);
            }

            internal static new Atlas __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Atlas)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Atlas __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Atlas)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Atlas __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Atlas(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Atlas.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Atlas(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Atlas(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Atlas(global::spine_cpp.Spine.String path, global::spine_cpp.Spine.TextureLoader textureLoader, bool createTexture)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Atlas.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = path.__Instance;
                var __arg1 = textureLoader is null ? __IntPtr.Zero : textureLoader.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1, createTexture);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Atlas");
            }

            public Atlas(string data, int length, string dir, global::spine_cpp.Spine.TextureLoader textureLoader, bool createTexture)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Atlas.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg3 = textureLoader is null ? __IntPtr.Zero : textureLoader.__Instance;
                __Internal.ctor(__Instance, data, length, dir, __arg3, createTexture);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Atlas");
            }

            public Atlas(global::spine_cpp.Spine.Atlas _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Atlas.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Atlas");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void FlipV()
            {
                __Internal.FlipV(__Instance);
            }

            /// <summary>
            /// <para>Returns the first region found with the specified name. This method uses String comparison to find the region, so the result</para>
            /// <para>should be cached rather than calling this method multiple times.</para>
            /// </summary>
            /// <returns>The region, or NULL.</returns>
            public global::spine_cpp.Spine.AtlasRegion FindRegion(global::spine_cpp.Spine.String name)
            {
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                var ___ret = __Internal.FindRegion(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.AtlasRegion.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            #region Virtual table interop

            // ~Atlas()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Atlas.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class RTTI : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr _className;
                internal __IntPtr _pBaseRTTI;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0RTTI@spine@@QEAA@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string className);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0RTTI@spine@@QEAA@PEBDAEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string className, __IntPtr baseRTTI);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?isExactly@RTTI@spine@@QEBA_NAEBV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsExactly(__IntPtr __instance, __IntPtr rtti);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?instanceOf@RTTI@spine@@QEBA_NAEBV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool InstanceOf(__IntPtr __instance, __IntPtr rtti);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getClassName@RTTI@spine@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetClassName(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.RTTI> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.RTTI>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.Spine.RTTI managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.Spine.RTTI managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static RTTI __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new RTTI(native.ToPointer(), skipVTables);
            }

            internal static RTTI __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (RTTI)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static RTTI __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new RTTI(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private RTTI(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected RTTI(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public RTTI(string className)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RTTI.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, className);
            }

            public RTTI(string className, global::spine_cpp.Spine.RTTI baseRTTI)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RTTI.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(baseRTTI, null))
                    throw new global::System.ArgumentNullException("baseRTTI", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = baseRTTI.__Instance;
                __Internal.ctor(__Instance, className, __arg1);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public bool IsExactly(global::spine_cpp.Spine.RTTI rtti)
            {
                if (ReferenceEquals(rtti, null))
                    throw new global::System.ArgumentNullException("rtti", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = rtti.__Instance;
                var ___ret = __Internal.IsExactly(__Instance, __arg0);
                return ___ret;
            }

            public bool InstanceOf(global::spine_cpp.Spine.RTTI rtti)
            {
                if (ReferenceEquals(rtti, null))
                    throw new global::System.ArgumentNullException("rtti", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = rtti.__Instance;
                var ___ret = __Internal.InstanceOf(__Instance, __arg0);
                return ___ret;
            }

            public static explicit operator global::spine_cpp.Spine.RTTI(string className)
            {
                return new global::spine_cpp.Spine.RTTI(className);
            }

            public string ClassName
            {
                get
                {
                    var ___ret = __Internal.GetClassName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }
        }
    }

    namespace Spine
    {
        public unsafe abstract partial class AttachmentLoader : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AttachmentLoader@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AttachmentLoader@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new AttachmentLoader __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AttachmentLoaderInternal(native.ToPointer(), skipVTables);
            }

            internal static new AttachmentLoader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AttachmentLoader)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new AttachmentLoader __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AttachmentLoader)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AttachmentLoader __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AttachmentLoaderInternal(native, skipVTables);
            }

            protected AttachmentLoader(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected AttachmentLoader()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AttachmentLoader.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AttachmentLoader");
            }

            protected AttachmentLoader(global::spine_cpp.Spine.AttachmentLoader _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AttachmentLoader.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AttachmentLoader");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <returns>May be NULL to not load any attachment.</returns>
            public abstract global::spine_cpp.Spine.RegionAttachment NewRegionAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.String path, global::spine_cpp.Spine.Sequence sequence);

            /// <returns>May be NULL to not load any attachment.</returns>
            public abstract global::spine_cpp.Spine.MeshAttachment NewMeshAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.String path, global::spine_cpp.Spine.Sequence sequence);

            /// <returns>May be NULL to not load any attachment.</returns>
            public abstract global::spine_cpp.Spine.BoundingBoxAttachment NewBoundingBoxAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name);

            /// <returns>May be NULL to not load any attachment</returns>
            public abstract global::spine_cpp.Spine.PathAttachment NewPathAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name);

            public abstract global::spine_cpp.Spine.PointAttachment NewPointAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name);

            public abstract global::spine_cpp.Spine.ClippingAttachment NewClippingAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name);

            public abstract void ConfigureAttachment(global::spine_cpp.Spine.Attachment attachment);

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_AttachmentLoader_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public virtual global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    var ___GetRTTIDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 1);
                    var ___ret = ___GetRTTIDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.RTTI.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            #region Virtual table interop

            // virtual ~AttachmentLoader()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.AttachmentLoader.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.AttachmentLoader.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // RegionAttachment *newRegionAttachment(Skin &skin, const String &name, const String &path, Sequence *sequence) = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr _NewRegionAttachmentDelegateInstance;

            private static __IntPtr _NewRegionAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name, __IntPtr path, __IntPtr sequence)
            {
                var __target = global::spine_cpp.Spine.AttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var __result2 = global::spine_cpp.Spine.String.__GetOrCreateInstance(path, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Sequence.__GetOrCreateInstance(sequence, false, skipVTables: true);
                var ___ret = __target.NewRegionAttachment(__result0, __result1, __result2, __result3);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // MeshAttachment *newMeshAttachment(Skin &skin, const String &name, const String &path, Sequence *sequence) = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr _NewMeshAttachmentDelegateInstance;

            private static __IntPtr _NewMeshAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name, __IntPtr path, __IntPtr sequence)
            {
                var __target = global::spine_cpp.Spine.AttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var __result2 = global::spine_cpp.Spine.String.__GetOrCreateInstance(path, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Sequence.__GetOrCreateInstance(sequence, false, skipVTables: true);
                var ___ret = __target.NewMeshAttachment(__result0, __result1, __result2, __result3);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // BoundingBoxAttachment *newBoundingBoxAttachment(Skin &skin, const String &name) = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr _NewBoundingBoxAttachmentDelegateInstance;

            private static __IntPtr _NewBoundingBoxAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name)
            {
                var __target = global::spine_cpp.Spine.AttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var ___ret = __target.NewBoundingBoxAttachment(__result0, __result1);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // PathAttachment *newPathAttachment(Skin &skin, const String &name) = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr _NewPathAttachmentDelegateInstance;

            private static __IntPtr _NewPathAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name)
            {
                var __target = global::spine_cpp.Spine.AttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var ___ret = __target.NewPathAttachment(__result0, __result1);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // PointAttachment *newPointAttachment(Skin &skin, const String &name) = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr _NewPointAttachmentDelegateInstance;

            private static __IntPtr _NewPointAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name)
            {
                var __target = global::spine_cpp.Spine.AttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var ___ret = __target.NewPointAttachment(__result0, __result1);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // ClippingAttachment *newClippingAttachment(Skin &skin, const String &name) = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr _NewClippingAttachmentDelegateInstance;

            private static __IntPtr _NewClippingAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name)
            {
                var __target = global::spine_cpp.Spine.AttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var ___ret = __target.NewClippingAttachment(__result0, __result1);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // void configureAttachment(Attachment *attachment) = 0
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr _ConfigureAttachmentDelegateInstance;

            private static void _ConfigureAttachmentDelegateHook(__IntPtr __instance, __IntPtr attachment)
            {
                var __target = global::spine_cpp.Spine.AttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(attachment, false, skipVTables: true);
                __target.ConfigureAttachment(__result0);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[9];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _NewRegionAttachmentDelegateInstance += _NewRegionAttachmentDelegateHook;
                    _NewMeshAttachmentDelegateInstance += _NewMeshAttachmentDelegateHook;
                    _NewBoundingBoxAttachmentDelegateInstance += _NewBoundingBoxAttachmentDelegateHook;
                    _NewPathAttachmentDelegateInstance += _NewPathAttachmentDelegateHook;
                    _NewPointAttachmentDelegateInstance += _NewPointAttachmentDelegateHook;
                    _NewClippingAttachmentDelegateInstance += _NewClippingAttachmentDelegateHook;
                    _ConfigureAttachmentDelegateInstance += _ConfigureAttachmentDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_NewRegionAttachmentDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_NewMeshAttachmentDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_NewBoundingBoxAttachmentDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_NewPathAttachmentDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_NewPointAttachmentDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_NewClippingAttachmentDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_ConfigureAttachmentDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 9, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 9, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                VTables.Methods[0] = new Delegate[9];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class AttachmentLoaderInternal : global::spine_cpp.Spine.AttachmentLoader, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal AttachmentLoaderInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal AttachmentLoaderInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <returns>May be NULL to not load any attachment.</returns>
            public override global::spine_cpp.Spine.RegionAttachment NewRegionAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.String path, global::spine_cpp.Spine.Sequence sequence)
            {
                var ___NewRegionAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr>(0, 2);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = path.__Instance;
                var __arg3 = sequence is null ? __IntPtr.Zero : sequence.__Instance;
                var ___ret = ___NewRegionAttachmentDelegate(__Instance, __arg0, __arg1, __arg2, __arg3);
                var __result0 = global::spine_cpp.Spine.RegionAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL to not load any attachment.</returns>
            public override global::spine_cpp.Spine.MeshAttachment NewMeshAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.String path, global::spine_cpp.Spine.Sequence sequence)
            {
                var ___NewMeshAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr>(0, 3);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = path.__Instance;
                var __arg3 = sequence is null ? __IntPtr.Zero : sequence.__Instance;
                var ___ret = ___NewMeshAttachmentDelegate(__Instance, __arg0, __arg1, __arg2, __arg3);
                var __result0 = global::spine_cpp.Spine.MeshAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL to not load any attachment.</returns>
            public override global::spine_cpp.Spine.BoundingBoxAttachment NewBoundingBoxAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name)
            {
                var ___NewBoundingBoxAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr>(0, 4);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var ___ret = ___NewBoundingBoxAttachmentDelegate(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.BoundingBoxAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL to not load any attachment</returns>
            public override global::spine_cpp.Spine.PathAttachment NewPathAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name)
            {
                var ___NewPathAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr>(0, 5);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var ___ret = ___NewPathAttachmentDelegate(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.PathAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override global::spine_cpp.Spine.PointAttachment NewPointAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name)
            {
                var ___NewPointAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr>(0, 6);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var ___ret = ___NewPointAttachmentDelegate(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.PointAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override global::spine_cpp.Spine.ClippingAttachment NewClippingAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name)
            {
                var ___NewClippingAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr>(0, 7);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var ___ret = ___NewClippingAttachmentDelegate(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.ClippingAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override void ConfigureAttachment(global::spine_cpp.Spine.Attachment attachment)
            {
                var ___ConfigureAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr>(0, 8);
                var __arg0 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
                ___ConfigureAttachmentDelegate(__Instance, __arg0);
            }
        }
    }

    namespace Spine
    {
        /// <summary>
        /// <para>An AttachmentLoader that configures attachments using texture regions from an Atlas.</para>
        /// <para>See http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data about Loading Skeleton Data in the Spine Runtimes Guide.</para>
        /// </summary>
        public unsafe partial class AtlasAttachmentLoader : global::spine_cpp.Spine.AttachmentLoader, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _atlas;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AtlasAttachmentLoader@spine@@QEAA@PEAVAtlas@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr atlas);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AtlasAttachmentLoader@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?findRegion@AtlasAttachmentLoader@spine@@QEAAPEAVAtlasRegion@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindRegion(__IntPtr __instance, __IntPtr name);
            }

            internal static new AtlasAttachmentLoader __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AtlasAttachmentLoader(native.ToPointer(), skipVTables);
            }

            internal static new AtlasAttachmentLoader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AtlasAttachmentLoader)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new AtlasAttachmentLoader __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AtlasAttachmentLoader)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AtlasAttachmentLoader __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AtlasAttachmentLoader(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.AtlasAttachmentLoader.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private AtlasAttachmentLoader(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected AtlasAttachmentLoader(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public AtlasAttachmentLoader(global::spine_cpp.Spine.Atlas atlas)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AtlasAttachmentLoader.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = atlas is null ? __IntPtr.Zero : atlas.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AtlasAttachmentLoader");
            }

            public AtlasAttachmentLoader(global::spine_cpp.Spine.AtlasAttachmentLoader _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AtlasAttachmentLoader.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AtlasAttachmentLoader");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override global::spine_cpp.Spine.RegionAttachment NewRegionAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.String path, global::spine_cpp.Spine.Sequence sequence)
            {
                var ___NewRegionAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr>(0, 2);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = path.__Instance;
                var __arg3 = sequence is null ? __IntPtr.Zero : sequence.__Instance;
                var ___ret = ___NewRegionAttachmentDelegate(__Instance, __arg0, __arg1, __arg2, __arg3);
                var __result0 = global::spine_cpp.Spine.RegionAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override global::spine_cpp.Spine.MeshAttachment NewMeshAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.String path, global::spine_cpp.Spine.Sequence sequence)
            {
                var ___NewMeshAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr>(0, 3);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = path.__Instance;
                var __arg3 = sequence is null ? __IntPtr.Zero : sequence.__Instance;
                var ___ret = ___NewMeshAttachmentDelegate(__Instance, __arg0, __arg1, __arg2, __arg3);
                var __result0 = global::spine_cpp.Spine.MeshAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override global::spine_cpp.Spine.BoundingBoxAttachment NewBoundingBoxAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name)
            {
                var ___NewBoundingBoxAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr>(0, 4);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var ___ret = ___NewBoundingBoxAttachmentDelegate(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.BoundingBoxAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override global::spine_cpp.Spine.PathAttachment NewPathAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name)
            {
                var ___NewPathAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr>(0, 5);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var ___ret = ___NewPathAttachmentDelegate(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.PathAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override global::spine_cpp.Spine.PointAttachment NewPointAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name)
            {
                var ___NewPointAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr>(0, 6);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var ___ret = ___NewPointAttachmentDelegate(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.PointAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override global::spine_cpp.Spine.ClippingAttachment NewClippingAttachment(global::spine_cpp.Spine.Skin skin, global::spine_cpp.Spine.String name)
            {
                var ___NewClippingAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr>(0, 7);
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skin.__Instance;
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var ___ret = ___NewClippingAttachmentDelegate(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.ClippingAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override void ConfigureAttachment(global::spine_cpp.Spine.Attachment attachment)
            {
                var ___ConfigureAttachmentDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr>(0, 8);
                var __arg0 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
                ___ConfigureAttachmentDelegate(__Instance, __arg0);
            }

            public global::spine_cpp.Spine.AtlasRegion FindRegion(global::spine_cpp.Spine.String name)
            {
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                var ___ret = __Internal.FindRegion(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.AtlasRegion.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public static explicit operator global::spine_cpp.Spine.AtlasAttachmentLoader(global::spine_cpp.Spine.Atlas atlas)
            {
                return new global::spine_cpp.Spine.AtlasAttachmentLoader(atlas);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_AtlasAttachmentLoader_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            #region Virtual table interop

            // AtlasAttachmentLoader
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.AtlasAttachmentLoader.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.AtlasAttachmentLoader.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // RegionAttachment *newRegionAttachment(Skin &skin, const String &name, const String &path, Sequence *sequence)
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr _NewRegionAttachmentDelegateInstance;

            private static __IntPtr _NewRegionAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name, __IntPtr path, __IntPtr sequence)
            {
                var __target = global::spine_cpp.Spine.AtlasAttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var __result2 = global::spine_cpp.Spine.String.__GetOrCreateInstance(path, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Sequence.__GetOrCreateInstance(sequence, false, skipVTables: true);
                var ___ret = __target.NewRegionAttachment(__result0, __result1, __result2, __result3);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // MeshAttachment *newMeshAttachment(Skin &skin, const String &name, const String &path, Sequence *sequence)
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr _NewMeshAttachmentDelegateInstance;

            private static __IntPtr _NewMeshAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name, __IntPtr path, __IntPtr sequence)
            {
                var __target = global::spine_cpp.Spine.AtlasAttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var __result2 = global::spine_cpp.Spine.String.__GetOrCreateInstance(path, false, skipVTables: true);
                var __result3 = global::spine_cpp.Spine.Sequence.__GetOrCreateInstance(sequence, false, skipVTables: true);
                var ___ret = __target.NewMeshAttachment(__result0, __result1, __result2, __result3);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // BoundingBoxAttachment *newBoundingBoxAttachment(Skin &skin, const String &name)
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr _NewBoundingBoxAttachmentDelegateInstance;

            private static __IntPtr _NewBoundingBoxAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name)
            {
                var __target = global::spine_cpp.Spine.AtlasAttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var ___ret = __target.NewBoundingBoxAttachment(__result0, __result1);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // PathAttachment *newPathAttachment(Skin &skin, const String &name)
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr _NewPathAttachmentDelegateInstance;

            private static __IntPtr _NewPathAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name)
            {
                var __target = global::spine_cpp.Spine.AtlasAttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var ___ret = __target.NewPathAttachment(__result0, __result1);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // PointAttachment *newPointAttachment(Skin &skin, const String &name)
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr _NewPointAttachmentDelegateInstance;

            private static __IntPtr _NewPointAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name)
            {
                var __target = global::spine_cpp.Spine.AtlasAttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var ___ret = __target.NewPointAttachment(__result0, __result1);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // ClippingAttachment *newClippingAttachment(Skin &skin, const String &name)
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr___IntPtr___IntPtr _NewClippingAttachmentDelegateInstance;

            private static __IntPtr _NewClippingAttachmentDelegateHook(__IntPtr __instance, __IntPtr skin, __IntPtr name)
            {
                var __target = global::spine_cpp.Spine.AtlasAttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(skin, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(name, false, skipVTables: true);
                var ___ret = __target.NewClippingAttachment(__result0, __result1);
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // void configureAttachment(Attachment *attachment)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr _ConfigureAttachmentDelegateInstance;

            private static void _ConfigureAttachmentDelegateHook(__IntPtr __instance, __IntPtr attachment)
            {
                var __target = global::spine_cpp.Spine.AtlasAttachmentLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(attachment, false, skipVTables: true);
                __target.ConfigureAttachment(__result0);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[9];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _NewRegionAttachmentDelegateInstance += _NewRegionAttachmentDelegateHook;
                    _NewMeshAttachmentDelegateInstance += _NewMeshAttachmentDelegateHook;
                    _NewBoundingBoxAttachmentDelegateInstance += _NewBoundingBoxAttachmentDelegateHook;
                    _NewPathAttachmentDelegateInstance += _NewPathAttachmentDelegateHook;
                    _NewPointAttachmentDelegateInstance += _NewPointAttachmentDelegateHook;
                    _NewClippingAttachmentDelegateInstance += _NewClippingAttachmentDelegateHook;
                    _ConfigureAttachmentDelegateInstance += _ConfigureAttachmentDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_NewRegionAttachmentDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_NewMeshAttachmentDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_NewBoundingBoxAttachmentDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_NewPathAttachmentDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_NewPointAttachmentDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_NewClippingAttachmentDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_ConfigureAttachmentDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 9, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 9, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                VTables.Methods[0] = new Delegate[9];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe abstract partial class Attachment : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 48)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal int _refCount;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Attachment@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Attachment@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?reference@Attachment@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Reference(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?dereference@Attachment@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Dereference(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getName@Attachment@spine@@QEBAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getRefCount@Attachment@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetRefCount(__IntPtr __instance);
            }

            internal static new Attachment __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AttachmentInternal(native.ToPointer(), skipVTables);
            }

            internal static new Attachment __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Attachment)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Attachment __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Attachment)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Attachment __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AttachmentInternal(native, skipVTables);
            }

            protected Attachment(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected Attachment(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Attachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Attachment");
            }

            protected Attachment(global::spine_cpp.Spine.Attachment _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Attachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Attachment");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Reference()
            {
                __Internal.Reference(__Instance);
            }

            public void Dereference()
            {
                __Internal.Dereference(__Instance);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_Attachment_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public virtual global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    var ___GetRTTIDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 1);
                    var ___ret = ___GetRTTIDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.RTTI.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public abstract global::spine_cpp.Spine.Attachment Copy
            {
                get;
            }

            public int RefCount
            {
                get
                {
                    var ___ret = __Internal.GetRefCount(__Instance);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // virtual ~Attachment()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Attachment.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Attachment.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // Attachment *copy() = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Attachment.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class AttachmentInternal : global::spine_cpp.Spine.Attachment, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal AttachmentInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal AttachmentInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override global::spine_cpp.Spine.Attachment Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___CopyDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }
        }
    }

    namespace Spine
    {
        public unsafe abstract partial class Timeline : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 80)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Timeline@spine@@QEAA@_K0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong frameEntries);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Timeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setPropertyIds@Timeline@spine@@IEAAXQEA_J_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPropertyIds(__IntPtr __instance, long[] propertyIds, ulong propertyIdsCount);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getFrameEntries@Timeline@spine@@QEAA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetFrameEntries(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getFrameCount@Timeline@spine@@QEAA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetFrameCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getDuration@Timeline@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetDuration(__IntPtr __instance);
            }

            internal static new Timeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TimelineInternal(native.ToPointer(), skipVTables);
            }

            internal static new Timeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Timeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Timeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Timeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Timeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TimelineInternal(native, skipVTables);
            }

            protected Timeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected Timeline(ulong frameCount, ulong frameEntries)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Timeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, frameEntries);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Timeline");
            }

            protected Timeline(global::spine_cpp.Spine.Timeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Timeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Timeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            protected void SetPropertyIds(long[] propertyIds, ulong propertyIdsCount)
            {
                __Internal.SetPropertyIds(__Instance, propertyIds, propertyIdsCount);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_Timeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected ulong _frameEntries
            {
                get
                {
                    return ((__Internal*)__Instance)->_frameEntries;
                }

                set
                {
                    ((__Internal*)__Instance)->_frameEntries = value;
                }
            }

            public virtual global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    var ___GetRTTIDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 1);
                    var ___ret = ___GetRTTIDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.RTTI.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public ulong FrameEntries
            {
                get
                {
                    var ___ret = __Internal.GetFrameEntries(__Instance);
                    return ___ret;
                }
            }

            public ulong FrameCount
            {
                get
                {
                    var ___ret = __Internal.GetFrameCount(__Instance);
                    return ___ret;
                }
            }

            public float Duration
            {
                get
                {
                    var ___ret = __Internal.GetDuration(__Instance);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // virtual ~Timeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Timeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Timeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[4];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class TimelineInternal : global::spine_cpp.Spine.Timeline, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal TimelineInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal TimelineInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }
        }
    }

    namespace Spine
    {
        public unsafe partial class AttachmentTimeline : global::spine_cpp.Spine.Timeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal int _slotIndex;
                internal global::spine_cpp.Spine.Vector.__Internal _attachmentNames;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AttachmentTimeline@spine@@QEAA@_KH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, int slotIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AttachmentTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setFrame@AttachmentTimeline@spine@@QEAAXHMAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, int frame, float time, __IntPtr attachmentName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAttachment@AttachmentTimeline@spine@@IEAAXAEAVSkeleton@2@AEAVSlot@2@PEAVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAttachment(__IntPtr __instance, __IntPtr skeleton, __IntPtr slot, __IntPtr attachmentName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSlotIndex@AttachmentTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetSlotIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSlotIndex@AttachmentTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSlotIndex(__IntPtr __instance, int inValue);
            }

            internal static new AttachmentTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AttachmentTimeline(native.ToPointer(), skipVTables);
            }

            internal static new AttachmentTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AttachmentTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new AttachmentTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AttachmentTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AttachmentTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AttachmentTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.AttachmentTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private AttachmentTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected AttachmentTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public AttachmentTimeline(ulong frameCount, int slotIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AttachmentTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, slotIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AttachmentTimeline");
            }

            public AttachmentTimeline(global::spine_cpp.Spine.AttachmentTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AttachmentTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AttachmentTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Sets the time and value of the specified keyframe.</summary>
            public void SetFrame(int frame, float time, global::spine_cpp.Spine.String attachmentName)
            {
                if (ReferenceEquals(attachmentName, null))
                    throw new global::System.ArgumentNullException("attachmentName", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = attachmentName.__Instance;
                __Internal.SetFrame(__Instance, frame, time, __arg2);
            }

            protected void SetAttachment(global::spine_cpp.Spine.Skeleton skeleton, global::spine_cpp.Spine.Slot slot, global::spine_cpp.Spine.String attachmentName)
            {
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                if (ReferenceEquals(slot, null))
                    throw new global::System.ArgumentNullException("slot", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = slot.__Instance;
                var __arg2 = attachmentName is null ? __IntPtr.Zero : attachmentName.__Instance;
                __Internal.SetAttachment(__Instance, __arg0, __arg1, __arg2);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_AttachmentTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected int _slotIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_slotIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_slotIndex = value;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int SlotIndex
            {
                get
                {
                    var ___ret = __Internal.GetSlotIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSlotIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~AttachmentTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.AttachmentTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.AttachmentTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[4];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe abstract partial class Updatable : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Updatable@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Updatable@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new Updatable __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new UpdatableInternal(native.ToPointer(), skipVTables);
            }

            internal static new Updatable __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Updatable)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Updatable __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Updatable)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Updatable __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new UpdatableInternal(native, skipVTables);
            }

            protected Updatable(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected Updatable()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Updatable.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Updatable");
            }

            protected Updatable(global::spine_cpp.Spine.Updatable _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Updatable.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Updatable");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract void Update();

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_Updatable_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public virtual global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    var ___GetRTTIDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 1);
                    var ___ret = ___GetRTTIDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.RTTI.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public abstract bool Active
            {
                get;

                set;
            }

            #region Virtual table interop

            // virtual ~Updatable()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Updatable.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Updatable.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void update() = 0
            private static global::spine_cpp.Delegates.Action___IntPtr _UpdateDelegateInstance;

            private static void _UpdateDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Updatable.__GetInstance(__instance);
                __target.Update();
            }

            // bool isActive() = 0
            private static global::spine_cpp.Delegates.Func_bool___IntPtr _IsActiveDelegateInstance;

            private static bool _IsActiveDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Updatable.__GetInstance(__instance);
                var ___ret = __target.Active;
                return ___ret;
            }

            // void setActive(bool inValue) = 0
            private static global::spine_cpp.Delegates.Action___IntPtr_bool _SetActiveDelegateInstance;

            private static void _SetActiveDelegateHook(__IntPtr __instance, bool inValue)
            {
                var __target = global::spine_cpp.Spine.Updatable.__GetInstance(__instance);
                __target.Active = inValue;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _UpdateDelegateInstance += _UpdateDelegateHook;
                    _IsActiveDelegateInstance += _IsActiveDelegateHook;
                    _SetActiveDelegateInstance += _SetActiveDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_IsActiveDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetActiveDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class UpdatableInternal : global::spine_cpp.Spine.Updatable, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal UpdatableInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal UpdatableInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override void Update()
            {
                var ___UpdateDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr>(0, 2);
                ___UpdateDelegate(__Instance);
            }

            public override bool Active
            {
                get
                {
                    var ___IsActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_bool___IntPtr>(0, 3);
                    var ___ret = ___IsActiveDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_bool>(0, 4);
                    ___SetActiveDelegate(__Instance, value);
                }
            }
        }
    }

    namespace Spine
    {
        /// <summary>Stores a bone's current pose.</summary>
        /// <remarks>
        /// <para>A bone has a local transform which is used to compute its world transform. A bone also has an applied transform, which is a</para>
        /// <para>local transform that can be applied to compute the world transform. The local transform and applied transform may differ if a</para>
        /// <para>constraint or application code modifies the world transform after it was computed from the local transform.</para>
        /// </remarks>
        public unsafe partial class Bone : global::spine_cpp.Spine.Updatable, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 152)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _data;
                internal __IntPtr _skeleton;
                internal __IntPtr _parent;
                internal global::spine_cpp.Spine.Vector.__Internal _children;
                internal float _x;
                internal float _y;
                internal float _rotation;
                internal float _scaleX;
                internal float _scaleY;
                internal float _shearX;
                internal float _shearY;
                internal float _ax;
                internal float _ay;
                internal float _arotation;
                internal float _ascaleX;
                internal float _ascaleY;
                internal float _ashearX;
                internal float _ashearY;
                internal float _a;
                internal float _b;
                internal float _worldX;
                internal float _c;
                internal float _d;
                internal float _worldY;
                internal byte _sorted;
                internal byte _active;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Bone@spine@@QEAA@AEAVBoneData@1@AEAVSkeleton@1@PEAV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr data, __IntPtr skeleton, __IntPtr parent);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Bone@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?updateWorldTransform@Bone@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateWorldTransform(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?updateWorldTransform@Bone@spine@@QEAAXMMMMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateWorldTransform(__IntPtr __instance, float x, float y, float rotation, float scaleX, float scaleY, float shearX, float shearY);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?updateAppliedTransform@Bone@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateAppliedTransform(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setToSetupPose@Bone@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetToSetupPose(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?worldToLocal@Bone@spine@@QEAAXMMAEAM0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void WorldToLocal(__IntPtr __instance, float worldX, float worldY, float* outLocalX, float* outLocalY);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?localToWorld@Bone@spine@@QEAAXMMAEAM0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void LocalToWorld(__IntPtr __instance, float localX, float localY, float* outWorldX, float* outWorldY);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?worldToLocalRotation@Bone@spine@@QEAAMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float WorldToLocalRotation(__IntPtr __instance, float worldRotation);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?localToWorldRotation@Bone@spine@@QEAAMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float LocalToWorldRotation(__IntPtr __instance, float localRotation);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?rotateWorld@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RotateWorld(__IntPtr __instance, float degrees);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?isYDown@Bone@spine@@SA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsYDown();

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setYDown@Bone@spine@@SAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetYDown(bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getWorldToLocalRotationX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWorldToLocalRotationX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getWorldToLocalRotationY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWorldToLocalRotationY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getData@Bone@spine@@QEAAAEAVBoneData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSkeleton@Bone@spine@@QEAAAEAVSkeleton@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSkeleton(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getParent@Bone@spine@@QEAAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetParent(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setX@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setY@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getRotation@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetRotation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setRotation@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRotation(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getScaleX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScaleX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setScaleX@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScaleX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getScaleY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScaleY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setScaleY@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScaleY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getShearX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetShearX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setShearX@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetShearX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getShearY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetShearY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setShearY@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetShearY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAppliedRotation@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAppliedRotation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAppliedRotation@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAppliedRotation(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAX@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAY@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAScaleX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAScaleX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAScaleX@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAScaleX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAScaleY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAScaleY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAScaleY@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAScaleY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAShearX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAShearX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAShearX@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAShearX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAShearY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetAShearY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAShearY@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAShearY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getA@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetA(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setA@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetA(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getB@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetB(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setB@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetB(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getC@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetC(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setC@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetC(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getD@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetD(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setD@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetD(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getWorldX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWorldX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setWorldX@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWorldX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getWorldY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWorldY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setWorldY@Bone@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWorldY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getWorldRotationX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWorldRotationX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getWorldRotationY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWorldRotationY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getWorldScaleX@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWorldScaleX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getWorldScaleY@Bone@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWorldScaleY(__IntPtr __instance);
            }

            internal static new Bone __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Bone(native.ToPointer(), skipVTables);
            }

            internal static new Bone __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Bone)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Bone __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Bone)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Bone __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Bone(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Bone.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Bone(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Bone(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            /// <param name="parent">May be NULL.</param>
            public Bone(global::spine_cpp.Spine.BoneData data, global::spine_cpp.Spine.Skeleton skeleton, global::spine_cpp.Spine.Bone parent)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Bone.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(data, null))
                    throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = data.__Instance;
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = skeleton.__Instance;
                var __arg2 = parent is null ? __IntPtr.Zero : parent.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1, __arg2);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Bone");
            }

            public Bone(global::spine_cpp.Spine.Bone _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Bone.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Bone");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Same as updateWorldTransform. This method exists for Bone to implement Spine::Updatable.</summary>
            public override void Update()
            {
                var ___UpdateDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr>(0, 2);
                ___UpdateDelegate(__Instance);
            }

            /// <summary>Computes the world transform using the parent bone and this bone's local transform.</summary>
            public void UpdateWorldTransform()
            {
                __Internal.UpdateWorldTransform(__Instance);
            }

            /// <summary>Computes the world transform using the parent bone and the specified local transform.</summary>
            public void UpdateWorldTransform(float x, float y, float rotation, float scaleX, float scaleY, float shearX, float shearY)
            {
                __Internal.UpdateWorldTransform(__Instance, x, y, rotation, scaleX, scaleY, shearX, shearY);
            }

            /// <summary>
            /// <para>Computes the individual applied transform values from the world transform. This can be useful to perform processing using</para>
            /// <para>the applied transform after the world transform has been modified directly (eg, by a constraint)..</para>
            /// </summary>
            /// <remarks>Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation.</remarks>
            public void UpdateAppliedTransform()
            {
                __Internal.UpdateAppliedTransform(__Instance);
            }

            public void SetToSetupPose()
            {
                __Internal.SetToSetupPose(__Instance);
            }

            public void WorldToLocal(float worldX, float worldY, ref float outLocalX, ref float outLocalY)
            {
                fixed (float* __outLocalX2 = &outLocalX)
                {
                    var __arg2 = __outLocalX2;
                    fixed (float* __outLocalY3 = &outLocalY)
                    {
                        var __arg3 = __outLocalY3;
                        __Internal.WorldToLocal(__Instance, worldX, worldY, __arg2, __arg3);
                    }
                }
            }

            public void LocalToWorld(float localX, float localY, ref float outWorldX, ref float outWorldY)
            {
                fixed (float* __outWorldX2 = &outWorldX)
                {
                    var __arg2 = __outWorldX2;
                    fixed (float* __outWorldY3 = &outWorldY)
                    {
                        var __arg3 = __outWorldY3;
                        __Internal.LocalToWorld(__Instance, localX, localY, __arg2, __arg3);
                    }
                }
            }

            public float WorldToLocalRotation(float worldRotation)
            {
                var ___ret = __Internal.WorldToLocalRotation(__Instance, worldRotation);
                return ___ret;
            }

            public float LocalToWorldRotation(float localRotation)
            {
                var ___ret = __Internal.LocalToWorldRotation(__Instance, localRotation);
                return ___ret;
            }

            /// <summary>Rotates the world transform the specified amount and sets isAppliedValid to false.</summary>
            /// <param name="degrees">Degrees.</param>
            public void RotateWorld(float degrees)
            {
                __Internal.RotateWorld(__Instance, degrees);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_Bone_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public static bool yDown
            {
                get
                {
                    var ___ret = __Internal.IsYDown();
                    return ___ret;
                }

                set
                {
                    __Internal.SetYDown(value);
                }
            }

            public float WorldToLocalRotationX
            {
                get
                {
                    var ___ret = __Internal.GetWorldToLocalRotationX(__Instance);
                    return ___ret;
                }
            }

            public float WorldToLocalRotationY
            {
                get
                {
                    var ___ret = __Internal.GetWorldToLocalRotationY(__Instance);
                    return ___ret;
                }
            }

            public global::spine_cpp.Spine.BoneData Data
            {
                get
                {
                    var ___ret = __Internal.GetData(__Instance);
                    var __result0 = global::spine_cpp.Spine.BoneData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Skeleton Skeleton
            {
                get
                {
                    var ___ret = __Internal.GetSkeleton(__Instance);
                    var __result0 = global::spine_cpp.Spine.Skeleton.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Bone Parent
            {
                get
                {
                    var ___ret = __Internal.GetParent(__Instance);
                    var __result0 = global::spine_cpp.Spine.Bone.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>The local X translation.</summary>
            public float X
            {
                get
                {
                    var ___ret = __Internal.GetX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetX(__Instance, value);
                }
            }

            /// <summary>The local Y translation.</summary>
            public float Y
            {
                get
                {
                    var ___ret = __Internal.GetY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetY(__Instance, value);
                }
            }

            /// <summary>The local rotation.</summary>
            public float Rotation
            {
                get
                {
                    var ___ret = __Internal.GetRotation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetRotation(__Instance, value);
                }
            }

            /// <summary>The local scaleX.</summary>
            public float ScaleX
            {
                get
                {
                    var ___ret = __Internal.GetScaleX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetScaleX(__Instance, value);
                }
            }

            /// <summary>The local scaleY.</summary>
            public float ScaleY
            {
                get
                {
                    var ___ret = __Internal.GetScaleY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetScaleY(__Instance, value);
                }
            }

            /// <summary>The local shearX.</summary>
            public float ShearX
            {
                get
                {
                    var ___ret = __Internal.GetShearX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetShearX(__Instance, value);
                }
            }

            /// <summary>The local shearY.</summary>
            public float ShearY
            {
                get
                {
                    var ___ret = __Internal.GetShearY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetShearY(__Instance, value);
                }
            }

            /// <summary>The rotation, as calculated by any constraints.</summary>
            public float AppliedRotation
            {
                get
                {
                    var ___ret = __Internal.GetAppliedRotation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAppliedRotation(__Instance, value);
                }
            }

            /// <summary>The applied local x translation.</summary>
            public float AX
            {
                get
                {
                    var ___ret = __Internal.GetAX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAX(__Instance, value);
                }
            }

            /// <summary>The applied local y translation.</summary>
            public float AY
            {
                get
                {
                    var ___ret = __Internal.GetAY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAY(__Instance, value);
                }
            }

            /// <summary>The applied local scaleX.</summary>
            public float AScaleX
            {
                get
                {
                    var ___ret = __Internal.GetAScaleX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAScaleX(__Instance, value);
                }
            }

            /// <summary>The applied local scaleY.</summary>
            public float AScaleY
            {
                get
                {
                    var ___ret = __Internal.GetAScaleY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAScaleY(__Instance, value);
                }
            }

            /// <summary>The applied local shearX.</summary>
            public float AShearX
            {
                get
                {
                    var ___ret = __Internal.GetAShearX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAShearX(__Instance, value);
                }
            }

            /// <summary>The applied local shearY.</summary>
            public float AShearY
            {
                get
                {
                    var ___ret = __Internal.GetAShearY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAShearY(__Instance, value);
                }
            }

            public float A
            {
                get
                {
                    var ___ret = __Internal.GetA(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetA(__Instance, value);
                }
            }

            public float B
            {
                get
                {
                    var ___ret = __Internal.GetB(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetB(__Instance, value);
                }
            }

            public float C
            {
                get
                {
                    var ___ret = __Internal.GetC(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetC(__Instance, value);
                }
            }

            public float D
            {
                get
                {
                    var ___ret = __Internal.GetD(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetD(__Instance, value);
                }
            }

            public float WorldX
            {
                get
                {
                    var ___ret = __Internal.GetWorldX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetWorldX(__Instance, value);
                }
            }

            public float WorldY
            {
                get
                {
                    var ___ret = __Internal.GetWorldY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetWorldY(__Instance, value);
                }
            }

            public float WorldRotationX
            {
                get
                {
                    var ___ret = __Internal.GetWorldRotationX(__Instance);
                    return ___ret;
                }
            }

            public float WorldRotationY
            {
                get
                {
                    var ___ret = __Internal.GetWorldRotationY(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the magnitide (always positive) of the world scale X.</summary>
            public float WorldScaleX
            {
                get
                {
                    var ___ret = __Internal.GetWorldScaleX(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the magnitide (always positive) of the world scale Y.</summary>
            public float WorldScaleY
            {
                get
                {
                    var ___ret = __Internal.GetWorldScaleY(__Instance);
                    return ___ret;
                }
            }

            public override bool Active
            {
                get
                {
                    var ___IsActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_bool___IntPtr>(0, 3);
                    var ___ret = ___IsActiveDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_bool>(0, 4);
                    ___SetActiveDelegate(__Instance, value);
                }
            }

            #region Virtual table interop

            // Bone
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Bone.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Bone.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void update()
            private static global::spine_cpp.Delegates.Action___IntPtr _UpdateDelegateInstance;

            private static void _UpdateDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Bone.__GetInstance(__instance);
                __target.Update();
            }

            // bool isActive()
            private static global::spine_cpp.Delegates.Func_bool___IntPtr _IsActiveDelegateInstance;

            private static bool _IsActiveDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.Bone.__GetInstance(__instance);
                var ___ret = __target.Active;
                return ___ret;
            }

            // void setActive(bool inValue)
            private static global::spine_cpp.Delegates.Action___IntPtr_bool _SetActiveDelegateInstance;

            private static void _SetActiveDelegateHook(__IntPtr __instance, bool inValue)
            {
                var __target = global::spine_cpp.Spine.Bone.__GetInstance(__instance);
                __target.Active = inValue;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _UpdateDelegateInstance += _UpdateDelegateHook;
                    _IsActiveDelegateInstance += _IsActiveDelegateHook;
                    _SetActiveDelegateInstance += _SetActiveDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_IsActiveDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetActiveDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class BoneData : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal int _index;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal __IntPtr _parent;
                internal float _length;
                internal float _x;
                internal float _y;
                internal float _rotation;
                internal float _scaleX;
                internal float _scaleY;
                internal float _shearX;
                internal float _shearY;
                internal global::spine_cpp.Spine.TransformMode _transformMode;
                internal byte _skinRequired;
                internal global::spine_cpp.Spine.Color.__Internal _color;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0BoneData@spine@@QEAA@HAEBVString@1@PEAV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, int index, __IntPtr name, __IntPtr parent);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0BoneData@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getIndex@BoneData@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getName@BoneData@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getParent@BoneData@spine@@QEAAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetParent(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getLength@BoneData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetLength(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setLength@BoneData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetLength(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getX@BoneData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setX@BoneData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getY@BoneData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setY@BoneData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getRotation@BoneData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetRotation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setRotation@BoneData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRotation(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getScaleX@BoneData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScaleX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setScaleX@BoneData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScaleX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getScaleY@BoneData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScaleY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setScaleY@BoneData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScaleY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getShearX@BoneData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetShearX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setShearX@BoneData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetShearX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getShearY@BoneData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetShearY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setShearY@BoneData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetShearY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getTransformMode@BoneData@spine@@QEAA?AW4TransformMode@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::spine_cpp.Spine.TransformMode GetTransformMode(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setTransformMode@BoneData@spine@@QEAAXW4TransformMode@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTransformMode(__IntPtr __instance, global::spine_cpp.Spine.TransformMode inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?isSkinRequired@BoneData@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsSkinRequired(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSkinRequired@BoneData@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSkinRequired(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getColor@BoneData@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);
            }

            internal static new BoneData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new BoneData(native.ToPointer(), skipVTables);
            }

            internal static new BoneData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (BoneData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new BoneData __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (BoneData)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static BoneData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new BoneData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.BoneData.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private BoneData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected BoneData(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public BoneData(int index, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.BoneData parent)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.BoneData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var __arg2 = parent is null ? __IntPtr.Zero : parent.__Instance;
                __Internal.ctor(__Instance, index, __arg1, __arg2);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.BoneData");
            }

            public BoneData(global::spine_cpp.Spine.BoneData _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.BoneData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.BoneData");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>The index of the bone in Skeleton.Bones</summary>
            public int Index
            {
                get
                {
                    var ___ret = __Internal.GetIndex(__Instance);
                    return ___ret;
                }
            }

            /// <summary>The name of the bone, which is unique within the skeleton.</summary>
            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>May be NULL.</summary>
            public global::spine_cpp.Spine.BoneData Parent
            {
                get
                {
                    var ___ret = __Internal.GetParent(__Instance);
                    var __result0 = global::spine_cpp.Spine.BoneData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public float Length
            {
                get
                {
                    var ___ret = __Internal.GetLength(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetLength(__Instance, value);
                }
            }

            /// <summary>Local X translation.</summary>
            public float X
            {
                get
                {
                    var ___ret = __Internal.GetX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetX(__Instance, value);
                }
            }

            /// <summary>Local Y translation.</summary>
            public float Y
            {
                get
                {
                    var ___ret = __Internal.GetY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetY(__Instance, value);
                }
            }

            /// <summary>Local rotation.</summary>
            public float Rotation
            {
                get
                {
                    var ___ret = __Internal.GetRotation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetRotation(__Instance, value);
                }
            }

            /// <summary>Local scaleX.</summary>
            public float ScaleX
            {
                get
                {
                    var ___ret = __Internal.GetScaleX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetScaleX(__Instance, value);
                }
            }

            /// <summary>Local scaleY.</summary>
            public float ScaleY
            {
                get
                {
                    var ___ret = __Internal.GetScaleY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetScaleY(__Instance, value);
                }
            }

            /// <summary>Local shearX.</summary>
            public float ShearX
            {
                get
                {
                    var ___ret = __Internal.GetShearX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetShearX(__Instance, value);
                }
            }

            /// <summary>Local shearY.</summary>
            public float ShearY
            {
                get
                {
                    var ___ret = __Internal.GetShearY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetShearY(__Instance, value);
                }
            }

            /// <summary>The transform mode for how parent world transforms affect this bone.</summary>
            public global::spine_cpp.Spine.TransformMode TransformMode
            {
                get
                {
                    var ___ret = __Internal.GetTransformMode(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetTransformMode(__Instance, value);
                }
            }

            public bool SkinRequired
            {
                get
                {
                    var ___ret = __Internal.IsSkinRequired(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSkinRequired(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // BoneData
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.BoneData.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>An attachment with vertices that are transformed by one or more bones and can be deformed by a slot's vertices.</summary>
        public unsafe abstract partial class VertexAttachment : global::spine_cpp.Spine.Attachment, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 136)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal int _refCount;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal global::spine_cpp.Spine.Vector.__Internal _vertices;
                internal ulong _worldVerticesLength;
                internal __IntPtr _timelineAttachment;
                internal int _id;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0VertexAttachment@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0VertexAttachment@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?computeWorldVertices@VertexAttachment@spine@@QEAAXAEAVSlot@2@PEAM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ComputeWorldVertices(__IntPtr __instance, __IntPtr slot, float* worldVertices);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?copyTo@VertexAttachment@spine@@QEAAXPEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CopyTo(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getId@VertexAttachment@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetId(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getWorldVerticesLength@VertexAttachment@spine@@QEAA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetWorldVerticesLength(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setWorldVerticesLength@VertexAttachment@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWorldVerticesLength(__IntPtr __instance, ulong inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getTimelineAttachment@VertexAttachment@spine@@QEAAPEAVAttachment@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTimelineAttachment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setTimelineAttachment@VertexAttachment@spine@@QEAAXPEAVAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTimelineAttachment(__IntPtr __instance, __IntPtr attachment);
            }

            internal static new VertexAttachment __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new VertexAttachmentInternal(native.ToPointer(), skipVTables);
            }

            internal static new VertexAttachment __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (VertexAttachment)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new VertexAttachment __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (VertexAttachment)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static VertexAttachment __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new VertexAttachmentInternal(native, skipVTables);
            }

            protected VertexAttachment(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected VertexAttachment(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.VertexAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.VertexAttachment");
            }

            protected VertexAttachment(global::spine_cpp.Spine.VertexAttachment _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.VertexAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.VertexAttachment");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void ComputeWorldVertices(global::spine_cpp.Spine.Slot slot, ref float worldVertices)
            {
                if (ReferenceEquals(slot, null))
                    throw new global::System.ArgumentNullException("slot", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slot.__Instance;
                fixed (float* __worldVertices1 = &worldVertices)
                {
                    var __arg1 = __worldVertices1;
                    __Internal.ComputeWorldVertices(__Instance, __arg0, __arg1);
                }
            }

            /// <summary>Transforms local vertices to world coordinates.</summary>
            /// <param name="start">The index of the first Vertices value to transform. Each vertex has 2 values, x and y.</param>
            /// <param name="count">The number of world vertex values to output. Must be less than or equal to WorldVerticesLength - start.</param>
            /// <param name="worldVertices">The output world vertices. Must have a length greater than or equal to offset + count.</param>
            /// <param name="offset">The worldVertices index to begin writing values.</param>
            /// <param name="stride">The number of worldVertices entries between the value pairs written.</param>
            public virtual void ComputeWorldVertices(global::spine_cpp.Spine.Slot slot, ulong start, ulong count, ref float worldVertices, ulong offset, ulong stride)
            {
                var ___ComputeWorldVertices_1Delegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr_ulong_ulong_floatPtr_ulong_ulong>(0, 4);
                if (ReferenceEquals(slot, null))
                    throw new global::System.ArgumentNullException("slot", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slot.__Instance;
                fixed (float* __worldVertices3 = &worldVertices)
                {
                    var __arg3 = __worldVertices3;
                    ___ComputeWorldVertices_1Delegate(__Instance, __arg0, start, count, __arg3, offset, stride);
                }
            }

            public void CopyTo(global::spine_cpp.Spine.VertexAttachment other)
            {
                var __arg0 = other is null ? __IntPtr.Zero : other.__Instance;
                __Internal.CopyTo(__Instance, __arg0);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_VertexAttachment_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected ulong _worldVerticesLength
            {
                get
                {
                    return ((__Internal*)__Instance)->_worldVerticesLength;
                }

                set
                {
                    ((__Internal*)__Instance)->_worldVerticesLength = value;
                }
            }

            protected global::spine_cpp.Spine.Attachment _timelineAttachment
            {
                get
                {
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(((__Internal*)__Instance)->_timelineAttachment, true);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->_timelineAttachment = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            /// <summary>Gets a unique ID for this attachment.</summary>
            public int Id
            {
                get
                {
                    var ___ret = __Internal.GetId(__Instance);
                    return ___ret;
                }
            }

            public ulong WorldVerticesLength
            {
                get
                {
                    var ___ret = __Internal.GetWorldVerticesLength(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetWorldVerticesLength(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.Attachment TimelineAttachment
            {
                get
                {
                    var ___ret = __Internal.GetTimelineAttachment(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetTimelineAttachment(__Instance, __arg0);
                }
            }

            #region Virtual table interop

            // virtual ~VertexAttachment()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.VertexAttachment.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.VertexAttachment.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // Attachment *copy() = 0
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.VertexAttachment.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // void computeWorldVertices(Slot &slot, size_t start, size_t count, float *worldVertices, size_t offset, size_t stride = 2)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_ulong_ulong_floatPtr_ulong_ulong _ComputeWorldVertices_1DelegateInstance;

            private static void _ComputeWorldVertices_1DelegateHook(__IntPtr __instance, __IntPtr slot, ulong start, ulong count, float* worldVertices, ulong offset, ulong stride)
            {
                var __target = global::spine_cpp.Spine.VertexAttachment.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(slot, false, skipVTables: true);
                __target.ComputeWorldVertices(__result0, start, count, ref *worldVertices, offset, stride);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[4];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    _ComputeWorldVertices_1DelegateInstance += _ComputeWorldVertices_1DelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ComputeWorldVertices_1DelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class VertexAttachmentInternal : global::spine_cpp.Spine.VertexAttachment, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal VertexAttachmentInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal VertexAttachmentInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override global::spine_cpp.Spine.Attachment Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___CopyDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }
        }
    }

    namespace Spine
    {
        /// <summary>Attachment that has a polygon for bounds checking.</summary>
        public unsafe partial class BoundingBoxAttachment : global::spine_cpp.Spine.VertexAttachment, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 160)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal int _refCount;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal global::spine_cpp.Spine.Vector.__Internal _vertices;
                internal ulong _worldVerticesLength;
                internal __IntPtr _timelineAttachment;
                internal int _id;
                internal global::spine_cpp.Spine.Color.__Internal _color;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0BoundingBoxAttachment@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0BoundingBoxAttachment@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getColor@BoundingBoxAttachment@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);
            }

            internal static new BoundingBoxAttachment __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new BoundingBoxAttachment(native.ToPointer(), skipVTables);
            }

            internal static new BoundingBoxAttachment __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (BoundingBoxAttachment)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new BoundingBoxAttachment __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (BoundingBoxAttachment)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static BoundingBoxAttachment __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new BoundingBoxAttachment(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.BoundingBoxAttachment.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private BoundingBoxAttachment(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected BoundingBoxAttachment(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public BoundingBoxAttachment(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.BoundingBoxAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.BoundingBoxAttachment");
            }

            public BoundingBoxAttachment(global::spine_cpp.Spine.BoundingBoxAttachment _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.BoundingBoxAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.BoundingBoxAttachment");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.BoundingBoxAttachment(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.BoundingBoxAttachment(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_BoundingBoxAttachment_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public override global::spine_cpp.Spine.Attachment Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___CopyDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // BoundingBoxAttachment
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.BoundingBoxAttachment.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.BoundingBoxAttachment.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // Attachment *copy()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.BoundingBoxAttachment.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // void computeWorldVertices(Slot &slot, size_t start, size_t count, float *worldVertices, size_t offset, size_t stride = 2)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_ulong_ulong_floatPtr_ulong_ulong _ComputeWorldVertices_1DelegateInstance;

            private static void _ComputeWorldVertices_1DelegateHook(__IntPtr __instance, __IntPtr slot, ulong start, ulong count, float* worldVertices, ulong offset, ulong stride)
            {
                var __target = global::spine_cpp.Spine.BoundingBoxAttachment.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(slot, false, skipVTables: true);
                __target.ComputeWorldVertices(__result0, start, count, ref *worldVertices, offset, stride);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[4];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    _ComputeWorldVertices_1DelegateInstance += _ComputeWorldVertices_1DelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ComputeWorldVertices_1DelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class ClippingAttachment : global::spine_cpp.Spine.VertexAttachment, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 168)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal int _refCount;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal global::spine_cpp.Spine.Vector.__Internal _vertices;
                internal ulong _worldVerticesLength;
                internal __IntPtr _timelineAttachment;
                internal int _id;
                internal __IntPtr _endSlot;
                internal global::spine_cpp.Spine.Color.__Internal _color;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0ClippingAttachment@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0ClippingAttachment@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getEndSlot@ClippingAttachment@spine@@QEAAPEAVSlotData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetEndSlot(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setEndSlot@ClippingAttachment@spine@@QEAAXPEAVSlotData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetEndSlot(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getColor@ClippingAttachment@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);
            }

            internal static new ClippingAttachment __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ClippingAttachment(native.ToPointer(), skipVTables);
            }

            internal static new ClippingAttachment __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ClippingAttachment)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ClippingAttachment __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ClippingAttachment)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ClippingAttachment __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ClippingAttachment(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.ClippingAttachment.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private ClippingAttachment(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ClippingAttachment(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public ClippingAttachment(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ClippingAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ClippingAttachment");
            }

            public ClippingAttachment(global::spine_cpp.Spine.ClippingAttachment _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ClippingAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ClippingAttachment");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.ClippingAttachment(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.ClippingAttachment(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_ClippingAttachment_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public global::spine_cpp.Spine.SlotData EndSlot
            {
                get
                {
                    var ___ret = __Internal.GetEndSlot(__Instance);
                    var __result0 = global::spine_cpp.Spine.SlotData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetEndSlot(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public override global::spine_cpp.Spine.Attachment Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___CopyDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // ClippingAttachment
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.ClippingAttachment.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ClippingAttachment.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // Attachment *copy()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ClippingAttachment.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // void computeWorldVertices(Slot &slot, size_t start, size_t count, float *worldVertices, size_t offset, size_t stride = 2)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_ulong_ulong_floatPtr_ulong_ulong _ComputeWorldVertices_1DelegateInstance;

            private static void _ComputeWorldVertices_1DelegateHook(__IntPtr __instance, __IntPtr slot, ulong start, ulong count, float* worldVertices, ulong offset, ulong stride)
            {
                var __target = global::spine_cpp.Spine.ClippingAttachment.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(slot, false, skipVTables: true);
                __target.ComputeWorldVertices(__result0, start, count, ref *worldVertices, offset, stride);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[4];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    _ComputeWorldVertices_1DelegateInstance += _ComputeWorldVertices_1DelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ComputeWorldVertices_1DelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>Base class for frames that use an interpolation bezier curve.</summary>
        public unsafe abstract partial class CurveTimeline : global::spine_cpp.Spine.Timeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 112)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0CurveTimeline@spine@@QEAA@_K00@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong frameEntries, ulong bezierCount);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0CurveTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setLinear@CurveTimeline@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetLinear(__IntPtr __instance, ulong frame);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setStepped@CurveTimeline@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetStepped(__IntPtr __instance, ulong frame);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBezierValue@CurveTimeline@spine@@QEAAMM_K00@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetBezierValue(__IntPtr __instance, float time, ulong frame, ulong valueOffset, ulong i);
            }

            internal static new CurveTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new CurveTimelineInternal(native.ToPointer(), skipVTables);
            }

            internal static new CurveTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (CurveTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new CurveTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (CurveTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static CurveTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new CurveTimelineInternal(native, skipVTables);
            }

            protected CurveTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected CurveTimeline(ulong frameCount, ulong frameEntries, ulong bezierCount)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.CurveTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, frameEntries, bezierCount);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.CurveTimeline");
            }

            protected CurveTimeline(global::spine_cpp.Spine.CurveTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.CurveTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.CurveTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void SetLinear(ulong frame)
            {
                __Internal.SetLinear(__Instance, frame);
            }

            public void SetStepped(ulong frame)
            {
                __Internal.SetStepped(__Instance, frame);
            }

            public virtual void SetBezier(ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var ___SetBezierDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float>(0, 4);
                ___SetBezierDelegate(__Instance, bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            public float GetBezierValue(float time, ulong frame, ulong valueOffset, ulong i)
            {
                var ___ret = __Internal.GetBezierValue(__Instance, time, frame, valueOffset, i);
                return ___ret;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_CurveTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            #region Virtual table interop

            // virtual ~CurveTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe abstract partial class CurveTimeline1 : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 112)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0CurveTimeline1@spine@@QEAA@_K0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0CurveTimeline1@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setFrame@CurveTimeline1@spine@@QEAAX_KMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, ulong frame, float time, float value);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getCurveValue@CurveTimeline1@spine@@QEAAMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetCurveValue(__IntPtr __instance, float time);
            }

            internal static new CurveTimeline1 __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new CurveTimeline1Internal(native.ToPointer(), skipVTables);
            }

            internal static new CurveTimeline1 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (CurveTimeline1)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new CurveTimeline1 __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (CurveTimeline1)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static CurveTimeline1 __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new CurveTimeline1Internal(native, skipVTables);
            }

            protected CurveTimeline1(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected CurveTimeline1(ulong frameCount, ulong bezierCount)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.CurveTimeline1.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.CurveTimeline1");
            }

            protected CurveTimeline1(global::spine_cpp.Spine.CurveTimeline1 _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.CurveTimeline1.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.CurveTimeline1");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void SetFrame(ulong frame, float time, float value)
            {
                __Internal.SetFrame(__Instance, frame, time, value);
            }

            public float GetCurveValue(float time)
            {
                var ___ret = __Internal.GetCurveValue(__Instance, time);
                return ___ret;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_CurveTimeline1_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            #region Virtual table interop

            // virtual ~CurveTimeline1()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline1.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline1.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline1.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe abstract partial class CurveTimeline2 : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 112)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0CurveTimeline2@spine@@QEAA@_K0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0CurveTimeline2@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setFrame@CurveTimeline2@spine@@QEAAX_KMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, ulong frame, float time, float value1, float value2);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "?getCurveValue@CurveTimeline2@spine@@QEAAMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetCurveValue(__IntPtr __instance, float time);
            }

            internal static new CurveTimeline2 __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new CurveTimeline2Internal(native.ToPointer(), skipVTables);
            }

            internal static new CurveTimeline2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (CurveTimeline2)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new CurveTimeline2 __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (CurveTimeline2)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static CurveTimeline2 __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new CurveTimeline2Internal(native, skipVTables);
            }

            protected CurveTimeline2(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected CurveTimeline2(ulong frameCount, ulong bezierCount)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.CurveTimeline2.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.CurveTimeline2");
            }

            protected CurveTimeline2(global::spine_cpp.Spine.CurveTimeline2 _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.CurveTimeline2.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.CurveTimeline2");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void SetFrame(ulong frame, float time, float value1, float value2)
            {
                __Internal.SetFrame(__Instance, frame, time, value1, value2);
            }

            public float GetCurveValue(float time)
            {
                var ___ret = __Internal.GetCurveValue(__Instance, time);
                return ___ret;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_CurveTimeline2_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            #region Virtual table interop

            // virtual ~CurveTimeline2()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline2.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline2.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.CurveTimeline2.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class CurveTimelineInternal : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal CurveTimelineInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal CurveTimelineInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }
        }

        public unsafe partial class CurveTimeline1Internal : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal CurveTimeline1Internal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal CurveTimeline1Internal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }
        }

        public unsafe partial class CurveTimeline2Internal : global::spine_cpp.Spine.CurveTimeline2, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal CurveTimeline2Internal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal CurveTimeline2Internal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }
        }
    }

    namespace Spine
    {
        public unsafe partial class RGBATimeline : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _slotIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0RGBATimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int slotIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0RGBATimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setFrame@RGBATimeline@spine@@QEAAXHMMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, int frame, float time, float r, float g, float b, float a);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSlotIndex@RGBATimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetSlotIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSlotIndex@RGBATimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSlotIndex(__IntPtr __instance, int inValue);
            }

            internal static new RGBATimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new RGBATimeline(native.ToPointer(), skipVTables);
            }

            internal static new RGBATimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (RGBATimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new RGBATimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (RGBATimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static RGBATimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new RGBATimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.RGBATimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private RGBATimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected RGBATimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public RGBATimeline(ulong frameCount, ulong bezierCount, int slotIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RGBATimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, slotIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RGBATimeline");
            }

            public RGBATimeline(global::spine_cpp.Spine.RGBATimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RGBATimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RGBATimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Sets the time and value of the specified keyframe.</summary>
            public void SetFrame(int frame, float time, float r, float g, float b, float a)
            {
                __Internal.SetFrame(__Instance, frame, time, r, g, b, a);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_RGBATimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected int _slotIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_slotIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_slotIndex = value;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int SlotIndex
            {
                get
                {
                    var ___ret = __Internal.GetSlotIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSlotIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~RGBATimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.RGBATimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RGBATimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.RGBATimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class RGBTimeline : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _slotIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0RGBTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int slotIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0RGBTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setFrame@RGBTimeline@spine@@QEAAXHMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, int frame, float time, float r, float g, float b);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSlotIndex@RGBTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetSlotIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSlotIndex@RGBTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSlotIndex(__IntPtr __instance, int inValue);
            }

            internal static new RGBTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new RGBTimeline(native.ToPointer(), skipVTables);
            }

            internal static new RGBTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (RGBTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new RGBTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (RGBTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static RGBTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new RGBTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.RGBTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private RGBTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected RGBTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public RGBTimeline(ulong frameCount, ulong bezierCount, int slotIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RGBTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, slotIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RGBTimeline");
            }

            public RGBTimeline(global::spine_cpp.Spine.RGBTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RGBTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RGBTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Sets the time and value of the specified keyframe.</summary>
            public void SetFrame(int frame, float time, float r, float g, float b)
            {
                __Internal.SetFrame(__Instance, frame, time, r, g, b);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_RGBTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected int _slotIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_slotIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_slotIndex = value;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int SlotIndex
            {
                get
                {
                    var ___ret = __Internal.GetSlotIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSlotIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~RGBTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.RGBTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RGBTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.RGBTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class AlphaTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _slotIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AlphaTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int slotIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AlphaTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSlotIndex@AlphaTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetSlotIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSlotIndex@AlphaTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSlotIndex(__IntPtr __instance, int inValue);
            }

            internal static new AlphaTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AlphaTimeline(native.ToPointer(), skipVTables);
            }

            internal static new AlphaTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AlphaTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new AlphaTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AlphaTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AlphaTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AlphaTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.AlphaTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private AlphaTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected AlphaTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public AlphaTimeline(ulong frameCount, ulong bezierCount, int slotIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AlphaTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, slotIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AlphaTimeline");
            }

            public AlphaTimeline(global::spine_cpp.Spine.AlphaTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.AlphaTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.AlphaTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_AlphaTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected int _slotIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_slotIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_slotIndex = value;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int SlotIndex
            {
                get
                {
                    var ___ret = __Internal.GetSlotIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSlotIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~AlphaTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.AlphaTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.AlphaTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.AlphaTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class RGBA2Timeline : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _slotIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0RGBA2Timeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int slotIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0RGBA2Timeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setFrame@RGBA2Timeline@spine@@QEAAXHMMMMMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, int frame, float time, float r, float g, float b, float a, float r2, float g2, float b2);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSlotIndex@RGBA2Timeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetSlotIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSlotIndex@RGBA2Timeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSlotIndex(__IntPtr __instance, int inValue);
            }

            internal static new RGBA2Timeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new RGBA2Timeline(native.ToPointer(), skipVTables);
            }

            internal static new RGBA2Timeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (RGBA2Timeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new RGBA2Timeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (RGBA2Timeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static RGBA2Timeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new RGBA2Timeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.RGBA2Timeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private RGBA2Timeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected RGBA2Timeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public RGBA2Timeline(ulong frameCount, ulong bezierCount, int slotIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RGBA2Timeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, slotIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RGBA2Timeline");
            }

            public RGBA2Timeline(global::spine_cpp.Spine.RGBA2Timeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RGBA2Timeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RGBA2Timeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Sets the time and value of the specified keyframe.</summary>
            public void SetFrame(int frame, float time, float r, float g, float b, float a, float r2, float g2, float b2)
            {
                __Internal.SetFrame(__Instance, frame, time, r, g, b, a, r2, g2, b2);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_RGBA2Timeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected int _slotIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_slotIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_slotIndex = value;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int SlotIndex
            {
                get
                {
                    var ___ret = __Internal.GetSlotIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSlotIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~RGBA2Timeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.RGBA2Timeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RGBA2Timeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.RGBA2Timeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class RGB2Timeline : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _slotIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0RGB2Timeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int slotIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0RGB2Timeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setFrame@RGB2Timeline@spine@@QEAAXHMMMMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, int frame, float time, float r, float g, float b, float r2, float g2, float b2);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSlotIndex@RGB2Timeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetSlotIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSlotIndex@RGB2Timeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSlotIndex(__IntPtr __instance, int inValue);
            }

            internal static new RGB2Timeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new RGB2Timeline(native.ToPointer(), skipVTables);
            }

            internal static new RGB2Timeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (RGB2Timeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new RGB2Timeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (RGB2Timeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static RGB2Timeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new RGB2Timeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.RGB2Timeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private RGB2Timeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected RGB2Timeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public RGB2Timeline(ulong frameCount, ulong bezierCount, int slotIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RGB2Timeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, slotIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RGB2Timeline");
            }

            public RGB2Timeline(global::spine_cpp.Spine.RGB2Timeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RGB2Timeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RGB2Timeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Sets the time and value of the specified keyframe.</summary>
            public void SetFrame(int frame, float time, float r, float g, float b, float r2, float g2, float b2)
            {
                __Internal.SetFrame(__Instance, frame, time, r, g, b, r2, g2, b2);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_RGB2Timeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected int _slotIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_slotIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_slotIndex = value;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int SlotIndex
            {
                get
                {
                    var ___ret = __Internal.GetSlotIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSlotIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~RGB2Timeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.RGB2Timeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RGB2Timeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.RGB2Timeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>The interface for all constraints.</summary>
        public unsafe partial class ConstraintData : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 56)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal ulong _order;
                internal byte _skinRequired;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0ConstraintData@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0ConstraintData@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getName@ConstraintData@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getOrder@ConstraintData@spine@@QEAA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetOrder(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setOrder@ConstraintData@spine@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetOrder(__IntPtr __instance, ulong inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?isSkinRequired@ConstraintData@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsSkinRequired(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSkinRequired@ConstraintData@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSkinRequired(__IntPtr __instance, bool inValue);
            }

            internal static new ConstraintData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ConstraintData(native.ToPointer(), skipVTables);
            }

            internal static new ConstraintData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ConstraintData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ConstraintData __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ConstraintData)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ConstraintData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ConstraintData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.ConstraintData.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private ConstraintData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ConstraintData(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public ConstraintData(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ConstraintData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ConstraintData");
            }

            public ConstraintData(global::spine_cpp.Spine.ConstraintData _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ConstraintData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ConstraintData");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static implicit operator global::spine_cpp.Spine.ConstraintData(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.ConstraintData(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_ConstraintData_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public virtual global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    var ___GetRTTIDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 1);
                    var ___ret = ___GetRTTIDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.RTTI.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>The IK constraint's name, which is unique within the skeleton.</summary>
            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>The ordinal for the order a skeleton's constraints will be applied.</summary>
            public ulong Order
            {
                get
                {
                    var ___ret = __Internal.GetOrder(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOrder(__Instance, value);
                }
            }

            /// <summary>Whether the constraint is only active for a specific skin.</summary>
            public bool SkinRequired
            {
                get
                {
                    var ___ret = __Internal.IsSkinRequired(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSkinRequired(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~ConstraintData()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.ConstraintData.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ConstraintData.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class DeformTimeline : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 160)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _slotIndex;
                internal global::spine_cpp.Spine.Vector.__Internal _vertices;
                internal __IntPtr _attachment;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0DeformTimeline@spine@@QEAA@_K0HPEAVVertexAttachment@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int slotIndex, __IntPtr attachment);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0DeformTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getCurvePercent@DeformTimeline@spine@@QEAAMMH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetCurvePercent(__IntPtr __instance, float time, int frame);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAttachment@DeformTimeline@spine@@QEAAPEAVVertexAttachment@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAttachment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAttachment@DeformTimeline@spine@@QEAAXPEAVVertexAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAttachment(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSlotIndex@DeformTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetSlotIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSlotIndex@DeformTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSlotIndex(__IntPtr __instance, int inValue);
            }

            internal static new DeformTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new DeformTimeline(native.ToPointer(), skipVTables);
            }

            internal static new DeformTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (DeformTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new DeformTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (DeformTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static DeformTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new DeformTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.DeformTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private DeformTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected DeformTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public DeformTimeline(ulong frameCount, ulong bezierCount, int slotIndex, global::spine_cpp.Spine.VertexAttachment attachment)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.DeformTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg3 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
                __Internal.ctor(__Instance, frameCount, bezierCount, slotIndex, __arg3);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.DeformTimeline");
            }

            public DeformTimeline(global::spine_cpp.Spine.DeformTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.DeformTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.DeformTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void SetBezier(ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                base.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            public float GetCurvePercent(float time, int frame)
            {
                var ___ret = __Internal.GetCurvePercent(__Instance, time, frame);
                return ___ret;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_DeformTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected int _slotIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_slotIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_slotIndex = value;
                }
            }

            protected global::spine_cpp.Spine.VertexAttachment _attachment
            {
                get
                {
                    var __result0 = global::spine_cpp.Spine.VertexAttachment.__GetOrCreateInstance(((__Internal*)__Instance)->_attachment, true);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->_attachment = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public global::spine_cpp.Spine.VertexAttachment Attachment
            {
                get
                {
                    var ___ret = __Internal.GetAttachment(__Instance);
                    var __result0 = global::spine_cpp.Spine.VertexAttachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetAttachment(__Instance, __arg0);
                }
            }

            public int SlotIndex
            {
                get
                {
                    var ___ret = __Internal.GetSlotIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSlotIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // DeformTimeline
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.DeformTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.DeformTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.DeformTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class DrawOrderTimeline : global::spine_cpp.Spine.Timeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 112)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _drawOrders;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0DrawOrderTimeline@spine@@QEAA@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0DrawOrderTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new DrawOrderTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new DrawOrderTimeline(native.ToPointer(), skipVTables);
            }

            internal static new DrawOrderTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (DrawOrderTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new DrawOrderTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (DrawOrderTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static DrawOrderTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new DrawOrderTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.DrawOrderTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private DrawOrderTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected DrawOrderTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public DrawOrderTimeline(ulong frameCount)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.DrawOrderTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.DrawOrderTimeline");
            }

            public DrawOrderTimeline(global::spine_cpp.Spine.DrawOrderTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.DrawOrderTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.DrawOrderTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.DrawOrderTimeline(ulong frameCount)
            {
                return new global::spine_cpp.Spine.DrawOrderTimeline(frameCount);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_DrawOrderTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            #region Virtual table interop

            // DrawOrderTimeline
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.DrawOrderTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.DrawOrderTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[4];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>Stores the current pose values for an Event.</summary>
        public unsafe partial class Event : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 72)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _data;
                internal float _time;
                internal int _intValue;
                internal float _floatValue;
                internal global::spine_cpp.Spine.String.__Internal _stringValue;
                internal float _volume;
                internal float _balance;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Event@spine@@QEAA@MAEBVEventData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, float time, __IntPtr data);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Event@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getData@Event@spine@@QEAAAEBVEventData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getTime@Event@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetTime(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getIntValue@Event@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetIntValue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setIntValue@Event@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIntValue(__IntPtr __instance, int inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getFloatValue@Event@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetFloatValue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setFloatValue@Event@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFloatValue(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getStringValue@Event@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetStringValue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setStringValue@Event@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetStringValue(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getVolume@Event@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetVolume(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setVolume@Event@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVolume(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBalance@Event@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetBalance(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setBalance@Event@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBalance(__IntPtr __instance, float inValue);
            }

            internal static new Event __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Event(native.ToPointer(), skipVTables);
            }

            internal static new Event __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Event)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Event __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Event)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Event __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Event(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Event.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Event(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Event(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Event(float time, global::spine_cpp.Spine.EventData data)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Event.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(data, null))
                    throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = data.__Instance;
                __Internal.ctor(__Instance, time, __arg1);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Event");
            }

            public Event(global::spine_cpp.Spine.Event _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Event.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Event");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::spine_cpp.Spine.EventData Data
            {
                get
                {
                    var ___ret = __Internal.GetData(__Instance);
                    var __result0 = global::spine_cpp.Spine.EventData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>The animation time this event was keyed.</summary>
            public float Time
            {
                get
                {
                    var ___ret = __Internal.GetTime(__Instance);
                    return ___ret;
                }
            }

            public int IntValue
            {
                get
                {
                    var ___ret = __Internal.GetIntValue(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetIntValue(__Instance, value);
                }
            }

            public float FloatValue
            {
                get
                {
                    var ___ret = __Internal.GetFloatValue(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetFloatValue(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.String StringValue
            {
                get
                {
                    var ___ret = __Internal.GetStringValue(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetStringValue(__Instance, __arg0);
                }
            }

            public float Volume
            {
                get
                {
                    var ___ret = __Internal.GetVolume(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetVolume(__Instance, value);
                }
            }

            public float Balance
            {
                get
                {
                    var ___ret = __Internal.GetBalance(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBalance(__Instance, value);
                }
            }

            #region Virtual table interop

            // Event
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Event.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>Stores the setup pose values for an Event.</summary>
        public unsafe partial class EventData : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal int _intValue;
                internal float _floatValue;
                internal global::spine_cpp.Spine.String.__Internal _stringValue;
                internal global::spine_cpp.Spine.String.__Internal _audioPath;
                internal float _volume;
                internal float _balance;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0EventData@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0EventData@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getName@EventData@spine@@QEBAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getIntValue@EventData@spine@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetIntValue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setIntValue@EventData@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIntValue(__IntPtr __instance, int inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getFloatValue@EventData@spine@@QEBAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetFloatValue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setFloatValue@EventData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFloatValue(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getStringValue@EventData@spine@@QEBAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetStringValue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setStringValue@EventData@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetStringValue(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAudioPath@EventData@spine@@QEBAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAudioPath(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAudioPath@EventData@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAudioPath(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getVolume@EventData@spine@@QEBAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetVolume(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setVolume@EventData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVolume(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBalance@EventData@spine@@QEBAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetBalance(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setBalance@EventData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBalance(__IntPtr __instance, float inValue);
            }

            internal static new EventData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new EventData(native.ToPointer(), skipVTables);
            }

            internal static new EventData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (EventData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new EventData __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (EventData)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static EventData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new EventData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.EventData.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private EventData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected EventData(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public EventData(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.EventData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.EventData");
            }

            public EventData(global::spine_cpp.Spine.EventData _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.EventData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.EventData");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.EventData(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.EventData(name);
            }

            /// <summary>The name of the event, which is unique within the skeleton.</summary>
            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public int IntValue
            {
                get
                {
                    var ___ret = __Internal.GetIntValue(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetIntValue(__Instance, value);
                }
            }

            public float FloatValue
            {
                get
                {
                    var ___ret = __Internal.GetFloatValue(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetFloatValue(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.String StringValue
            {
                get
                {
                    var ___ret = __Internal.GetStringValue(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetStringValue(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.String AudioPath
            {
                get
                {
                    var ___ret = __Internal.GetAudioPath(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetAudioPath(__Instance, __arg0);
                }
            }

            public float Volume
            {
                get
                {
                    var ___ret = __Internal.GetVolume(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetVolume(__Instance, value);
                }
            }

            public float Balance
            {
                get
                {
                    var ___ret = __Internal.GetBalance(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBalance(__Instance, value);
                }
            }

            #region Virtual table interop

            // EventData
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.EventData.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class EventTimeline : global::spine_cpp.Spine.Timeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 112)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _events;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0EventTimeline@spine@@QEAA@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0EventTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setFrame@EventTimeline@spine@@QEAAX_KPEAVEvent@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, ulong frame, __IntPtr @event);
            }

            internal static new EventTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new EventTimeline(native.ToPointer(), skipVTables);
            }

            internal static new EventTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (EventTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new EventTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (EventTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static EventTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new EventTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.EventTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private EventTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected EventTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public EventTimeline(ulong frameCount)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.EventTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.EventTimeline");
            }

            public EventTimeline(global::spine_cpp.Spine.EventTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.EventTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.EventTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Sets the time and value of the specified keyframe.</summary>
            public void SetFrame(ulong frame, global::spine_cpp.Spine.Event @event)
            {
                var __arg1 = @event is null ? __IntPtr.Zero : @event.__Instance;
                __Internal.SetFrame(__Instance, frame, __arg1);
            }

            public static explicit operator global::spine_cpp.Spine.EventTimeline(ulong frameCount)
            {
                return new global::spine_cpp.Spine.EventTimeline(frameCount);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_EventTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            #region Virtual table interop

            // ~EventTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.EventTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.EventTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[4];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class IkConstraint : global::spine_cpp.Spine.Updatable, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 80)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _data;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal int _bendDirection;
                internal byte _compress;
                internal byte _stretch;
                internal float _mix;
                internal float _softness;
                internal __IntPtr _target;
                internal byte _active;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0IkConstraint@spine@@QEAA@AEAVIkConstraintData@1@AEAVSkeleton@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr data, __IntPtr skeleton);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0IkConstraint@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?apply@IkConstraint@spine@@SAXAEAVBone@2@MM_N11M@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Apply(__IntPtr bone, float targetX, float targetY, bool compress, bool stretch, bool uniform, float alpha);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?apply@IkConstraint@spine@@SAXAEAVBone@2@0MMH_N1MM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Apply(__IntPtr parent, __IntPtr child, float targetX, float targetY, int bendDir, bool stretch, bool uniform, float softness, float alpha);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getData@IkConstraint@spine@@QEAAAEAVIkConstraintData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getTarget@IkConstraint@spine@@QEAAPEAVBone@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTarget(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setTarget@IkConstraint@spine@@QEAAXPEAVBone@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTarget(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBendDirection@IkConstraint@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBendDirection(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setBendDirection@IkConstraint@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBendDirection(__IntPtr __instance, int inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getCompress@IkConstraint@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetCompress(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setCompress@IkConstraint@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetCompress(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getStretch@IkConstraint@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetStretch(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setStretch@IkConstraint@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetStretch(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMix@IkConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMix(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMix@IkConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMix(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSoftness@IkConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetSoftness(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSoftness@IkConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSoftness(__IntPtr __instance, float inValue);
            }

            internal static new IkConstraint __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new IkConstraint(native.ToPointer(), skipVTables);
            }

            internal static new IkConstraint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (IkConstraint)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new IkConstraint __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (IkConstraint)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static IkConstraint __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new IkConstraint(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.IkConstraint.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private IkConstraint(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected IkConstraint(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public IkConstraint(global::spine_cpp.Spine.IkConstraintData data, global::spine_cpp.Spine.Skeleton skeleton)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.IkConstraint.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(data, null))
                    throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = data.__Instance;
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = skeleton.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.IkConstraint");
            }

            public IkConstraint(global::spine_cpp.Spine.IkConstraint _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.IkConstraint.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.IkConstraint");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Update()
            {
                var ___UpdateDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr>(0, 2);
                ___UpdateDelegate(__Instance);
            }

            /// <summary>
            /// <para>Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified</para>
            /// <para>in the world coordinate system.</para>
            /// </summary>
            public static void Apply(global::spine_cpp.Spine.Bone bone, float targetX, float targetY, bool compress, bool stretch, bool uniform, float alpha)
            {
                if (ReferenceEquals(bone, null))
                    throw new global::System.ArgumentNullException("bone", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = bone.__Instance;
                __Internal.Apply(__arg0, targetX, targetY, compress, stretch, uniform, alpha);
            }

            /// <summary>
            /// <para>Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as</para>
            /// <para>possible. The target is specified in the world coordinate system.</para>
            /// </summary>
            /// <param name="child">A direct descendant of the parent bone.</param>
            public static void Apply(global::spine_cpp.Spine.Bone parent, global::spine_cpp.Spine.Bone child, float targetX, float targetY, int bendDir, bool stretch, bool uniform, float softness, float alpha)
            {
                if (ReferenceEquals(parent, null))
                    throw new global::System.ArgumentNullException("parent", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = parent.__Instance;
                if (ReferenceEquals(child, null))
                    throw new global::System.ArgumentNullException("child", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = child.__Instance;
                __Internal.Apply(__arg0, __arg1, targetX, targetY, bendDir, stretch, uniform, softness, alpha);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_IkConstraint_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public virtual int Order
            {
                get
                {
                    var ___GetOrderDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_int___IntPtr>(0, 5);
                    var ___ret = ___GetOrderDelegate(__Instance);
                    return ___ret;
                }
            }

            public global::spine_cpp.Spine.IkConstraintData Data
            {
                get
                {
                    var ___ret = __Internal.GetData(__Instance);
                    var __result0 = global::spine_cpp.Spine.IkConstraintData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Bone Target
            {
                get
                {
                    var ___ret = __Internal.GetTarget(__Instance);
                    var __result0 = global::spine_cpp.Spine.Bone.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetTarget(__Instance, __arg0);
                }
            }

            public int BendDirection
            {
                get
                {
                    var ___ret = __Internal.GetBendDirection(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBendDirection(__Instance, value);
                }
            }

            public bool Compress
            {
                get
                {
                    var ___ret = __Internal.GetCompress(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetCompress(__Instance, value);
                }
            }

            public bool Stretch
            {
                get
                {
                    var ___ret = __Internal.GetStretch(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetStretch(__Instance, value);
                }
            }

            public float Mix
            {
                get
                {
                    var ___ret = __Internal.GetMix(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMix(__Instance, value);
                }
            }

            public float Softness
            {
                get
                {
                    var ___ret = __Internal.GetSoftness(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSoftness(__Instance, value);
                }
            }

            public override bool Active
            {
                get
                {
                    var ___IsActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_bool___IntPtr>(0, 3);
                    var ___ret = ___IsActiveDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_bool>(0, 4);
                    ___SetActiveDelegate(__Instance, value);
                }
            }

            #region Virtual table interop

            // IkConstraint
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.IkConstraint.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.IkConstraint.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void update()
            private static global::spine_cpp.Delegates.Action___IntPtr _UpdateDelegateInstance;

            private static void _UpdateDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.IkConstraint.__GetInstance(__instance);
                __target.Update();
            }

            // bool isActive()
            private static global::spine_cpp.Delegates.Func_bool___IntPtr _IsActiveDelegateInstance;

            private static bool _IsActiveDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.IkConstraint.__GetInstance(__instance);
                var ___ret = __target.Active;
                return ___ret;
            }

            // void setActive(bool inValue)
            private static global::spine_cpp.Delegates.Action___IntPtr_bool _SetActiveDelegateInstance;

            private static void _SetActiveDelegateHook(__IntPtr __instance, bool inValue)
            {
                var __target = global::spine_cpp.Spine.IkConstraint.__GetInstance(__instance);
                __target.Active = inValue;
            }

            // int getOrder()
            private static global::spine_cpp.Delegates.Func_int___IntPtr _GetOrderDelegateInstance;

            private static int _GetOrderDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.IkConstraint.__GetInstance(__instance);
                var ___ret = __target.Order;
                return ___ret;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[6];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _UpdateDelegateInstance += _UpdateDelegateHook;
                    _IsActiveDelegateInstance += _IsActiveDelegateHook;
                    _SetActiveDelegateInstance += _SetActiveDelegateHook;
                    _GetOrderDelegateInstance += _GetOrderDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_IsActiveDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetActiveDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetOrderDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                VTables.Methods[0] = new Delegate[6];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class IkConstraintData : global::spine_cpp.Spine.ConstraintData, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 112)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal ulong _order;
                internal byte _skinRequired;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal __IntPtr _target;
                internal int _bendDirection;
                internal byte _compress;
                internal byte _stretch;
                internal byte _uniform;
                internal float _mix;
                internal float _softness;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0IkConstraintData@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0IkConstraintData@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getTarget@IkConstraintData@spine@@QEAAPEAVBoneData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTarget(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setTarget@IkConstraintData@spine@@QEAAXPEAVBoneData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTarget(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBendDirection@IkConstraintData@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBendDirection(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setBendDirection@IkConstraintData@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBendDirection(__IntPtr __instance, int inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getCompress@IkConstraintData@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetCompress(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setCompress@IkConstraintData@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetCompress(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getStretch@IkConstraintData@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetStretch(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setStretch@IkConstraintData@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetStretch(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getUniform@IkConstraintData@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetUniform(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setUniform@IkConstraintData@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetUniform(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMix@IkConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMix(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMix@IkConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMix(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSoftness@IkConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetSoftness(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSoftness@IkConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSoftness(__IntPtr __instance, float inValue);
            }

            internal static new IkConstraintData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new IkConstraintData(native.ToPointer(), skipVTables);
            }

            internal static new IkConstraintData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (IkConstraintData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new IkConstraintData __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (IkConstraintData)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static IkConstraintData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new IkConstraintData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.IkConstraintData.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private IkConstraintData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected IkConstraintData(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public IkConstraintData(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.IkConstraintData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.IkConstraintData");
            }

            public IkConstraintData(global::spine_cpp.Spine.IkConstraintData _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.IkConstraintData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.IkConstraintData");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.IkConstraintData(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.IkConstraintData(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_IkConstraintData_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            /// <summary>The bone that is the IK target.</summary>
            public global::spine_cpp.Spine.BoneData Target
            {
                get
                {
                    var ___ret = __Internal.GetTarget(__Instance);
                    var __result0 = global::spine_cpp.Spine.BoneData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetTarget(__Instance, __arg0);
                }
            }

            /// <summary>Controls the bend direction of the IK bones, either 1 or -1.</summary>
            public int BendDirection
            {
                get
                {
                    var ___ret = __Internal.GetBendDirection(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBendDirection(__Instance, value);
                }
            }

            public bool Compress
            {
                get
                {
                    var ___ret = __Internal.GetCompress(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetCompress(__Instance, value);
                }
            }

            public bool Stretch
            {
                get
                {
                    var ___ret = __Internal.GetStretch(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetStretch(__Instance, value);
                }
            }

            public bool Uniform
            {
                get
                {
                    var ___ret = __Internal.GetUniform(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetUniform(__Instance, value);
                }
            }

            public float Mix
            {
                get
                {
                    var ___ret = __Internal.GetMix(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMix(__Instance, value);
                }
            }

            public float Softness
            {
                get
                {
                    var ___ret = __Internal.GetSoftness(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSoftness(__Instance, value);
                }
            }

            #region Virtual table interop

            // IkConstraintData
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.IkConstraintData.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.IkConstraintData.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class IkConstraintTimeline : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _ikConstraintIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0IkConstraintTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int ikConstraintIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0IkConstraintTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setFrame@IkConstraintTimeline@spine@@QEAAXHMMMH_N0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, int frame, float time, float mix, float softness, int bendDirection, bool compress, bool stretch);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getIkConstraintIndex@IkConstraintTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetIkConstraintIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setIkConstraintIndex@IkConstraintTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIkConstraintIndex(__IntPtr __instance, int inValue);
            }

            internal static new IkConstraintTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new IkConstraintTimeline(native.ToPointer(), skipVTables);
            }

            internal static new IkConstraintTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (IkConstraintTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new IkConstraintTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (IkConstraintTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static IkConstraintTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new IkConstraintTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.IkConstraintTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private IkConstraintTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected IkConstraintTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public IkConstraintTimeline(ulong frameCount, ulong bezierCount, int ikConstraintIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.IkConstraintTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, ikConstraintIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.IkConstraintTimeline");
            }

            public IkConstraintTimeline(global::spine_cpp.Spine.IkConstraintTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.IkConstraintTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.IkConstraintTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Sets the time, mix and bend direction of the specified keyframe.</summary>
            public void SetFrame(int frame, float time, float mix, float softness, int bendDirection, bool compress, bool stretch)
            {
                __Internal.SetFrame(__Instance, frame, time, mix, softness, bendDirection, compress, stretch);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_IkConstraintTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int IkConstraintIndex
            {
                get
                {
                    var ___ret = __Internal.GetIkConstraintIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetIkConstraintIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // IkConstraintTimeline
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.IkConstraintTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.IkConstraintTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.IkConstraintTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class Json : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 56)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _next;
                internal __IntPtr _child;
                internal int _type;
                internal int _size;
                internal __IntPtr _valueString;
                internal int _valueInt;
                internal float _valueFloat;
                internal __IntPtr _name;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Json@spine@@QEAA@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string value);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Json@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getItem@Json@spine@@SAPEAV12@PEAV12@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetItem(__IntPtr @object, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string @string);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getItem@Json@spine@@SAPEAV12@PEAV12@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetItem_1(__IntPtr @object, int childIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getString@Json@spine@@SAPEBDPEAV12@PEBD1@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetString(__IntPtr @object, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getFloat@Json@spine@@SAMPEAV12@PEBDM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetFloat(__IntPtr @object, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, float defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getInt@Json@spine@@SAHPEAV12@PEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetInt(__IntPtr @object, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, int defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBoolean@Json@spine@@SA_NPEAV12@PEBD_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetBoolean(__IntPtr @object, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, bool defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getError@Json@spine@@SAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetError();
            }

            internal static new Json __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Json(native.ToPointer(), skipVTables);
            }

            internal static new Json __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Json)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Json __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Json)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Json __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Json(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Json.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Json(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Json(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Json(string value)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Json.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, value);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Json");
            }

            public Json(global::spine_cpp.Spine.Json _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Json.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Json");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.Json(string value)
            {
                return new global::spine_cpp.Spine.Json(value);
            }

            public static global::spine_cpp.Spine.Json GetItem(global::spine_cpp.Spine.Json @object, string @string)
            {
                var __arg0 = @object is null ? __IntPtr.Zero : @object.__Instance;
                var ___ret = __Internal.GetItem(__arg0, @string);
                var __result0 = global::spine_cpp.Spine.Json.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public static global::spine_cpp.Spine.Json GetItem(global::spine_cpp.Spine.Json @object, int childIndex)
            {
                var __arg0 = @object is null ? __IntPtr.Zero : @object.__Instance;
                var ___ret = __Internal.GetItem_1(__arg0, childIndex);
                var __result0 = global::spine_cpp.Spine.Json.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public static string GetString(global::spine_cpp.Spine.Json @object, string name, string defaultValue)
            {
                var __arg0 = @object is null ? __IntPtr.Zero : @object.__Instance;
                var ___ret = __Internal.GetString(__arg0, name, defaultValue);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public static float GetFloat(global::spine_cpp.Spine.Json @object, string name, float defaultValue)
            {
                var __arg0 = @object is null ? __IntPtr.Zero : @object.__Instance;
                var ___ret = __Internal.GetFloat(__arg0, name, defaultValue);
                return ___ret;
            }

            public static int GetInt(global::spine_cpp.Spine.Json @object, string name, int defaultValue)
            {
                var __arg0 = @object is null ? __IntPtr.Zero : @object.__Instance;
                var ___ret = __Internal.GetInt(__arg0, name, defaultValue);
                return ___ret;
            }

            public static bool GetBoolean(global::spine_cpp.Spine.Json @object, string name, bool defaultValue)
            {
                var __arg0 = @object is null ? __IntPtr.Zero : @object.__Instance;
                var ___ret = __Internal.GetBoolean(__arg0, name, defaultValue);
                return ___ret;
            }

            public static int JSON_FALSE
            {
                get
                {
                    var __ptr = (int*)global::spine_cpp.__Symbols.DLLPlugin._JSON_FALSE_Json_spine__2HB;
                    return *__ptr;
                }
            }

            public static int JSON_TRUE
            {
                get
                {
                    var __ptr = (int*)global::spine_cpp.__Symbols.DLLPlugin._JSON_TRUE_Json_spine__2HB;
                    return *__ptr;
                }
            }

            public static int JSON_NULL
            {
                get
                {
                    var __ptr = (int*)global::spine_cpp.__Symbols.DLLPlugin._JSON_NULL_Json_spine__2HB;
                    return *__ptr;
                }
            }

            public static int JSON_NUMBER
            {
                get
                {
                    var __ptr = (int*)global::spine_cpp.__Symbols.DLLPlugin._JSON_NUMBER_Json_spine__2HB;
                    return *__ptr;
                }
            }

            public static int JSON_STRING
            {
                get
                {
                    var __ptr = (int*)global::spine_cpp.__Symbols.DLLPlugin._JSON_STRING_Json_spine__2HB;
                    return *__ptr;
                }
            }

            public static int JSON_ARRAY
            {
                get
                {
                    var __ptr = (int*)global::spine_cpp.__Symbols.DLLPlugin._JSON_ARRAY_Json_spine__2HB;
                    return *__ptr;
                }
            }

            public static int JSON_OBJECT
            {
                get
                {
                    var __ptr = (int*)global::spine_cpp.__Symbols.DLLPlugin._JSON_OBJECT_Json_spine__2HB;
                    return *__ptr;
                }
            }

            public static string error
            {
                get
                {
                    var ___ret = __Internal.GetError();
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            #region Virtual table interop

            // ~Json()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Json.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class LinkedMesh : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 96)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _mesh;
                internal global::spine_cpp.Spine.String.__Internal _skin;
                internal ulong _slotIndex;
                internal global::spine_cpp.Spine.String.__Internal _parent;
                internal byte _inheritTimeline;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0LinkedMesh@spine@@QEAA@PEAVMeshAttachment@1@AEBVString@1@_K1_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr mesh, __IntPtr skin, ulong slotIndex, __IntPtr parent, bool inheritTimeline);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0LinkedMesh@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new LinkedMesh __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new LinkedMesh(native.ToPointer(), skipVTables);
            }

            internal static new LinkedMesh __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (LinkedMesh)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new LinkedMesh __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (LinkedMesh)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static LinkedMesh __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new LinkedMesh(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.LinkedMesh.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private LinkedMesh(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected LinkedMesh(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public LinkedMesh(global::spine_cpp.Spine.MeshAttachment mesh, global::spine_cpp.Spine.String skin, ulong slotIndex, global::spine_cpp.Spine.String parent, bool inheritTimeline)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.LinkedMesh.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = mesh is null ? __IntPtr.Zero : mesh.__Instance;
                if (ReferenceEquals(skin, null))
                    throw new global::System.ArgumentNullException("skin", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = skin.__Instance;
                if (ReferenceEquals(parent, null))
                    throw new global::System.ArgumentNullException("parent", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = parent.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1, slotIndex, __arg3, inheritTimeline);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.LinkedMesh");
            }

            public LinkedMesh(global::spine_cpp.Spine.LinkedMesh _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.LinkedMesh.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.LinkedMesh");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // LinkedMesh
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.LinkedMesh.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public enum SequenceMode
        {
            Hold = 0,
            Once = 1,
            Loop = 2,
            Pingpong = 3,
            OnceReverse = 4,
            LoopReverse = 5,
            PingpongReverse = 6
        }

        public unsafe partial class Sequence : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 64)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal int _id;
                internal global::spine_cpp.Spine.Vector.__Internal _regions;
                internal int _start;
                internal int _digits;
                internal int _setupIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Sequence@spine@@QEAA@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, int count);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Sequence@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?apply@Sequence@spine@@QEAAXPEAVSlot@2@PEAVAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Apply(__IntPtr __instance, __IntPtr slot, __IntPtr attachment);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getPath@Sequence@spine@@QEAA?AVString@2@AEBV32@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetPath(__IntPtr __instance, __IntPtr @return, __IntPtr basePath, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?copy@Sequence@spine@@QEAAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Copy(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getId@Sequence@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetId(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setId@Sequence@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetId(__IntPtr __instance, int id);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getStart@Sequence@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetStart(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setStart@Sequence@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetStart(__IntPtr __instance, int start);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getDigits@Sequence@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetDigits(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setDigits@Sequence@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDigits(__IntPtr __instance, int digits);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSetupIndex@Sequence@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetSetupIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSetupIndex@Sequence@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSetupIndex(__IntPtr __instance, int setupIndex);
            }

            internal static new Sequence __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Sequence(native.ToPointer(), skipVTables);
            }

            internal static new Sequence __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Sequence)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Sequence __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Sequence)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Sequence __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Sequence(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Sequence.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Sequence(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Sequence(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Sequence(int count)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Sequence.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, count);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Sequence");
            }

            public Sequence(global::spine_cpp.Spine.Sequence _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Sequence.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Sequence");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Apply(global::spine_cpp.Spine.Slot slot, global::spine_cpp.Spine.Attachment attachment)
            {
                var __arg0 = slot is null ? __IntPtr.Zero : slot.__Instance;
                var __arg1 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
                __Internal.Apply(__Instance, __arg0, __arg1);
            }

            public global::spine_cpp.Spine.String GetPath(global::spine_cpp.Spine.String basePath, int index)
            {
                if (ReferenceEquals(basePath, null))
                    throw new global::System.ArgumentNullException("basePath", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = basePath.__Instance;
                var ___ret = new global::spine_cpp.Spine.String.__Internal();
                __Internal.GetPath(__Instance, new IntPtr(&___ret), __arg0, index);
                var _____ret = global::spine_cpp.Spine.String.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::spine_cpp.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            public static implicit operator global::spine_cpp.Spine.Sequence(int count)
            {
                return new global::spine_cpp.Spine.Sequence(count);
            }

            public global::spine_cpp.Spine.Sequence Copy
            {
                get
                {
                    var ___ret = __Internal.Copy(__Instance);
                    var __result0 = global::spine_cpp.Spine.Sequence.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public int Id
            {
                get
                {
                    var ___ret = __Internal.GetId(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetId(__Instance, value);
                }
            }

            public int Start
            {
                get
                {
                    var ___ret = __Internal.GetStart(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetStart(__Instance, value);
                }
            }

            public int Digits
            {
                get
                {
                    var ___ret = __Internal.GetDigits(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetDigits(__Instance, value);
                }
            }

            public int SetupIndex
            {
                get
                {
                    var ___ret = __Internal.GetSetupIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSetupIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // ~Sequence()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Sequence.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>Attachment that displays a texture region using a mesh.</summary>
        public unsafe partial class MeshAttachment : global::spine_cpp.Spine.VertexAttachment, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 360)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal int _refCount;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal global::spine_cpp.Spine.Vector.__Internal _vertices;
                internal ulong _worldVerticesLength;
                internal __IntPtr _timelineAttachment;
                internal int _id;
                internal __IntPtr _parentMesh;
                internal global::spine_cpp.Spine.Vector.__Internal _uvs;
                internal global::spine_cpp.Spine.Vector.__Internal _regionUVs;
                internal global::spine_cpp.Spine.Vector.__Internal _triangles;
                internal global::spine_cpp.Spine.Vector.__Internal _edges;
                internal global::spine_cpp.Spine.String.__Internal _path;
                internal global::spine_cpp.Spine.Color.__Internal _color;
                internal int _hullLength;
                internal int _width;
                internal int _height;
                internal __IntPtr _region;
                internal __IntPtr _sequence;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0MeshAttachment@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0MeshAttachment@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?updateRegion@MeshAttachment@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?newLinkedMesh@MeshAttachment@spine@@QEAAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr NewLinkedMesh(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getHullLength@MeshAttachment@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetHullLength(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setHullLength@MeshAttachment@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHullLength(__IntPtr __instance, int inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getColor@MeshAttachment@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getPath@MeshAttachment@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetPath(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setPath@MeshAttachment@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPath(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getRegion@MeshAttachment@spine@@QEAAPEAVTextureRegion@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setRegion@MeshAttachment@spine@@QEAAXPEAVTextureRegion@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRegion(__IntPtr __instance, __IntPtr region);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSequence@MeshAttachment@spine@@QEAAPEAVSequence@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSequence(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSequence@MeshAttachment@spine@@QEAAXPEAVSequence@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSequence(__IntPtr __instance, __IntPtr sequence);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getParentMesh@MeshAttachment@spine@@QEAAPEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetParentMesh(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setParentMesh@MeshAttachment@spine@@QEAAXPEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetParentMesh(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getWidth@MeshAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWidth(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setWidth@MeshAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWidth(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getHeight@MeshAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetHeight(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setHeight@MeshAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHeight(__IntPtr __instance, float inValue);
            }

            internal static new MeshAttachment __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new MeshAttachment(native.ToPointer(), skipVTables);
            }

            internal static new MeshAttachment __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (MeshAttachment)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new MeshAttachment __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (MeshAttachment)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static MeshAttachment __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new MeshAttachment(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.MeshAttachment.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private MeshAttachment(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected MeshAttachment(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public MeshAttachment(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.MeshAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.MeshAttachment");
            }

            public MeshAttachment(global::spine_cpp.Spine.MeshAttachment _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.MeshAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.MeshAttachment");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void ComputeWorldVertices(global::spine_cpp.Spine.Slot slot, ulong start, ulong count, ref float worldVertices, ulong offset, ulong stride)
            {
                base.ComputeWorldVertices(slot, start, count, ref worldVertices, offset, stride);
            }

            public void UpdateRegion()
            {
                __Internal.UpdateRegion(__Instance);
            }

            public global::spine_cpp.Spine.MeshAttachment NewLinkedMesh()
            {
                var ___ret = __Internal.NewLinkedMesh(__Instance);
                var __result0 = global::spine_cpp.Spine.MeshAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public static explicit operator global::spine_cpp.Spine.MeshAttachment(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.MeshAttachment(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_MeshAttachment_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int HullLength
            {
                get
                {
                    var ___ret = __Internal.GetHullLength(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHullLength(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.String Path
            {
                get
                {
                    var ___ret = __Internal.GetPath(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetPath(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.TextureRegion Region
            {
                get
                {
                    var ___ret = __Internal.GetRegion(__Instance);
                    var __result0 = global::spine_cpp.Spine.TextureRegion.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetRegion(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.Sequence Sequence
            {
                get
                {
                    var ___ret = __Internal.GetSequence(__Instance);
                    var __result0 = global::spine_cpp.Spine.Sequence.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetSequence(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.MeshAttachment ParentMesh
            {
                get
                {
                    var ___ret = __Internal.GetParentMesh(__Instance);
                    var __result0 = global::spine_cpp.Spine.MeshAttachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetParentMesh(__Instance, __arg0);
                }
            }

            public float Width
            {
                get
                {
                    var ___ret = __Internal.GetWidth(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetWidth(__Instance, value);
                }
            }

            public float Height
            {
                get
                {
                    var ___ret = __Internal.GetHeight(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHeight(__Instance, value);
                }
            }

            public override global::spine_cpp.Spine.Attachment Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___CopyDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // virtual ~MeshAttachment()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.MeshAttachment.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.MeshAttachment.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // Attachment *copy()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.MeshAttachment.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // void computeWorldVertices(Slot &slot, size_t start, size_t count, float *worldVertices, size_t offset, size_t stride = 2)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_ulong_ulong_floatPtr_ulong_ulong _ComputeWorldVerticesDelegateInstance;

            private static void _ComputeWorldVerticesDelegateHook(__IntPtr __instance, __IntPtr slot, ulong start, ulong count, float* worldVertices, ulong offset, ulong stride)
            {
                var __target = global::spine_cpp.Spine.MeshAttachment.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(slot, false, skipVTables: true);
                __target.ComputeWorldVertices(__result0, start, count, ref *worldVertices, offset, stride);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[4];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    _ComputeWorldVerticesDelegateInstance += _ComputeWorldVerticesDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ComputeWorldVerticesDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class PathAttachment : global::spine_cpp.Spine.VertexAttachment, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 200)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal int _refCount;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal global::spine_cpp.Spine.Vector.__Internal _vertices;
                internal ulong _worldVerticesLength;
                internal __IntPtr _timelineAttachment;
                internal int _id;
                internal global::spine_cpp.Spine.Vector.__Internal _lengths;
                internal byte _closed;
                internal byte _constantSpeed;
                internal global::spine_cpp.Spine.Color.__Internal _color;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0PathAttachment@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0PathAttachment@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?isClosed@PathAttachment@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsClosed(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setClosed@PathAttachment@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetClosed(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?isConstantSpeed@PathAttachment@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsConstantSpeed(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setConstantSpeed@PathAttachment@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetConstantSpeed(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getColor@PathAttachment@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);
            }

            internal static new PathAttachment __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PathAttachment(native.ToPointer(), skipVTables);
            }

            internal static new PathAttachment __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PathAttachment)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new PathAttachment __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (PathAttachment)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static PathAttachment __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PathAttachment(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.PathAttachment.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private PathAttachment(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PathAttachment(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public PathAttachment(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathAttachment");
            }

            public PathAttachment(global::spine_cpp.Spine.PathAttachment _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathAttachment");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.PathAttachment(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.PathAttachment(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_PathAttachment_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public bool Closed
            {
                get
                {
                    var ___ret = __Internal.IsClosed(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetClosed(__Instance, value);
                }
            }

            public bool ConstantSpeed
            {
                get
                {
                    var ___ret = __Internal.IsConstantSpeed(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetConstantSpeed(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public override global::spine_cpp.Spine.Attachment Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___CopyDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // PathAttachment
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.PathAttachment.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathAttachment.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // Attachment *copy()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathAttachment.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // void computeWorldVertices(Slot &slot, size_t start, size_t count, float *worldVertices, size_t offset, size_t stride = 2)
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr_ulong_ulong_floatPtr_ulong_ulong _ComputeWorldVertices_1DelegateInstance;

            private static void _ComputeWorldVertices_1DelegateHook(__IntPtr __instance, __IntPtr slot, ulong start, ulong count, float* worldVertices, ulong offset, ulong stride)
            {
                var __target = global::spine_cpp.Spine.PathAttachment.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(slot, false, skipVTables: true);
                __target.ComputeWorldVertices(__result0, start, count, ref *worldVertices, offset, stride);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[4];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    _ComputeWorldVertices_1DelegateInstance += _ComputeWorldVertices_1DelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ComputeWorldVertices_1DelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class PathConstraint : global::spine_cpp.Spine.Updatable, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 280)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _data;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal __IntPtr _target;
                internal float _position;
                internal float _spacing;
                internal float _mixRotate;
                internal float _mixX;
                internal float _mixY;
                internal global::spine_cpp.Spine.Vector.__Internal _spaces;
                internal global::spine_cpp.Spine.Vector.__Internal _positions;
                internal global::spine_cpp.Spine.Vector.__Internal _world;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal global::spine_cpp.Spine.Vector.__Internal _lengths;
                internal global::spine_cpp.Spine.Vector.__Internal _segments;
                internal byte _active;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0PathConstraint@spine@@QEAA@AEAVPathConstraintData@1@AEAVSkeleton@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr data, __IntPtr skeleton);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0PathConstraint@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getData@PathConstraint@spine@@QEAAAEAVPathConstraintData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getTarget@PathConstraint@spine@@QEAAPEAVSlot@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTarget(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setTarget@PathConstraint@spine@@QEAAXPEAVSlot@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTarget(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getPosition@PathConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetPosition(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setPosition@PathConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPosition(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSpacing@PathConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetSpacing(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSpacing@PathConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSpacing(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixRotate@PathConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixRotate(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixRotate@PathConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixRotate(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixX@PathConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixX@PathConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixY@PathConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixY@PathConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixY(__IntPtr __instance, float inValue);
            }

            internal static new PathConstraint __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PathConstraint(native.ToPointer(), skipVTables);
            }

            internal static new PathConstraint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PathConstraint)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new PathConstraint __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (PathConstraint)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static PathConstraint __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PathConstraint(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.PathConstraint.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private PathConstraint(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PathConstraint(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public PathConstraint(global::spine_cpp.Spine.PathConstraintData data, global::spine_cpp.Spine.Skeleton skeleton)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraint.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(data, null))
                    throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = data.__Instance;
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = skeleton.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraint");
            }

            public PathConstraint(global::spine_cpp.Spine.PathConstraint _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraint.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraint");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Update()
            {
                var ___UpdateDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr>(0, 2);
                ___UpdateDelegate(__Instance);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_PathConstraint_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public virtual int Order
            {
                get
                {
                    var ___GetOrderDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_int___IntPtr>(0, 5);
                    var ___ret = ___GetOrderDelegate(__Instance);
                    return ___ret;
                }
            }

            public global::spine_cpp.Spine.PathConstraintData Data
            {
                get
                {
                    var ___ret = __Internal.GetData(__Instance);
                    var __result0 = global::spine_cpp.Spine.PathConstraintData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Slot Target
            {
                get
                {
                    var ___ret = __Internal.GetTarget(__Instance);
                    var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetTarget(__Instance, __arg0);
                }
            }

            public float Position
            {
                get
                {
                    var ___ret = __Internal.GetPosition(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetPosition(__Instance, value);
                }
            }

            public float Spacing
            {
                get
                {
                    var ___ret = __Internal.GetSpacing(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSpacing(__Instance, value);
                }
            }

            public float MixRotate
            {
                get
                {
                    var ___ret = __Internal.GetMixRotate(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixRotate(__Instance, value);
                }
            }

            public float MixX
            {
                get
                {
                    var ___ret = __Internal.GetMixX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixX(__Instance, value);
                }
            }

            public float MixY
            {
                get
                {
                    var ___ret = __Internal.GetMixY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixY(__Instance, value);
                }
            }

            public override bool Active
            {
                get
                {
                    var ___IsActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_bool___IntPtr>(0, 3);
                    var ___ret = ___IsActiveDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_bool>(0, 4);
                    ___SetActiveDelegate(__Instance, value);
                }
            }

            #region Virtual table interop

            // PathConstraint
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.PathConstraint.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraint.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void update()
            private static global::spine_cpp.Delegates.Action___IntPtr _UpdateDelegateInstance;

            private static void _UpdateDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraint.__GetInstance(__instance);
                __target.Update();
            }

            // bool isActive()
            private static global::spine_cpp.Delegates.Func_bool___IntPtr _IsActiveDelegateInstance;

            private static bool _IsActiveDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraint.__GetInstance(__instance);
                var ___ret = __target.Active;
                return ___ret;
            }

            // void setActive(bool inValue)
            private static global::spine_cpp.Delegates.Action___IntPtr_bool _SetActiveDelegateInstance;

            private static void _SetActiveDelegateHook(__IntPtr __instance, bool inValue)
            {
                var __target = global::spine_cpp.Spine.PathConstraint.__GetInstance(__instance);
                __target.Active = inValue;
            }

            // int getOrder()
            private static global::spine_cpp.Delegates.Func_int___IntPtr _GetOrderDelegateInstance;

            private static int _GetOrderDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraint.__GetInstance(__instance);
                var ___ret = __target.Order;
                return ___ret;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[6];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _UpdateDelegateInstance += _UpdateDelegateHook;
                    _IsActiveDelegateInstance += _IsActiveDelegateHook;
                    _SetActiveDelegateInstance += _SetActiveDelegateHook;
                    _GetOrderDelegateInstance += _GetOrderDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_IsActiveDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetActiveDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetOrderDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                VTables.Methods[0] = new Delegate[6];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class PathConstraintData : global::spine_cpp.Spine.ConstraintData, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 136)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal ulong _order;
                internal byte _skinRequired;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal __IntPtr _target;
                internal global::spine_cpp.Spine.PositionMode _positionMode;
                internal global::spine_cpp.Spine.SpacingMode _spacingMode;
                internal global::spine_cpp.Spine.RotateMode _rotateMode;
                internal float _offsetRotation;
                internal float _position;
                internal float _spacing;
                internal float _mixRotate;
                internal float _mixX;
                internal float _mixY;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0PathConstraintData@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0PathConstraintData@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getTarget@PathConstraintData@spine@@QEAAPEAVSlotData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTarget(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setTarget@PathConstraintData@spine@@QEAAXPEAVSlotData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTarget(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getPositionMode@PathConstraintData@spine@@QEAA?AW4PositionMode@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::spine_cpp.Spine.PositionMode GetPositionMode(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setPositionMode@PathConstraintData@spine@@QEAAXW4PositionMode@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPositionMode(__IntPtr __instance, global::spine_cpp.Spine.PositionMode inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSpacingMode@PathConstraintData@spine@@QEAA?AW4SpacingMode@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::spine_cpp.Spine.SpacingMode GetSpacingMode(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSpacingMode@PathConstraintData@spine@@QEAAXW4SpacingMode@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSpacingMode(__IntPtr __instance, global::spine_cpp.Spine.SpacingMode inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getRotateMode@PathConstraintData@spine@@QEAA?AW4RotateMode@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::spine_cpp.Spine.RotateMode GetRotateMode(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setRotateMode@PathConstraintData@spine@@QEAAXW4RotateMode@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRotateMode(__IntPtr __instance, global::spine_cpp.Spine.RotateMode inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getOffsetRotation@PathConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetOffsetRotation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setOffsetRotation@PathConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetOffsetRotation(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getPosition@PathConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetPosition(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setPosition@PathConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPosition(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSpacing@PathConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetSpacing(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSpacing@PathConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSpacing(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixRotate@PathConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixRotate(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixRotate@PathConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixRotate(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixX@PathConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixX@PathConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixY@PathConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixY@PathConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixY(__IntPtr __instance, float inValue);
            }

            internal static new PathConstraintData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PathConstraintData(native.ToPointer(), skipVTables);
            }

            internal static new PathConstraintData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PathConstraintData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new PathConstraintData __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (PathConstraintData)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static PathConstraintData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PathConstraintData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.PathConstraintData.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private PathConstraintData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PathConstraintData(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public PathConstraintData(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraintData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraintData");
            }

            public PathConstraintData(global::spine_cpp.Spine.PathConstraintData _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraintData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraintData");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.PathConstraintData(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.PathConstraintData(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_PathConstraintData_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public global::spine_cpp.Spine.SlotData Target
            {
                get
                {
                    var ___ret = __Internal.GetTarget(__Instance);
                    var __result0 = global::spine_cpp.Spine.SlotData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetTarget(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.PositionMode PositionMode
            {
                get
                {
                    var ___ret = __Internal.GetPositionMode(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetPositionMode(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.SpacingMode SpacingMode
            {
                get
                {
                    var ___ret = __Internal.GetSpacingMode(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSpacingMode(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.RotateMode RotateMode
            {
                get
                {
                    var ___ret = __Internal.GetRotateMode(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetRotateMode(__Instance, value);
                }
            }

            public float OffsetRotation
            {
                get
                {
                    var ___ret = __Internal.GetOffsetRotation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOffsetRotation(__Instance, value);
                }
            }

            public float Position
            {
                get
                {
                    var ___ret = __Internal.GetPosition(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetPosition(__Instance, value);
                }
            }

            public float Spacing
            {
                get
                {
                    var ___ret = __Internal.GetSpacing(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSpacing(__Instance, value);
                }
            }

            public float MixRotate
            {
                get
                {
                    var ___ret = __Internal.GetMixRotate(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixRotate(__Instance, value);
                }
            }

            public float MixX
            {
                get
                {
                    var ___ret = __Internal.GetMixX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixX(__Instance, value);
                }
            }

            public float MixY
            {
                get
                {
                    var ___ret = __Internal.GetMixY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixY(__Instance, value);
                }
            }

            #region Virtual table interop

            // PathConstraintData
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.PathConstraintData.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraintData.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class PathConstraintMixTimeline : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _pathConstraintIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0PathConstraintMixTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int pathConstraintIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0PathConstraintMixTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setFrame@PathConstraintMixTimeline@spine@@QEAAXHMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, int frameIndex, float time, float mixRotate, float mixX, float mixY);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getPathConstraintIndex@PathConstraintMixTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetPathConstraintIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setPathConstraintIndex@PathConstraintMixTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPathConstraintIndex(__IntPtr __instance, int inValue);
            }

            internal static new PathConstraintMixTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PathConstraintMixTimeline(native.ToPointer(), skipVTables);
            }

            internal static new PathConstraintMixTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PathConstraintMixTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new PathConstraintMixTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (PathConstraintMixTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static PathConstraintMixTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PathConstraintMixTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.PathConstraintMixTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private PathConstraintMixTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PathConstraintMixTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public PathConstraintMixTimeline(ulong frameCount, ulong bezierCount, int pathConstraintIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraintMixTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, pathConstraintIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraintMixTimeline");
            }

            public PathConstraintMixTimeline(global::spine_cpp.Spine.PathConstraintMixTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraintMixTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraintMixTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Sets the time and mixes of the specified keyframe.</summary>
            public void SetFrame(int frameIndex, float time, float mixRotate, float mixX, float mixY)
            {
                __Internal.SetFrame(__Instance, frameIndex, time, mixRotate, mixX, mixY);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_PathConstraintMixTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int PathConstraintIndex
            {
                get
                {
                    var ___ret = __Internal.GetPathConstraintIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetPathConstraintIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // PathConstraintMixTimeline
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.PathConstraintMixTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraintMixTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.PathConstraintMixTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class PathConstraintPositionTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _pathConstraintIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0PathConstraintPositionTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int pathConstraintIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0PathConstraintPositionTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getPathConstraintIndex@PathConstraintPositionTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetPathConstraintIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setPathConstraintIndex@PathConstraintPositionTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPathConstraintIndex(__IntPtr __instance, int inValue);
            }

            internal static new PathConstraintPositionTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PathConstraintPositionTimeline(native.ToPointer(), skipVTables);
            }

            internal static new PathConstraintPositionTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PathConstraintPositionTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new PathConstraintPositionTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (PathConstraintPositionTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static PathConstraintPositionTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PathConstraintPositionTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.PathConstraintPositionTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private PathConstraintPositionTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PathConstraintPositionTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public PathConstraintPositionTimeline(ulong frameCount, ulong bezierCount, int pathConstraintIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraintPositionTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, pathConstraintIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraintPositionTimeline");
            }

            public PathConstraintPositionTimeline(global::spine_cpp.Spine.PathConstraintPositionTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraintPositionTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraintPositionTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_PathConstraintPositionTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public static int ENTRIES
            {
                get
                {
                    var __ptr = (int*)global::spine_cpp.__Symbols.spine_cpp._ENTRIES_PathConstraintPositionTimeline_spine__2HB;
                    return *__ptr;
                }
            }

            protected int _pathConstraintIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_pathConstraintIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_pathConstraintIndex = value;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int PathConstraintIndex
            {
                get
                {
                    var ___ret = __Internal.GetPathConstraintIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetPathConstraintIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~PathConstraintPositionTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.PathConstraintPositionTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraintPositionTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.PathConstraintPositionTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class PathConstraintSpacingTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _pathConstraintIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0PathConstraintSpacingTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int pathConstraintIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0PathConstraintSpacingTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getPathConstraintIndex@PathConstraintSpacingTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetPathConstraintIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setPathConstraintIndex@PathConstraintSpacingTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPathConstraintIndex(__IntPtr __instance, int inValue);
            }

            internal static new PathConstraintSpacingTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PathConstraintSpacingTimeline(native.ToPointer(), skipVTables);
            }

            internal static new PathConstraintSpacingTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PathConstraintSpacingTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new PathConstraintSpacingTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (PathConstraintSpacingTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static PathConstraintSpacingTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PathConstraintSpacingTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.PathConstraintSpacingTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private PathConstraintSpacingTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PathConstraintSpacingTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public PathConstraintSpacingTimeline(ulong frameCount, ulong bezierCount, int pathConstraintIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraintSpacingTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, pathConstraintIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraintSpacingTimeline");
            }

            public PathConstraintSpacingTimeline(global::spine_cpp.Spine.PathConstraintSpacingTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PathConstraintSpacingTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PathConstraintSpacingTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_PathConstraintSpacingTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            protected int _pathConstraintIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->_pathConstraintIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->_pathConstraintIndex = value;
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int PathConstraintIndex
            {
                get
                {
                    var ___ret = __Internal.GetPathConstraintIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetPathConstraintIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // PathConstraintSpacingTimeline
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.PathConstraintSpacingTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PathConstraintSpacingTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.PathConstraintSpacingTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>
        /// <para>An attachment which is a single point and a rotation. This can be used to spawn projectiles, particles, etc. A bone can be</para>
        /// <para>used in similar ways, but a PointAttachment is slightly less expensive to compute and can be hidden, shown, and placed in a</para>
        /// <para>skin.</para>
        /// </summary>
        /// <remarks>See http://esotericsoftware.com/spine-point-attachments for Point Attachments in the Spine User Guide.</remarks>
        public unsafe partial class PointAttachment : global::spine_cpp.Spine.Attachment, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 88)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal int _refCount;
                internal fixed byte _xPadding[4];
                internal float _x;
                internal float _y;
                internal float _rotation;
                internal global::spine_cpp.Spine.Color.__Internal _color;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0PointAttachment@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0PointAttachment@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?computeWorldPosition@PointAttachment@spine@@QEAAXAEAVBone@2@AEAM1@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ComputeWorldPosition(__IntPtr __instance, __IntPtr bone, float* ox, float* oy);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?computeWorldRotation@PointAttachment@spine@@QEAAMAEAVBone@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float ComputeWorldRotation(__IntPtr __instance, __IntPtr bone);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getX@PointAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setX@PointAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getY@PointAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setY@PointAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getRotation@PointAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetRotation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setRotation@PointAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRotation(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getColor@PointAttachment@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);
            }

            internal static new PointAttachment __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PointAttachment(native.ToPointer(), skipVTables);
            }

            internal static new PointAttachment __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PointAttachment)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new PointAttachment __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (PointAttachment)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static PointAttachment __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PointAttachment(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.PointAttachment.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private PointAttachment(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PointAttachment(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public PointAttachment(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PointAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PointAttachment");
            }

            public PointAttachment(global::spine_cpp.Spine.PointAttachment _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.PointAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.PointAttachment");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void ComputeWorldPosition(global::spine_cpp.Spine.Bone bone, ref float ox, ref float oy)
            {
                if (ReferenceEquals(bone, null))
                    throw new global::System.ArgumentNullException("bone", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = bone.__Instance;
                fixed (float* __ox1 = &ox)
                {
                    var __arg1 = __ox1;
                    fixed (float* __oy2 = &oy)
                    {
                        var __arg2 = __oy2;
                        __Internal.ComputeWorldPosition(__Instance, __arg0, __arg1, __arg2);
                    }
                }
            }

            public float ComputeWorldRotation(global::spine_cpp.Spine.Bone bone)
            {
                if (ReferenceEquals(bone, null))
                    throw new global::System.ArgumentNullException("bone", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = bone.__Instance;
                var ___ret = __Internal.ComputeWorldRotation(__Instance, __arg0);
                return ___ret;
            }

            public static explicit operator global::spine_cpp.Spine.PointAttachment(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.PointAttachment(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_PointAttachment_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public float X
            {
                get
                {
                    var ___ret = __Internal.GetX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetX(__Instance, value);
                }
            }

            public float Y
            {
                get
                {
                    var ___ret = __Internal.GetY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetY(__Instance, value);
                }
            }

            public float Rotation
            {
                get
                {
                    var ___ret = __Internal.GetRotation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetRotation(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public override global::spine_cpp.Spine.Attachment Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___CopyDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // PointAttachment
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.PointAttachment.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PointAttachment.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // Attachment *copy()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.PointAttachment.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>Attachment that displays a texture region.</summary>
        public unsafe partial class RegionAttachment : global::spine_cpp.Spine.Attachment, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 216)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal int _refCount;
                internal fixed byte _xPadding[4];
                internal float _x;
                internal float _y;
                internal float _rotation;
                internal float _scaleX;
                internal float _scaleY;
                internal float _width;
                internal float _height;
                internal global::spine_cpp.Spine.Vector.__Internal _vertexOffset;
                internal global::spine_cpp.Spine.Vector.__Internal _uvs;
                internal global::spine_cpp.Spine.String.__Internal _path;
                internal global::spine_cpp.Spine.Color.__Internal _color;
                internal __IntPtr _region;
                internal __IntPtr _sequence;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0RegionAttachment@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0RegionAttachment@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?updateRegion@RegionAttachment@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?computeWorldVertices@RegionAttachment@spine@@QEAAXAEAVSlot@2@PEAM_K2@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ComputeWorldVertices(__IntPtr __instance, __IntPtr slot, float* worldVertices, ulong offset, ulong stride);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getX@RegionAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setX@RegionAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getY@RegionAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setY@RegionAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getRotation@RegionAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetRotation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setRotation@RegionAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRotation(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getScaleX@RegionAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScaleX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setScaleX@RegionAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScaleX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getScaleY@RegionAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScaleY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setScaleY@RegionAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScaleY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getWidth@RegionAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWidth(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setWidth@RegionAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWidth(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getHeight@RegionAttachment@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetHeight(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setHeight@RegionAttachment@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHeight(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getColor@RegionAttachment@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getPath@RegionAttachment@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetPath(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setPath@RegionAttachment@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPath(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getRegion@RegionAttachment@spine@@QEAAPEAVTextureRegion@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRegion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setRegion@RegionAttachment@spine@@QEAAXPEAVTextureRegion@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRegion(__IntPtr __instance, __IntPtr region);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSequence@RegionAttachment@spine@@QEAAPEAVSequence@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSequence(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSequence@RegionAttachment@spine@@QEAAXPEAVSequence@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSequence(__IntPtr __instance, __IntPtr sequence);
            }

            internal static new RegionAttachment __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new RegionAttachment(native.ToPointer(), skipVTables);
            }

            internal static new RegionAttachment __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (RegionAttachment)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new RegionAttachment __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (RegionAttachment)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static RegionAttachment __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new RegionAttachment(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.RegionAttachment.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private RegionAttachment(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected RegionAttachment(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public RegionAttachment(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RegionAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RegionAttachment");
            }

            public RegionAttachment(global::spine_cpp.Spine.RegionAttachment _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RegionAttachment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RegionAttachment");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void UpdateRegion()
            {
                __Internal.UpdateRegion(__Instance);
            }

            /// <summary>Transforms the attachment's four vertices to world coordinates.</summary>
            /// <param name="slot">The parent slot.</param>
            /// <param name="worldVertices">The output world vertices. Must have a length greater than or equal to offset + 8.</param>
            /// <param name="offset">The worldVertices index to begin writing values.</param>
            /// <param name="stride">The number of worldVertices entries between the value pairs written.</param>
            public void ComputeWorldVertices(global::spine_cpp.Spine.Slot slot, ref float worldVertices, ulong offset, ulong stride)
            {
                if (ReferenceEquals(slot, null))
                    throw new global::System.ArgumentNullException("slot", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slot.__Instance;
                fixed (float* __worldVertices1 = &worldVertices)
                {
                    var __arg1 = __worldVertices1;
                    __Internal.ComputeWorldVertices(__Instance, __arg0, __arg1, offset, stride);
                }
            }

            public static explicit operator global::spine_cpp.Spine.RegionAttachment(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.RegionAttachment(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_RegionAttachment_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public float X
            {
                get
                {
                    var ___ret = __Internal.GetX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetX(__Instance, value);
                }
            }

            public float Y
            {
                get
                {
                    var ___ret = __Internal.GetY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetY(__Instance, value);
                }
            }

            public float Rotation
            {
                get
                {
                    var ___ret = __Internal.GetRotation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetRotation(__Instance, value);
                }
            }

            public float ScaleX
            {
                get
                {
                    var ___ret = __Internal.GetScaleX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetScaleX(__Instance, value);
                }
            }

            public float ScaleY
            {
                get
                {
                    var ___ret = __Internal.GetScaleY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetScaleY(__Instance, value);
                }
            }

            public float Width
            {
                get
                {
                    var ___ret = __Internal.GetWidth(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetWidth(__Instance, value);
                }
            }

            public float Height
            {
                get
                {
                    var ___ret = __Internal.GetHeight(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHeight(__Instance, value);
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.String Path
            {
                get
                {
                    var ___ret = __Internal.GetPath(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetPath(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.TextureRegion Region
            {
                get
                {
                    var ___ret = __Internal.GetRegion(__Instance);
                    var __result0 = global::spine_cpp.Spine.TextureRegion.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetRegion(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.Sequence Sequence
            {
                get
                {
                    var ___ret = __Internal.GetSequence(__Instance);
                    var __result0 = global::spine_cpp.Spine.Sequence.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetSequence(__Instance, __arg0);
                }
            }

            public override global::spine_cpp.Spine.Attachment Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___CopyDelegate(__Instance);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // virtual ~RegionAttachment()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.RegionAttachment.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RegionAttachment.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // Attachment *copy()
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RegionAttachment.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class RotateTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0RotateTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0RotateTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBoneIndex@RotateTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setBoneIndex@RotateTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new RotateTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new RotateTimeline(native.ToPointer(), skipVTables);
            }

            internal static new RotateTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (RotateTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new RotateTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (RotateTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static RotateTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new RotateTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.RotateTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private RotateTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected RotateTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public RotateTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RotateTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RotateTimeline");
            }

            public RotateTimeline(global::spine_cpp.Spine.RotateTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.RotateTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.RotateTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_RotateTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // RotateTimeline
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.RotateTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.RotateTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.RotateTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class TranslateTimeline : global::spine_cpp.Spine.CurveTimeline2, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0TranslateTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0TranslateTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBoneIndex@TranslateTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setBoneIndex@TranslateTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new TranslateTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TranslateTimeline(native.ToPointer(), skipVTables);
            }

            internal static new TranslateTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TranslateTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new TranslateTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (TranslateTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static TranslateTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TranslateTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.TranslateTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private TranslateTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TranslateTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public TranslateTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TranslateTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TranslateTimeline");
            }

            public TranslateTimeline(global::spine_cpp.Spine.TranslateTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TranslateTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TranslateTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_TranslateTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~TranslateTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.TranslateTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TranslateTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.TranslateTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class TranslateXTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0TranslateXTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0TranslateXTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBoneIndex@TranslateXTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setBoneIndex@TranslateXTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new TranslateXTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TranslateXTimeline(native.ToPointer(), skipVTables);
            }

            internal static new TranslateXTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TranslateXTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new TranslateXTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (TranslateXTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static TranslateXTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TranslateXTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.TranslateXTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private TranslateXTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TranslateXTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public TranslateXTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TranslateXTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TranslateXTimeline");
            }

            public TranslateXTimeline(global::spine_cpp.Spine.TranslateXTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TranslateXTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TranslateXTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_TranslateXTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~TranslateXTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.TranslateXTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TranslateXTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.TranslateXTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class TranslateYTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0TranslateYTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0TranslateYTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBoneIndex@TranslateYTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setBoneIndex@TranslateYTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new TranslateYTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TranslateYTimeline(native.ToPointer(), skipVTables);
            }

            internal static new TranslateYTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TranslateYTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new TranslateYTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (TranslateYTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static TranslateYTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TranslateYTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.TranslateYTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private TranslateYTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TranslateYTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public TranslateYTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TranslateYTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TranslateYTimeline");
            }

            public TranslateYTimeline(global::spine_cpp.Spine.TranslateYTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TranslateYTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TranslateYTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_TranslateYTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~TranslateYTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.TranslateYTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TranslateYTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.TranslateYTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class ScaleTimeline : global::spine_cpp.Spine.CurveTimeline2, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0ScaleTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0ScaleTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBoneIndex@ScaleTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setBoneIndex@ScaleTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new ScaleTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ScaleTimeline(native.ToPointer(), skipVTables);
            }

            internal static new ScaleTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ScaleTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ScaleTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ScaleTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ScaleTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ScaleTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.ScaleTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private ScaleTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ScaleTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public ScaleTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ScaleTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ScaleTimeline");
            }

            public ScaleTimeline(global::spine_cpp.Spine.ScaleTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ScaleTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ScaleTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_ScaleTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~ScaleTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.ScaleTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ScaleTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.ScaleTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class ScaleXTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0ScaleXTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0ScaleXTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBoneIndex@ScaleXTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setBoneIndex@ScaleXTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new ScaleXTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ScaleXTimeline(native.ToPointer(), skipVTables);
            }

            internal static new ScaleXTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ScaleXTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ScaleXTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ScaleXTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ScaleXTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ScaleXTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.ScaleXTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private ScaleXTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ScaleXTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public ScaleXTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ScaleXTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ScaleXTimeline");
            }

            public ScaleXTimeline(global::spine_cpp.Spine.ScaleXTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ScaleXTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ScaleXTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_ScaleXTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~ScaleXTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.ScaleXTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ScaleXTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.ScaleXTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class ScaleYTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0ScaleYTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0ScaleYTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBoneIndex@ScaleYTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setBoneIndex@ScaleYTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new ScaleYTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ScaleYTimeline(native.ToPointer(), skipVTables);
            }

            internal static new ScaleYTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ScaleYTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ScaleYTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ScaleYTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ScaleYTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ScaleYTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.ScaleYTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private ScaleYTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ScaleYTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public ScaleYTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ScaleYTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ScaleYTimeline");
            }

            public ScaleYTimeline(global::spine_cpp.Spine.ScaleYTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ScaleYTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ScaleYTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_ScaleYTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~ScaleYTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.ScaleYTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ScaleYTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.ScaleYTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class ShearTimeline : global::spine_cpp.Spine.CurveTimeline2, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0ShearTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0ShearTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBoneIndex@ShearTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setBoneIndex@ShearTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new ShearTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ShearTimeline(native.ToPointer(), skipVTables);
            }

            internal static new ShearTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ShearTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ShearTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ShearTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ShearTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ShearTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.ShearTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private ShearTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ShearTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public ShearTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ShearTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ShearTimeline");
            }

            public ShearTimeline(global::spine_cpp.Spine.ShearTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ShearTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ShearTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_ShearTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~ShearTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.ShearTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ShearTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.ShearTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class ShearXTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0ShearXTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0ShearXTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBoneIndex@ShearXTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setBoneIndex@ShearXTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new ShearXTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ShearXTimeline(native.ToPointer(), skipVTables);
            }

            internal static new ShearXTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ShearXTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ShearXTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ShearXTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ShearXTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ShearXTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.ShearXTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private ShearXTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ShearXTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public ShearXTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ShearXTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ShearXTimeline");
            }

            public ShearXTimeline(global::spine_cpp.Spine.ShearXTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ShearXTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ShearXTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_ShearXTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~ShearXTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.ShearXTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ShearXTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.ShearXTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class ShearYTimeline : global::spine_cpp.Spine.CurveTimeline1, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _boneIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0ShearYTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int boneIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0ShearYTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBoneIndex@ShearYTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetBoneIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setBoneIndex@ShearYTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoneIndex(__IntPtr __instance, int inValue);
            }

            internal static new ShearYTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ShearYTimeline(native.ToPointer(), skipVTables);
            }

            internal static new ShearYTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ShearYTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ShearYTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ShearYTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ShearYTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ShearYTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.ShearYTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private ShearYTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ShearYTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public ShearYTimeline(ulong frameCount, ulong bezierCount, int boneIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ShearYTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, boneIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ShearYTimeline");
            }

            public ShearYTimeline(global::spine_cpp.Spine.ShearYTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.ShearYTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.ShearYTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_ShearYTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int BoneIndex
            {
                get
                {
                    var ___ret = __Internal.GetBoneIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoneIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~ShearYTimeline()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.ShearYTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.ShearYTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.ShearYTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class Skeleton : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 288)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _data;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal global::spine_cpp.Spine.Vector.__Internal _slots;
                internal global::spine_cpp.Spine.Vector.__Internal _drawOrder;
                internal global::spine_cpp.Spine.Vector.__Internal _ikConstraints;
                internal global::spine_cpp.Spine.Vector.__Internal _transformConstraints;
                internal global::spine_cpp.Spine.Vector.__Internal _pathConstraints;
                internal global::spine_cpp.Spine.Vector.__Internal _updateCache;
                internal __IntPtr _skin;
                internal global::spine_cpp.Spine.Color.__Internal _color;
                internal float _scaleX;
                internal float _scaleY;
                internal float _x;
                internal float _y;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Skeleton@spine@@QEAA@PEAVSkeletonData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr skeletonData);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Skeleton@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?updateCache@Skeleton@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateCache(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?printUpdateCache@Skeleton@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PrintUpdateCache(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?updateWorldTransform@Skeleton@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateWorldTransform(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?updateWorldTransform@Skeleton@spine@@QEAAXPEAVBone@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateWorldTransform(__IntPtr __instance, __IntPtr parent);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setToSetupPose@Skeleton@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetToSetupPose(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setBonesToSetupPose@Skeleton@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBonesToSetupPose(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSlotsToSetupPose@Skeleton@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSlotsToSetupPose(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?findBone@Skeleton@spine@@QEAAPEAVBone@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindBone(__IntPtr __instance, __IntPtr boneName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?findSlot@Skeleton@spine@@QEAAPEAVSlot@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindSlot(__IntPtr __instance, __IntPtr slotName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSkin@Skeleton@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSkin(__IntPtr __instance, __IntPtr skinName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAttachment@Skeleton@spine@@QEAAPEAVAttachment@2@AEBVString@2@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAttachment(__IntPtr __instance, __IntPtr slotName, __IntPtr attachmentName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAttachment@Skeleton@spine@@QEAAPEAVAttachment@2@HAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAttachment(__IntPtr __instance, int slotIndex, __IntPtr attachmentName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAttachment@Skeleton@spine@@QEAAXAEBVString@2@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAttachment(__IntPtr __instance, __IntPtr slotName, __IntPtr attachmentName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?findIkConstraint@Skeleton@spine@@QEAAPEAVIkConstraint@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindIkConstraint(__IntPtr __instance, __IntPtr constraintName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?findTransformConstraint@Skeleton@spine@@QEAAPEAVTransformConstraint@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindTransformConstraint(__IntPtr __instance, __IntPtr constraintName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?findPathConstraint@Skeleton@spine@@QEAAPEAVPathConstraint@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindPathConstraint(__IntPtr __instance, __IntPtr constraintName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setPosition@Skeleton@spine@@QEAAXMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPosition(__IntPtr __instance, float x, float y);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getSkin@Skeleton@spine@@QEAAPEAVSkin@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSkin(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setSkin@Skeleton@spine@@QEAAXPEAVSkin@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSkin_1(__IntPtr __instance, __IntPtr newSkin);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getRootBone@Skeleton@spine@@QEAAPEAVBone@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRootBone(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getData@Skeleton@spine@@QEAAPEAVSkeletonData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getColor@Skeleton@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getX@Skeleton@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setX@Skeleton@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getY@Skeleton@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setY@Skeleton@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getScaleX@Skeleton@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScaleX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setScaleX@Skeleton@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScaleX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getScaleY@Skeleton@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScaleY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setScaleY@Skeleton@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScaleY(__IntPtr __instance, float inValue);
            }

            internal static new Skeleton __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Skeleton(native.ToPointer(), skipVTables);
            }

            internal static new Skeleton __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Skeleton)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Skeleton __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Skeleton)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Skeleton __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Skeleton(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Skeleton.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Skeleton(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Skeleton(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Skeleton(global::spine_cpp.Spine.SkeletonData skeletonData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Skeleton.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = skeletonData is null ? __IntPtr.Zero : skeletonData.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Skeleton");
            }

            public Skeleton(global::spine_cpp.Spine.Skeleton _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Skeleton.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Skeleton");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Caches information about bones and constraints. Must be called if bones, constraints or weighted path attachments are added</para>
            /// <para>or removed.</para>
            /// </summary>
            public void UpdateCache()
            {
                __Internal.UpdateCache(__Instance);
            }

            public void PrintUpdateCache()
            {
                __Internal.PrintUpdateCache(__Instance);
            }

            /// <summary>Updates the world transform for each bone and applies constraints.</summary>
            public void UpdateWorldTransform()
            {
                __Internal.UpdateWorldTransform(__Instance);
            }

            public void UpdateWorldTransform(global::spine_cpp.Spine.Bone parent)
            {
                var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
                __Internal.UpdateWorldTransform(__Instance, __arg0);
            }

            /// <summary>Sets the bones, constraints, and slots to their setup pose values.</summary>
            public void SetToSetupPose()
            {
                __Internal.SetToSetupPose(__Instance);
            }

            /// <summary>Sets the bones and constraints to their setup pose values.</summary>
            public void SetBonesToSetupPose()
            {
                __Internal.SetBonesToSetupPose(__Instance);
            }

            public void SetSlotsToSetupPose()
            {
                __Internal.SetSlotsToSetupPose(__Instance);
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.Bone FindBone(global::spine_cpp.Spine.String boneName)
            {
                if (ReferenceEquals(boneName, null))
                    throw new global::System.ArgumentNullException("boneName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = boneName.__Instance;
                var ___ret = __Internal.FindBone(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.Bone.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.Slot FindSlot(global::spine_cpp.Spine.String slotName)
            {
                if (ReferenceEquals(slotName, null))
                    throw new global::System.ArgumentNullException("slotName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slotName.__Instance;
                var ___ret = __Internal.FindSlot(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.Slot.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Sets a skin by name (see setSkin).</summary>
            public void SetSkin(global::spine_cpp.Spine.String skinName)
            {
                if (ReferenceEquals(skinName, null))
                    throw new global::System.ArgumentNullException("skinName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skinName.__Instance;
                __Internal.SetSkin(__Instance, __arg0);
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.Attachment GetAttachment(global::spine_cpp.Spine.String slotName, global::spine_cpp.Spine.String attachmentName)
            {
                if (ReferenceEquals(slotName, null))
                    throw new global::System.ArgumentNullException("slotName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slotName.__Instance;
                if (ReferenceEquals(attachmentName, null))
                    throw new global::System.ArgumentNullException("attachmentName", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = attachmentName.__Instance;
                var ___ret = __Internal.GetAttachment(__Instance, __arg0, __arg1);
                var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.Attachment GetAttachment(int slotIndex, global::spine_cpp.Spine.String attachmentName)
            {
                if (ReferenceEquals(attachmentName, null))
                    throw new global::System.ArgumentNullException("attachmentName", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = attachmentName.__Instance;
                var ___ret = __Internal.GetAttachment(__Instance, slotIndex, __arg1);
                var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <param name="attachmentName">May be empty.</param>
            public void SetAttachment(global::spine_cpp.Spine.String slotName, global::spine_cpp.Spine.String attachmentName)
            {
                if (ReferenceEquals(slotName, null))
                    throw new global::System.ArgumentNullException("slotName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slotName.__Instance;
                if (ReferenceEquals(attachmentName, null))
                    throw new global::System.ArgumentNullException("attachmentName", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = attachmentName.__Instance;
                __Internal.SetAttachment(__Instance, __arg0, __arg1);
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.IkConstraint FindIkConstraint(global::spine_cpp.Spine.String constraintName)
            {
                if (ReferenceEquals(constraintName, null))
                    throw new global::System.ArgumentNullException("constraintName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = constraintName.__Instance;
                var ___ret = __Internal.FindIkConstraint(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.IkConstraint.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.TransformConstraint FindTransformConstraint(global::spine_cpp.Spine.String constraintName)
            {
                if (ReferenceEquals(constraintName, null))
                    throw new global::System.ArgumentNullException("constraintName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = constraintName.__Instance;
                var ___ret = __Internal.FindTransformConstraint(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.TransformConstraint.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.PathConstraint FindPathConstraint(global::spine_cpp.Spine.String constraintName)
            {
                if (ReferenceEquals(constraintName, null))
                    throw new global::System.ArgumentNullException("constraintName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = constraintName.__Instance;
                var ___ret = __Internal.FindPathConstraint(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.PathConstraint.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public void SetPosition(float x, float y)
            {
                __Internal.SetPosition(__Instance, x, y);
            }

            public static explicit operator global::spine_cpp.Spine.Skeleton(global::spine_cpp.Spine.SkeletonData skeletonData)
            {
                return new global::spine_cpp.Spine.Skeleton(skeletonData);
            }

            public global::spine_cpp.Spine.Skin Skin
            {
                get
                {
                    var ___ret = __Internal.GetSkin(__Instance);
                    var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetSkin_1(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.Bone RootBone
            {
                get
                {
                    var ___ret = __Internal.GetRootBone(__Instance);
                    var __result0 = global::spine_cpp.Spine.Bone.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.SkeletonData Data
            {
                get
                {
                    var ___ret = __Internal.GetData(__Instance);
                    var __result0 = global::spine_cpp.Spine.SkeletonData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public float X
            {
                get
                {
                    var ___ret = __Internal.GetX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetX(__Instance, value);
                }
            }

            public float Y
            {
                get
                {
                    var ___ret = __Internal.GetY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetY(__Instance, value);
                }
            }

            public float ScaleX
            {
                get
                {
                    var ___ret = __Internal.GetScaleX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetScaleX(__Instance, value);
                }
            }

            public float ScaleY
            {
                get
                {
                    var ___ret = __Internal.GetScaleY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetScaleY(__Instance, value);
                }
            }

            #region Virtual table interop

            // ~Skeleton()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Skeleton.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class SkeletonBinary : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 88)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _attachmentLoader;
                internal global::spine_cpp.Spine.Vector.__Internal _linkedMeshes;
                internal global::spine_cpp.Spine.String.__Internal _error;
                internal float _scale;
                internal byte _ownsLoader;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0SkeletonBinary@spine@@QEAA@PEAVAtlas@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr atlasArray);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0SkeletonBinary@spine@@QEAA@PEAVAttachmentLoader@1@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr attachmentLoader, bool ownsLoader);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0SkeletonBinary@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?readSkeletonData@SkeletonBinary@spine@@QEAAPEAVSkeletonData@2@PEBEH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ReadSkeletonData(__IntPtr __instance, byte* binary, int length);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?readSkeletonDataFile@SkeletonBinary@spine@@QEAAPEAVSkeletonData@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ReadSkeletonDataFile(__IntPtr __instance, __IntPtr path);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setScale@SkeletonBinary@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScale(__IntPtr __instance, float scale);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getError@SkeletonBinary@spine@@QEAAAEAVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetError(__IntPtr __instance);
            }

            internal static new SkeletonBinary __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SkeletonBinary(native.ToPointer(), skipVTables);
            }

            internal static new SkeletonBinary __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SkeletonBinary)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new SkeletonBinary __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (SkeletonBinary)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static SkeletonBinary __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SkeletonBinary(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.SkeletonBinary.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private SkeletonBinary(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SkeletonBinary(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public SkeletonBinary(global::spine_cpp.Spine.Atlas atlasArray)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonBinary.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = atlasArray is null ? __IntPtr.Zero : atlasArray.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonBinary");
            }

            public SkeletonBinary(global::spine_cpp.Spine.AttachmentLoader attachmentLoader, bool ownsLoader)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonBinary.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = attachmentLoader is null ? __IntPtr.Zero : attachmentLoader.__Instance;
                __Internal.ctor(__Instance, __arg0, ownsLoader);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonBinary");
            }

            public SkeletonBinary(global::spine_cpp.Spine.SkeletonBinary _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonBinary.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonBinary");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::spine_cpp.Spine.SkeletonData ReadSkeletonData(byte* binary, int length)
            {
                var ___ret = __Internal.ReadSkeletonData(__Instance, binary, length);
                var __result0 = global::spine_cpp.Spine.SkeletonData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.SkeletonData ReadSkeletonDataFile(global::spine_cpp.Spine.String path)
            {
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = path.__Instance;
                var ___ret = __Internal.ReadSkeletonDataFile(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.SkeletonData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public void SetScale(float scale)
            {
                __Internal.SetScale(__Instance, scale);
            }

            public static explicit operator global::spine_cpp.Spine.SkeletonBinary(global::spine_cpp.Spine.Atlas atlasArray)
            {
                return new global::spine_cpp.Spine.SkeletonBinary(atlasArray);
            }

            public const int BONE_ROTATE = 0;
            public const int BONE_TRANSLATE = 1;
            public const int BONE_TRANSLATEX = 2;
            public const int BONE_TRANSLATEY = 3;
            public const int BONE_SCALE = 4;
            public const int BONE_SCALEX = 5;
            public const int BONE_SCALEY = 6;
            public const int BONE_SHEAR = 7;
            public const int BONE_SHEARX = 8;
            public const int BONE_SHEARY = 9;
            public const int SLOT_ATTACHMENT = 0;
            public const int SLOT_RGBA = 1;
            public const int SLOT_RGB = 2;
            public const int SLOT_RGBA2 = 3;
            public const int SLOT_RGB2 = 4;
            public const int SLOT_ALPHA = 5;
            public const int ATTACHMENT_DEFORM = 0;
            public const int ATTACHMENT_SEQUENCE = 1;
            public const int PATH_POSITION = 0;
            public const int PATH_SPACING = 1;
            public const int PATH_MIX = 2;
            public const int CURVE_LINEAR = 0;
            public const int CURVE_STEPPED = 1;
            public const int CURVE_BEZIER = 2;
            public global::spine_cpp.Spine.String Error
            {
                get
                {
                    var ___ret = __Internal.GetError(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // ~SkeletonBinary()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.SkeletonBinary.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>
        /// <para>Collects each BoundingBoxAttachment that is visible and computes the world vertices for its polygon.</para>
        /// <para>The polygon vertices are provided along with convenience methods for doing hit detection.</para>
        /// </summary>
        public unsafe partial class SkeletonBounds : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 128)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Pool.__Internalc__N_spine_S_Pool____N_spine_S_Polygon _polygonPool;
                internal global::spine_cpp.Spine.Vector.__Internal _boundingBoxes;
                internal global::spine_cpp.Spine.Vector.__Internal _polygons;
                internal float _minX;
                internal float _minY;
                internal float _maxX;
                internal float _maxY;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0SkeletonBounds@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0SkeletonBounds@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?update@SkeletonBounds@spine@@QEAAXAEAVSkeleton@2@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Update(__IntPtr __instance, __IntPtr skeleton, bool updateAabb);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?aabbcontainsPoint@SkeletonBounds@spine@@QEAA_NMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool AabbcontainsPoint(__IntPtr __instance, float x, float y);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?aabbintersectsSegment@SkeletonBounds@spine@@QEAA_NMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool AabbintersectsSegment(__IntPtr __instance, float x1, float y1, float x2, float y2);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?aabbIntersectsSkeleton@SkeletonBounds@spine@@QEAA_NV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool AabbIntersectsSkeleton(__IntPtr __instance, __IntPtr bounds);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?containsPoint@SkeletonBounds@spine@@QEAA_NPEAVPolygon@2@MM@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ContainsPoint(__IntPtr __instance, __IntPtr polygon, float x, float y);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?containsPoint@SkeletonBounds@spine@@QEAAPEAVBoundingBoxAttachment@2@MM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ContainsPoint(__IntPtr __instance, float x, float y);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?intersectsSegment@SkeletonBounds@spine@@QEAAPEAVBoundingBoxAttachment@2@MMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr IntersectsSegment(__IntPtr __instance, float x1, float y1, float x2, float y2);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?intersectsSegment@SkeletonBounds@spine@@QEAA_NPEAVPolygon@2@MMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IntersectsSegment(__IntPtr __instance, __IntPtr polygon, float x1, float y1, float x2, float y2);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getPolygon@SkeletonBounds@spine@@QEAAPEAVPolygon@2@PEAVBoundingBoxAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetPolygon(__IntPtr __instance, __IntPtr attachment);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBoundingBox@SkeletonBounds@spine@@QEAAPEAVBoundingBoxAttachment@2@PEAVPolygon@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBoundingBox(__IntPtr __instance, __IntPtr polygon);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getWidth@SkeletonBounds@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWidth(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getHeight@SkeletonBounds@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetHeight(__IntPtr __instance);
            }

            internal static new SkeletonBounds __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SkeletonBounds(native.ToPointer(), skipVTables);
            }

            internal static new SkeletonBounds __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SkeletonBounds)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new SkeletonBounds __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (SkeletonBounds)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static SkeletonBounds __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SkeletonBounds(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.SkeletonBounds.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private SkeletonBounds(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SkeletonBounds(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public SkeletonBounds()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonBounds.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonBounds");
            }

            public SkeletonBounds(global::spine_cpp.Spine.SkeletonBounds _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonBounds.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonBounds");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Clears any previous polygons, finds all visible bounding box attachments,</para>
            /// <para>and computes the world vertices for each bounding box's polygon.</para>
            /// </summary>
            /// <param name="skeleton">The skeleton.</param>
            /// <param name="updateAabb">
            /// <para>If true, the axis aligned bounding box containing all the polygons is computed.</para>
            /// <para>If false, the SkeletonBounds AABB methods will always return true.</para>
            /// </param>
            public void Update(global::spine_cpp.Spine.Skeleton skeleton, bool updateAabb)
            {
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skeleton.__Instance;
                __Internal.Update(__Instance, __arg0, updateAabb);
            }

            /// <summary>Returns true if the axis aligned bounding box contains the point.</summary>
            public bool AabbcontainsPoint(float x, float y)
            {
                var ___ret = __Internal.AabbcontainsPoint(__Instance, x, y);
                return ___ret;
            }

            /// <summary>Returns true if the axis aligned bounding box intersects the line segment.</summary>
            public bool AabbintersectsSegment(float x1, float y1, float x2, float y2)
            {
                var ___ret = __Internal.AabbintersectsSegment(__Instance, x1, y1, x2, y2);
                return ___ret;
            }

            /// <summary>Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds.</summary>
            public bool AabbIntersectsSkeleton(global::spine_cpp.Spine.SkeletonBounds bounds)
            {
                if (ReferenceEquals(bounds, null))
                    throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
                var __arg0 = bounds.__Instance;
                var ___ret = __Internal.AabbIntersectsSkeleton(__Instance, __arg0);
                return ___ret;
            }

            /// <summary>Returns true if the polygon contains the point.</summary>
            public bool ContainsPoint(global::spine_cpp.Spine.Polygon polygon, float x, float y)
            {
                var __arg0 = polygon is null ? __IntPtr.Zero : polygon.__Instance;
                var ___ret = __Internal.ContainsPoint(__Instance, __arg0, x, y);
                return ___ret;
            }

            /// <summary>
            /// <para>Returns the first bounding box attachment that contains the point, or NULL. When doing many checks, it is usually more</para>
            /// <para>efficient to only call this method if {</para>
            /// </summary>
            public global::spine_cpp.Spine.BoundingBoxAttachment ContainsPoint(float x, float y)
            {
                var ___ret = __Internal.ContainsPoint(__Instance, x, y);
                var __result0 = global::spine_cpp.Spine.BoundingBoxAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>
            /// <para>Returns the first bounding box attachment that contains the line segment, or NULL. When doing many checks, it is usually</para>
            /// <para>more efficient to only call this method if {</para>
            /// </summary>
            public global::spine_cpp.Spine.BoundingBoxAttachment IntersectsSegment(float x1, float y1, float x2, float y2)
            {
                var ___ret = __Internal.IntersectsSegment(__Instance, x1, y1, x2, y2);
                var __result0 = global::spine_cpp.Spine.BoundingBoxAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Returns true if the polygon contains the line segment.</summary>
            public bool IntersectsSegment(global::spine_cpp.Spine.Polygon polygon, float x1, float y1, float x2, float y2)
            {
                var __arg0 = polygon is null ? __IntPtr.Zero : polygon.__Instance;
                var ___ret = __Internal.IntersectsSegment(__Instance, __arg0, x1, y1, x2, y2);
                return ___ret;
            }

            /// <summary>
            /// <para>Returns the polygon for the given bounding box attachment or null if no</para>
            /// <para>polygon can be found for the attachment. Requires a call to update() first.</para>
            /// </summary>
            public global::spine_cpp.Spine.Polygon GetPolygon(global::spine_cpp.Spine.BoundingBoxAttachment attachment)
            {
                var __arg0 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
                var ___ret = __Internal.GetPolygon(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.Polygon.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Returns the bounding box for the given polygon or null. Requires a call to update() first.</summary>
            public global::spine_cpp.Spine.BoundingBoxAttachment GetBoundingBox(global::spine_cpp.Spine.Polygon polygon)
            {
                var __arg0 = polygon is null ? __IntPtr.Zero : polygon.__Instance;
                var ___ret = __Internal.GetBoundingBox(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.BoundingBoxAttachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public float Width
            {
                get
                {
                    var ___ret = __Internal.GetWidth(__Instance);
                    return ___ret;
                }
            }

            public float Height
            {
                get
                {
                    var ___ret = __Internal.GetHeight(__Instance);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // ~SkeletonBounds()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.SkeletonBounds.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class Polygon : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 48)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _vertices;
                internal int _count;

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Polygon@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Polygon@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new Polygon __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Polygon(native.ToPointer(), skipVTables);
            }

            internal static new Polygon __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Polygon)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Polygon __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Polygon)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Polygon __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Polygon(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Polygon.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Polygon(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Polygon(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Polygon()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Polygon.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Polygon");
            }

            public Polygon(global::spine_cpp.Spine.Polygon _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Polygon.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Polygon");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public int Count
            {
                get
                {
                    return ((__Internal*)__Instance)->_count;
                }

                set
                {
                    ((__Internal*)__Instance)->_count = value;
                }
            }

            #region Virtual table interop

            // Polygon
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Polygon.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class Triangulator : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 248)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _convexPolygons;
                internal global::spine_cpp.Spine.Vector.__Internal _convexPolygonsIndices;
                internal global::spine_cpp.Spine.Vector.__Internal _indices;
                internal global::spine_cpp.Spine.Vector.__Internal _isConcaveArray;
                internal global::spine_cpp.Spine.Vector.__Internal _triangles;
                internal global::spine_cpp.Spine.Pool.__Internalc__N_spine_S_Pool____N_spine_S_Vector__f _polygonPool;
                internal global::spine_cpp.Spine.Pool.__Internalc__N_spine_S_Pool____N_spine_S_Vector__I _polygonIndicesPool;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Triangulator@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Triangulator@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new Triangulator __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Triangulator(native.ToPointer(), skipVTables);
            }

            internal static new Triangulator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Triangulator)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Triangulator __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Triangulator)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Triangulator __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Triangulator(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Triangulator.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Triangulator(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Triangulator(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Triangulator(global::spine_cpp.Spine.Triangulator _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Triangulator.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Triangulator");
            }

            public Triangulator()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Triangulator.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Triangulator");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~Triangulator()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Triangulator.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class SkeletonClipping : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 464)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Triangulator.__Internal _triangulator;
                internal global::spine_cpp.Spine.Vector.__Internal _clippingPolygon;
                internal global::spine_cpp.Spine.Vector.__Internal _clipOutput;
                internal global::spine_cpp.Spine.Vector.__Internal _clippedVertices;
                internal global::spine_cpp.Spine.Vector.__Internal _clippedTriangles;
                internal global::spine_cpp.Spine.Vector.__Internal _clippedUVs;
                internal global::spine_cpp.Spine.Vector.__Internal _scratch;
                internal __IntPtr _clipAttachment;
                internal __IntPtr _clippingPolygons;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0SkeletonClipping@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0SkeletonClipping@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?clipStart@SkeletonClipping@spine@@QEAA_KAEAVSlot@2@PEAVClippingAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong ClipStart(__IntPtr __instance, __IntPtr slot, __IntPtr clip);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?clipEnd@SkeletonClipping@spine@@QEAAXAEAVSlot@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClipEnd(__IntPtr __instance, __IntPtr slot);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?clipEnd@SkeletonClipping@spine@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClipEnd(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?clipTriangles@SkeletonClipping@spine@@QEAAXPEAMPEAG_K02@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClipTriangles(__IntPtr __instance, float* vertices, ushort* triangles, ulong trianglesLength, float* uvs, ulong stride);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?isClipping@SkeletonClipping@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsClipping(__IntPtr __instance);
            }

            internal static new SkeletonClipping __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SkeletonClipping(native.ToPointer(), skipVTables);
            }

            internal static new SkeletonClipping __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SkeletonClipping)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new SkeletonClipping __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (SkeletonClipping)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static SkeletonClipping __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SkeletonClipping(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.SkeletonClipping.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private SkeletonClipping(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SkeletonClipping(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public SkeletonClipping()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonClipping.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonClipping");
            }

            public SkeletonClipping(global::spine_cpp.Spine.SkeletonClipping _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonClipping.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonClipping");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public ulong ClipStart(global::spine_cpp.Spine.Slot slot, global::spine_cpp.Spine.ClippingAttachment clip)
            {
                if (ReferenceEquals(slot, null))
                    throw new global::System.ArgumentNullException("slot", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slot.__Instance;
                var __arg1 = clip is null ? __IntPtr.Zero : clip.__Instance;
                var ___ret = __Internal.ClipStart(__Instance, __arg0, __arg1);
                return ___ret;
            }

            public void ClipEnd(global::spine_cpp.Spine.Slot slot)
            {
                if (ReferenceEquals(slot, null))
                    throw new global::System.ArgumentNullException("slot", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slot.__Instance;
                __Internal.ClipEnd(__Instance, __arg0);
            }

            public void ClipEnd()
            {
                __Internal.ClipEnd(__Instance);
            }

            public void ClipTriangles(ref float vertices, ref ushort triangles, ulong trianglesLength, ref float uvs, ulong stride)
            {
                fixed (float* __vertices0 = &vertices)
                {
                    var __arg0 = __vertices0;
                    fixed (ushort* __triangles1 = &triangles)
                    {
                        var __arg1 = __triangles1;
                        fixed (float* __uvs3 = &uvs)
                        {
                            var __arg3 = __uvs3;
                            __Internal.ClipTriangles(__Instance, __arg0, __arg1, trianglesLength, __arg3, stride);
                        }
                    }
                }
            }

            public bool IsClipping
            {
                get
                {
                    var ___ret = __Internal.IsClipping(__Instance);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // SkeletonClipping
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.SkeletonClipping.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>Stores the setup pose and all of the stateless data for a skeleton.</summary>
        public unsafe partial class SkeletonData : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 488)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal global::spine_cpp.Spine.Vector.__Internal _slots;
                internal global::spine_cpp.Spine.Vector.__Internal _skins;
                internal __IntPtr _defaultSkin;
                internal global::spine_cpp.Spine.Vector.__Internal _events;
                internal global::spine_cpp.Spine.Vector.__Internal _animations;
                internal global::spine_cpp.Spine.Vector.__Internal _ikConstraints;
                internal global::spine_cpp.Spine.Vector.__Internal _transformConstraints;
                internal global::spine_cpp.Spine.Vector.__Internal _pathConstraints;
                internal float _x;
                internal float _y;
                internal float _width;
                internal float _height;
                internal global::spine_cpp.Spine.String.__Internal _version;
                internal global::spine_cpp.Spine.String.__Internal _hash;
                internal global::spine_cpp.Spine.Vector.__Internal _strings;
                internal float _fps;
                internal global::spine_cpp.Spine.String.__Internal _imagesPath;
                internal global::spine_cpp.Spine.String.__Internal _audioPath;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0SkeletonData@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0SkeletonData@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?findBone@SkeletonData@spine@@QEAAPEAVBoneData@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindBone(__IntPtr __instance, __IntPtr boneName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?findSlot@SkeletonData@spine@@QEAAPEAVSlotData@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindSlot(__IntPtr __instance, __IntPtr slotName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?findSkin@SkeletonData@spine@@QEAAPEAVSkin@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindSkin(__IntPtr __instance, __IntPtr skinName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?findEvent@SkeletonData@spine@@QEAAPEAVEventData@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindEvent(__IntPtr __instance, __IntPtr eventDataName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?findAnimation@SkeletonData@spine@@QEAAPEAVAnimation@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindAnimation(__IntPtr __instance, __IntPtr animationName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?findIkConstraint@SkeletonData@spine@@QEAAPEAVIkConstraintData@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindIkConstraint(__IntPtr __instance, __IntPtr constraintName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?findTransformConstraint@SkeletonData@spine@@QEAAPEAVTransformConstraintData@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindTransformConstraint(__IntPtr __instance, __IntPtr constraintName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?findPathConstraint@SkeletonData@spine@@QEAAPEAVPathConstraintData@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindPathConstraint(__IntPtr __instance, __IntPtr constraintName);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getName@SkeletonData@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setName@SkeletonData@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetName(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getDefaultSkin@SkeletonData@spine@@QEAAPEAVSkin@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDefaultSkin(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setDefaultSkin@SkeletonData@spine@@QEAAXPEAVSkin@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDefaultSkin(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getX@SkeletonData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setX@SkeletonData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getY@SkeletonData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setY@SkeletonData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getWidth@SkeletonData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWidth(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setWidth@SkeletonData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWidth(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getHeight@SkeletonData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetHeight(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setHeight@SkeletonData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHeight(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getVersion@SkeletonData@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetVersion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setVersion@SkeletonData@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVersion(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getHash@SkeletonData@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetHash(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setHash@SkeletonData@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHash(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getImagesPath@SkeletonData@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetImagesPath(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setImagesPath@SkeletonData@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetImagesPath(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAudioPath@SkeletonData@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAudioPath(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAudioPath@SkeletonData@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAudioPath(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getFps@SkeletonData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetFps(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setFps@SkeletonData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFps(__IntPtr __instance, float inValue);
            }

            internal static new SkeletonData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SkeletonData(native.ToPointer(), skipVTables);
            }

            internal static new SkeletonData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SkeletonData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new SkeletonData __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (SkeletonData)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static SkeletonData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SkeletonData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.SkeletonData.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private SkeletonData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SkeletonData(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public SkeletonData()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonData");
            }

            public SkeletonData(global::spine_cpp.Spine.SkeletonData _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonData");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Finds a bone by comparing each bone's name.</para>
            /// <para>It is more efficient to cache the results of this method than to call it multiple times.</para>
            /// </summary>
            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.BoneData FindBone(global::spine_cpp.Spine.String boneName)
            {
                if (ReferenceEquals(boneName, null))
                    throw new global::System.ArgumentNullException("boneName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = boneName.__Instance;
                var ___ret = __Internal.FindBone(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.BoneData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.SlotData FindSlot(global::spine_cpp.Spine.String slotName)
            {
                if (ReferenceEquals(slotName, null))
                    throw new global::System.ArgumentNullException("slotName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = slotName.__Instance;
                var ___ret = __Internal.FindSlot(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.SlotData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.Skin FindSkin(global::spine_cpp.Spine.String skinName)
            {
                if (ReferenceEquals(skinName, null))
                    throw new global::System.ArgumentNullException("skinName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = skinName.__Instance;
                var ___ret = __Internal.FindSkin(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.EventData FindEvent(global::spine_cpp.Spine.String eventDataName)
            {
                if (ReferenceEquals(eventDataName, null))
                    throw new global::System.ArgumentNullException("eventDataName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = eventDataName.__Instance;
                var ___ret = __Internal.FindEvent(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.EventData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.Animation FindAnimation(global::spine_cpp.Spine.String animationName)
            {
                if (ReferenceEquals(animationName, null))
                    throw new global::System.ArgumentNullException("animationName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = animationName.__Instance;
                var ___ret = __Internal.FindAnimation(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.Animation.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.IkConstraintData FindIkConstraint(global::spine_cpp.Spine.String constraintName)
            {
                if (ReferenceEquals(constraintName, null))
                    throw new global::System.ArgumentNullException("constraintName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = constraintName.__Instance;
                var ___ret = __Internal.FindIkConstraint(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.IkConstraintData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.TransformConstraintData FindTransformConstraint(global::spine_cpp.Spine.String constraintName)
            {
                if (ReferenceEquals(constraintName, null))
                    throw new global::System.ArgumentNullException("constraintName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = constraintName.__Instance;
                var ___ret = __Internal.FindTransformConstraint(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.TransformConstraintData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.PathConstraintData FindPathConstraint(global::spine_cpp.Spine.String constraintName)
            {
                if (ReferenceEquals(constraintName, null))
                    throw new global::System.ArgumentNullException("constraintName", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = constraintName.__Instance;
                var ___ret = __Internal.FindPathConstraint(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.PathConstraintData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetName(__Instance, __arg0);
                }
            }

            /// <summary>
            /// <para>The skeleton's default skin.</para>
            /// <para>By default this skin contains all attachments that were not in a skin in Spine.</para>
            /// </summary>
            /// <returns>May be NULL.</returns>
            public global::spine_cpp.Spine.Skin DefaultSkin
            {
                get
                {
                    var ___ret = __Internal.GetDefaultSkin(__Instance);
                    var __result0 = global::spine_cpp.Spine.Skin.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetDefaultSkin(__Instance, __arg0);
                }
            }

            public float X
            {
                get
                {
                    var ___ret = __Internal.GetX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetX(__Instance, value);
                }
            }

            public float Y
            {
                get
                {
                    var ___ret = __Internal.GetY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetY(__Instance, value);
                }
            }

            public float Width
            {
                get
                {
                    var ___ret = __Internal.GetWidth(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetWidth(__Instance, value);
                }
            }

            public float Height
            {
                get
                {
                    var ___ret = __Internal.GetHeight(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHeight(__Instance, value);
                }
            }

            /// <summary>The Spine version used to export this data, or NULL.</summary>
            public global::spine_cpp.Spine.String Version
            {
                get
                {
                    var ___ret = __Internal.GetVersion(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetVersion(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.String Hash
            {
                get
                {
                    var ___ret = __Internal.GetHash(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetHash(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.String ImagesPath
            {
                get
                {
                    var ___ret = __Internal.GetImagesPath(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetImagesPath(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.String AudioPath
            {
                get
                {
                    var ___ret = __Internal.GetAudioPath(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetAudioPath(__Instance, __arg0);
                }
            }

            /// <summary>The dopesheet FPS in Spine. Available only when nonessential data was exported.</summary>
            public float Fps
            {
                get
                {
                    var ___ret = __Internal.GetFps(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetFps(__Instance, value);
                }
            }

            #region Virtual table interop

            // ~SkeletonData()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.SkeletonData.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class SkeletonJson : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 88)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _attachmentLoader;
                internal global::spine_cpp.Spine.Vector.__Internal _linkedMeshes;
                internal float _scale;
                internal byte _ownsLoader;
                internal global::spine_cpp.Spine.String.__Internal _error;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0SkeletonJson@spine@@QEAA@PEAVAtlas@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr atlas);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0SkeletonJson@spine@@QEAA@PEAVAttachmentLoader@1@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr attachmentLoader, bool ownsLoader);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0SkeletonJson@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?readSkeletonDataFile@SkeletonJson@spine@@QEAAPEAVSkeletonData@2@AEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ReadSkeletonDataFile(__IntPtr __instance, __IntPtr path);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?readSkeletonData@SkeletonJson@spine@@QEAAPEAVSkeletonData@2@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ReadSkeletonData(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string json);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setScale@SkeletonJson@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScale(__IntPtr __instance, float scale);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getError@SkeletonJson@spine@@QEAAAEAVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetError(__IntPtr __instance);
            }

            internal static new SkeletonJson __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SkeletonJson(native.ToPointer(), skipVTables);
            }

            internal static new SkeletonJson __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SkeletonJson)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new SkeletonJson __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (SkeletonJson)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static SkeletonJson __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SkeletonJson(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.SkeletonJson.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private SkeletonJson(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SkeletonJson(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public SkeletonJson(global::spine_cpp.Spine.Atlas atlas)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonJson.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = atlas is null ? __IntPtr.Zero : atlas.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonJson");
            }

            public SkeletonJson(global::spine_cpp.Spine.AttachmentLoader attachmentLoader, bool ownsLoader)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonJson.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = attachmentLoader is null ? __IntPtr.Zero : attachmentLoader.__Instance;
                __Internal.ctor(__Instance, __arg0, ownsLoader);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonJson");
            }

            public SkeletonJson(global::spine_cpp.Spine.SkeletonJson _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SkeletonJson.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SkeletonJson");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::spine_cpp.Spine.SkeletonData ReadSkeletonDataFile(global::spine_cpp.Spine.String path)
            {
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = path.__Instance;
                var ___ret = __Internal.ReadSkeletonDataFile(__Instance, __arg0);
                var __result0 = global::spine_cpp.Spine.SkeletonData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public global::spine_cpp.Spine.SkeletonData ReadSkeletonData(string json)
            {
                var ___ret = __Internal.ReadSkeletonData(__Instance, json);
                var __result0 = global::spine_cpp.Spine.SkeletonData.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public void SetScale(float scale)
            {
                __Internal.SetScale(__Instance, scale);
            }

            public static explicit operator global::spine_cpp.Spine.SkeletonJson(global::spine_cpp.Spine.Atlas atlas)
            {
                return new global::spine_cpp.Spine.SkeletonJson(atlas);
            }

            public global::spine_cpp.Spine.String Error
            {
                get
                {
                    var ___ret = __Internal.GetError(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            #region Virtual table interop

            // ~SkeletonJson()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.SkeletonJson.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>
        /// <para>Stores attachments by slot index and attachment name.</para>
        /// <para>See SkeletonData::getDefaultSkin, Skeleton::getSkin, and</para>
        /// <para>http://esotericsoftware.com/spine-runtime-skins in the Spine Runtimes Guide.</para>
        /// </summary>
        public unsafe partial class Skin : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 144)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal global::spine_cpp.Spine.Skin.AttachmentMap.__Internal _attachments;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal global::spine_cpp.Spine.Vector.__Internal _constraints;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Skin@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Skin@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAttachment@Skin@spine@@QEAAX_KAEBVString@2@PEAVAttachment@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAttachment(__IntPtr __instance, ulong slotIndex, __IntPtr name, __IntPtr attachment);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAttachment@Skin@spine@@QEAAPEAVAttachment@2@_KAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAttachment(__IntPtr __instance, ulong slotIndex, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?removeAttachment@Skin@spine@@QEAAX_KAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAttachment(__IntPtr __instance, ulong slotIndex, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?addSkin@Skin@spine@@QEAAXPEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddSkin(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?copySkin@Skin@spine@@QEAAXPEAV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CopySkin(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getName@Skin@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAttachments@Skin@spine@@QEAA?AVEntries@AttachmentMap@12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetAttachments(__IntPtr __instance, __IntPtr @return);
            }

            public unsafe partial class AttachmentMap : global::spine_cpp.Spine.SpineObject, IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public new partial struct __Internal
                {
                    internal __IntPtr vfptr_SpineObject;
                    internal global::spine_cpp.Spine.Vector.__Internal _buckets;

                    [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AttachmentMap@Skin@spine@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern __IntPtr ctor(__IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0AttachmentMap@Skin@spine@@QEAA@AEBV012@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                    [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?put@AttachmentMap@Skin@spine@@QEAAX_KAEBVString@3@PEAVAttachment@3@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern void Put(__IntPtr __instance, ulong slotIndex, __IntPtr attachmentName, __IntPtr attachment);

                    [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?get@AttachmentMap@Skin@spine@@QEAAPEAVAttachment@3@_KAEBVString@3@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern __IntPtr Get(__IntPtr __instance, ulong slotIndex, __IntPtr attachmentName);

                    [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?remove@AttachmentMap@Skin@spine@@QEAAX_KAEBVString@3@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern void Remove(__IntPtr __instance, ulong slotIndex, __IntPtr attachmentName);

                    [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getEntries@AttachmentMap@Skin@spine@@QEAA?AVEntries@123@XZ", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern void GetEntries(__IntPtr __instance, __IntPtr @return);
                }

                public unsafe partial class Entry : IDisposable
                {
                    [StructLayout(LayoutKind.Sequential, Size = 48)]
                    public partial struct __Internal
                    {
                        internal ulong _slotIndex;
                        internal global::spine_cpp.Spine.String.__Internal _name;
                        internal __IntPtr _attachment;

                        [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Entry@AttachmentMap@Skin@spine@@QEAA@_KAEBVString@3@PEAVAttachment@3@@Z", CallingConvention = __CallingConvention.Cdecl)]
                        internal static extern __IntPtr ctor(__IntPtr __instance, ulong slotIndex, __IntPtr name, __IntPtr attachment);

                        [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Entry@AttachmentMap@Skin@spine@@QEAA@AEBU0123@@Z", CallingConvention = __CallingConvention.Cdecl)]
                        internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                        [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??1Entry@AttachmentMap@Skin@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                        internal static extern void dtor(__IntPtr __instance);
                    }

                    public __IntPtr __Instance { get; protected set; }

                    internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.Skin.AttachmentMap.Entry> NativeToManagedMap =
                        new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.Skin.AttachmentMap.Entry>();

                    internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.Spine.Skin.AttachmentMap.Entry managed)
                    {
                        NativeToManagedMap[native] = managed;
                    }

                    internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.Spine.Skin.AttachmentMap.Entry managed)
                    {
    
                        return NativeToManagedMap.TryGetValue(native, out managed);
                    }

                    protected bool __ownsNativeInstance;

                    internal static Entry __CreateInstance(__IntPtr native, bool skipVTables = false)
                    {
                        if (native == __IntPtr.Zero)
                            return null;
                        return new Entry(native.ToPointer(), skipVTables);
                    }

                    internal static Entry __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                    {
                        if (native == __IntPtr.Zero)
                            return null;
                        if (__TryGetNativeToManagedMapping(native, out var managed))
                            return (Entry)managed;
                        var result = __CreateInstance(native, skipVTables);
                        if (saveInstance)
                            __RecordNativeToManagedMapping(native, result);
                        return result;
                    }

                    internal static Entry __CreateInstance(__Internal native, bool skipVTables = false)
                    {
                        return new Entry(native, skipVTables);
                    }

                    private static void* __CopyValue(__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                        global::spine_cpp.Spine.Skin.AttachmentMap.Entry.__Internal.cctor(ret, new __IntPtr(&native));
                        return ret.ToPointer();
                    }

                    private Entry(__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        __RecordNativeToManagedMapping(__Instance, this);
                    }

                    protected Entry(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new __IntPtr(native);
                    }

                    public Entry(ulong slotIndex, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.Attachment attachment)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Skin.AttachmentMap.Entry.__Internal));
                        __ownsNativeInstance = true;
                        __RecordNativeToManagedMapping(__Instance, this);
                        if (ReferenceEquals(name, null))
                            throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                        var __arg1 = name.__Instance;
                        var __arg2 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
                        __Internal.ctor(__Instance, slotIndex, __arg1, __arg2);
                    }

                    public Entry(global::spine_cpp.Spine.Skin.AttachmentMap.Entry _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Skin.AttachmentMap.Entry.__Internal));
                        __ownsNativeInstance = true;
                        __RecordNativeToManagedMapping(__Instance, this);
                        if (ReferenceEquals(_0, null))
                            throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                        var __arg0 = _0.__Instance;
                        __Internal.cctor(__Instance, __arg0);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                    }

                    partial void DisposePartial(bool disposing);

                    internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        NativeToManagedMap.TryRemove(__Instance, out _);
                        DisposePartial(disposing);
                        if (callNativeDtor)
                            __Internal.dtor(__Instance);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }

                    public ulong SlotIndex
                    {
                        get
                        {
                            return ((__Internal*)__Instance)->_slotIndex;
                        }

                        set
                        {
                            ((__Internal*)__Instance)->_slotIndex = value;
                        }
                    }

                    public global::spine_cpp.Spine.String Name
                    {
                        get
                        {
                            return global::spine_cpp.Spine.String.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_name));
                        }

                        set
                        {
                            if (ReferenceEquals(value, null))
                                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                            ((__Internal*)__Instance)->_name = *(global::spine_cpp.Spine.String.__Internal*) value.__Instance;
                        }
                    }

                    public global::spine_cpp.Spine.Attachment Attachment
                    {
                        get
                        {
                            var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(((__Internal*)__Instance)->_attachment, true);
                            return __result0;
                        }

                        set
                        {
                            ((__Internal*)__Instance)->_attachment = value is null ? __IntPtr.Zero : value.__Instance;
                        }
                    }
                }

                public unsafe partial class Entries : IDisposable
                {
                    [StructLayout(LayoutKind.Sequential, Size = 24)]
                    public partial struct __Internal
                    {
                        internal __IntPtr _buckets;
                        internal ulong _slotIndex;
                        internal ulong _bucketIndex;

                        [SuppressUnmanagedCodeSecurity, DllImport("spine_cpp", EntryPoint = "??0Entries@AttachmentMap@Skin@spine@@QEAA@AEBV0123@@Z", CallingConvention = __CallingConvention.Cdecl)]
                        internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                        [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?hasNext@Entries@AttachmentMap@Skin@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                        [return: MarshalAs(UnmanagedType.I1)]
                        internal static extern bool HasNext(__IntPtr __instance);

                        [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?next@Entries@AttachmentMap@Skin@spine@@QEAAAEAUEntry@234@XZ", CallingConvention = __CallingConvention.Cdecl)]
                        internal static extern __IntPtr Next(__IntPtr __instance);
                    }

                    public __IntPtr __Instance { get; protected set; }

                    internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.Skin.AttachmentMap.Entries> NativeToManagedMap =
                        new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::spine_cpp.Spine.Skin.AttachmentMap.Entries>();

                    internal static void __RecordNativeToManagedMapping(IntPtr native, global::spine_cpp.Spine.Skin.AttachmentMap.Entries managed)
                    {
                        NativeToManagedMap[native] = managed;
                    }

                    internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::spine_cpp.Spine.Skin.AttachmentMap.Entries managed)
                    {
    
                        return NativeToManagedMap.TryGetValue(native, out managed);
                    }

                    protected bool __ownsNativeInstance;

                    internal static Entries __CreateInstance(__IntPtr native, bool skipVTables = false)
                    {
                        if (native == __IntPtr.Zero)
                            return null;
                        return new Entries(native.ToPointer(), skipVTables);
                    }

                    internal static Entries __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                    {
                        if (native == __IntPtr.Zero)
                            return null;
                        if (__TryGetNativeToManagedMapping(native, out var managed))
                            return (Entries)managed;
                        var result = __CreateInstance(native, skipVTables);
                        if (saveInstance)
                            __RecordNativeToManagedMapping(native, result);
                        return result;
                    }

                    internal static Entries __CreateInstance(__Internal native, bool skipVTables = false)
                    {
                        return new Entries(native, skipVTables);
                    }

                    private static void* __CopyValue(__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                        *(__Internal*) ret = native;
                        return ret.ToPointer();
                    }

                    private Entries(__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        __RecordNativeToManagedMapping(__Instance, this);
                    }

                    protected Entries(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new __IntPtr(native);
                    }

                    public Entries(global::spine_cpp.Spine.Skin.AttachmentMap.Entries _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Skin.AttachmentMap.Entries.__Internal));
                        __ownsNativeInstance = true;
                        __RecordNativeToManagedMapping(__Instance, this);
                        *((global::spine_cpp.Spine.Skin.AttachmentMap.Entries.__Internal*) __Instance) = *((global::spine_cpp.Spine.Skin.AttachmentMap.Entries.__Internal*) _0.__Instance);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                    }

                    partial void DisposePartial(bool disposing);

                    internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        NativeToManagedMap.TryRemove(__Instance, out _);
                        DisposePartial(disposing);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }

                    public bool HasNext
                    {
                        get
                        {
                            var ___ret = __Internal.HasNext(__Instance);
                            return ___ret;
                        }
                    }

                    public global::spine_cpp.Spine.Skin.AttachmentMap.Entry Next
                    {
                        get
                        {
                            var ___ret = __Internal.Next(__Instance);
                            var __result0 = global::spine_cpp.Spine.Skin.AttachmentMap.Entry.__GetOrCreateInstance(___ret, false);
                            return __result0;
                        }
                    }
                }

                internal static new AttachmentMap __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new AttachmentMap(native.ToPointer(), skipVTables);
                }

                internal static new AttachmentMap __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (AttachmentMap)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static new AttachmentMap __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (AttachmentMap)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static AttachmentMap __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new AttachmentMap(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    global::spine_cpp.Spine.Skin.AttachmentMap.__Internal.cctor(ret, new __IntPtr(&native));
                    return ret.ToPointer();
                }

                private AttachmentMap(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected AttachmentMap(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                    if (native == null)
                        return;
                    if (!skipVTables)
                        SetupVTables(true);
                }

                protected AttachmentMap()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Skin.AttachmentMap.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    __Internal.ctor(__Instance);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Skin.AttachmentMap");
                }

                public AttachmentMap(global::spine_cpp.Spine.Skin.AttachmentMap _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Skin.AttachmentMap.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                    SetupVTables(GetType().FullName == "spine_cpp.Spine.Skin.AttachmentMap");
                }

                partial void DisposePartial(bool disposing);

                internal protected override void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (callNativeDtor)
                    {
                        var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                        ___dtorDelegate(__Instance, 0);
                    }
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public void Put(ulong slotIndex, global::spine_cpp.Spine.String attachmentName, global::spine_cpp.Spine.Attachment attachment)
                {
                    if (ReferenceEquals(attachmentName, null))
                        throw new global::System.ArgumentNullException("attachmentName", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = attachmentName.__Instance;
                    var __arg2 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
                    __Internal.Put(__Instance, slotIndex, __arg1, __arg2);
                }

                public global::spine_cpp.Spine.Attachment Get(ulong slotIndex, global::spine_cpp.Spine.String attachmentName)
                {
                    if (ReferenceEquals(attachmentName, null))
                        throw new global::System.ArgumentNullException("attachmentName", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = attachmentName.__Instance;
                    var ___ret = __Internal.Get(__Instance, slotIndex, __arg1);
                    var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                public void Remove(ulong slotIndex, global::spine_cpp.Spine.String attachmentName)
                {
                    if (ReferenceEquals(attachmentName, null))
                        throw new global::System.ArgumentNullException("attachmentName", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = attachmentName.__Instance;
                    __Internal.Remove(__Instance, slotIndex, __arg1);
                }

                public global::spine_cpp.Spine.Skin.AttachmentMap.Entries entries
                {
                    get
                    {
                        var ___ret = new global::spine_cpp.Spine.Skin.AttachmentMap.Entries.__Internal();
                        __Internal.GetEntries(__Instance, new IntPtr(&___ret));
                        return global::spine_cpp.Spine.Skin.AttachmentMap.Entries.__CreateInstance(___ret);
                    }
                }

                #region Virtual table interop

                // AttachmentMap
                private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::spine_cpp.Spine.Skin.AttachmentMap.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static new class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[1];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                internal override CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal override void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            internal static new Skin __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Skin(native.ToPointer(), skipVTables);
            }

            internal static new Skin __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Skin)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Skin __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Skin)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Skin __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Skin(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Skin.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Skin(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Skin(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Skin(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Skin.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Skin");
            }

            public Skin(global::spine_cpp.Spine.Skin _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Skin.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Skin");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Adds an attachment to the skin for the specified slot index and name.</para>
            /// <para>If the name already exists for the slot, the previous value is replaced.</para>
            /// </summary>
            public void SetAttachment(ulong slotIndex, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.Attachment attachment)
            {
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var __arg2 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
                __Internal.SetAttachment(__Instance, slotIndex, __arg1, __arg2);
            }

            /// <summary>Returns the attachment for the specified slot index and name, or NULL.</summary>
            public global::spine_cpp.Spine.Attachment GetAttachment(ulong slotIndex, global::spine_cpp.Spine.String name)
            {
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                var ___ret = __Internal.GetAttachment(__Instance, slotIndex, __arg1);
                var __result0 = global::spine_cpp.Spine.Attachment.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public void RemoveAttachment(ulong slotIndex, global::spine_cpp.Spine.String name)
            {
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                __Internal.RemoveAttachment(__Instance, slotIndex, __arg1);
            }

            /// <summary>Adds all attachments, bones, and constraints from the specified skin to this skin.</summary>
            public void AddSkin(global::spine_cpp.Spine.Skin other)
            {
                var __arg0 = other is null ? __IntPtr.Zero : other.__Instance;
                __Internal.AddSkin(__Instance, __arg0);
            }

            /// <summary>Adds all attachments, bones, and constraints from the specified skin to this skin. Attachments are deep copied.</summary>
            public void CopySkin(global::spine_cpp.Spine.Skin other)
            {
                var __arg0 = other is null ? __IntPtr.Zero : other.__Instance;
                __Internal.CopySkin(__Instance, __arg0);
            }

            public static explicit operator global::spine_cpp.Spine.Skin(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.Skin(name);
            }

            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Skin.AttachmentMap.Entries Attachments
            {
                get
                {
                    var ___ret = new global::spine_cpp.Spine.Skin.AttachmentMap.Entries.__Internal();
                    __Internal.GetAttachments(__Instance, new IntPtr(&___ret));
                    return global::spine_cpp.Spine.Skin.AttachmentMap.Entries.__CreateInstance(___ret);
                }
            }

            #region Virtual table interop

            // ~Skin()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Skin.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class SlotData : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 152)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal int _index;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal __IntPtr _boneData;
                internal global::spine_cpp.Spine.Color.__Internal _color;
                internal global::spine_cpp.Spine.Color.__Internal _darkColor;
                internal byte _hasDarkColor;
                internal global::spine_cpp.Spine.String.__Internal _attachmentName;
                internal global::spine_cpp.Spine.BlendMode _blendMode;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0SlotData@spine@@QEAA@HAEBVString@1@AEAVBoneData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, int index, __IntPtr name, __IntPtr boneData);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0SlotData@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getIndex@SlotData@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getName@SlotData@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBoneData@SlotData@spine@@QEAAAEAVBoneData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBoneData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getColor@SlotData@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getDarkColor@SlotData@spine@@QEAAAEAVColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDarkColor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?hasDarkColor@SlotData@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasDarkColor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setHasDarkColor@SlotData@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHasDarkColor(__IntPtr __instance, bool inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getAttachmentName@SlotData@spine@@QEAAAEBVString@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAttachmentName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setAttachmentName@SlotData@spine@@QEAAXAEBVString@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAttachmentName(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getBlendMode@SlotData@spine@@QEAA?AW4BlendMode@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::spine_cpp.Spine.BlendMode GetBlendMode(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setBlendMode@SlotData@spine@@QEAAXW4BlendMode@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBlendMode(__IntPtr __instance, global::spine_cpp.Spine.BlendMode inValue);
            }

            internal static new SlotData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SlotData(native.ToPointer(), skipVTables);
            }

            internal static new SlotData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SlotData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new SlotData __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (SlotData)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static SlotData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SlotData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.SlotData.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private SlotData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SlotData(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public SlotData(int index, global::spine_cpp.Spine.String name, global::spine_cpp.Spine.BoneData boneData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SlotData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = name.__Instance;
                if (ReferenceEquals(boneData, null))
                    throw new global::System.ArgumentNullException("boneData", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = boneData.__Instance;
                __Internal.ctor(__Instance, index, __arg1, __arg2);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SlotData");
            }

            public SlotData(global::spine_cpp.Spine.SlotData _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.SlotData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.SlotData");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public int Index
            {
                get
                {
                    var ___ret = __Internal.GetIndex(__Instance);
                    return ___ret;
                }
            }

            public global::spine_cpp.Spine.String Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.BoneData BoneData
            {
                get
                {
                    var ___ret = __Internal.GetBoneData(__Instance);
                    var __result0 = global::spine_cpp.Spine.BoneData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Color Color
            {
                get
                {
                    var ___ret = __Internal.GetColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Color DarkColor
            {
                get
                {
                    var ___ret = __Internal.GetDarkColor(__Instance);
                    var __result0 = global::spine_cpp.Spine.Color.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public bool HasDarkColor
            {
                get
                {
                    var ___ret = __Internal.HasDarkColor(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHasDarkColor(__Instance, value);
                }
            }

            /// <summary>May be empty.</summary>
            public global::spine_cpp.Spine.String AttachmentName
            {
                get
                {
                    var ___ret = __Internal.GetAttachmentName(__Instance);
                    var __result0 = global::spine_cpp.Spine.String.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetAttachmentName(__Instance, __arg0);
                }
            }

            public global::spine_cpp.Spine.BlendMode BlendMode
            {
                get
                {
                    var ___ret = __Internal.GetBlendMode(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBlendMode(__Instance, value);
                }
            }

            #region Virtual table interop

            // SlotData
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.SlotData.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe abstract partial class TextureLoader : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0TextureLoader@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0TextureLoader@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new TextureLoader __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TextureLoaderInternal(native.ToPointer(), skipVTables);
            }

            internal static new TextureLoader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TextureLoader)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new TextureLoader __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (TextureLoader)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static TextureLoader __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TextureLoaderInternal(native, skipVTables);
            }

            protected TextureLoader(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected TextureLoader()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TextureLoader.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TextureLoader");
            }

            protected TextureLoader(global::spine_cpp.Spine.TextureLoader _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TextureLoader.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TextureLoader");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract void Load(global::spine_cpp.Spine.AtlasPage page, global::spine_cpp.Spine.String path);

            public abstract void Unload(__IntPtr texture);

            #region Virtual table interop

            // virtual ~TextureLoader()
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.TextureLoader.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void load(AtlasPage &page, const String &path) = 0
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr___IntPtr _LoadDelegateInstance;

            private static void _LoadDelegateHook(__IntPtr __instance, __IntPtr page, __IntPtr path)
            {
                var __target = global::spine_cpp.Spine.TextureLoader.__GetInstance(__instance);
                var __result0 = global::spine_cpp.Spine.AtlasPage.__GetOrCreateInstance(page, false, skipVTables: true);
                var __result1 = global::spine_cpp.Spine.String.__GetOrCreateInstance(path, false, skipVTables: true);
                __target.Load(__result0, __result1);
            }

            // void unload(void *texture) = 0
            private static global::spine_cpp.Delegates.Action___IntPtr___IntPtr _UnloadDelegateInstance;

            private static void _UnloadDelegateHook(__IntPtr __instance, __IntPtr texture)
            {
                var __target = global::spine_cpp.Spine.TextureLoader.__GetInstance(__instance);
                __target.Unload(texture);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _LoadDelegateInstance += _LoadDelegateHook;
                    _UnloadDelegateInstance += _UnloadDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_UnloadDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class TextureLoaderInternal : global::spine_cpp.Spine.TextureLoader, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal TextureLoaderInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal TextureLoaderInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override void Load(global::spine_cpp.Spine.AtlasPage page, global::spine_cpp.Spine.String path)
            {
                var ___LoadDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 1);
                if (ReferenceEquals(page, null))
                    throw new global::System.ArgumentNullException("page", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = page.__Instance;
                if (ReferenceEquals(path, null))
                    throw new global::System.ArgumentNullException("path", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = path.__Instance;
                ___LoadDelegate(__Instance, __arg0, __arg1);
            }

            public override void Unload(__IntPtr texture)
            {
                var ___UnloadDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr___IntPtr>(0, 2);
                ___UnloadDelegate(__Instance, texture);
            }
        }
    }

    namespace Spine
    {
        public unsafe partial class TransformConstraint : global::spine_cpp.Spine.Updatable, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 88)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal __IntPtr _data;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal __IntPtr _target;
                internal float _mixRotate;
                internal float _mixX;
                internal float _mixY;
                internal float _mixScaleX;
                internal float _mixScaleY;
                internal float _mixShearY;
                internal byte _active;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0TransformConstraint@spine@@QEAA@AEAVTransformConstraintData@1@AEAVSkeleton@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr data, __IntPtr skeleton);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0TransformConstraint@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getData@TransformConstraint@spine@@QEAAAEAVTransformConstraintData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getTarget@TransformConstraint@spine@@QEAAPEAVBone@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTarget(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setTarget@TransformConstraint@spine@@QEAAXPEAVBone@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTarget(__IntPtr __instance, __IntPtr inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixRotate@TransformConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixRotate(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixRotate@TransformConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixRotate(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixX@TransformConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixX@TransformConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixY@TransformConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixY@TransformConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixScaleX@TransformConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixScaleX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixScaleX@TransformConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixScaleX(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixScaleY@TransformConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixScaleY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixScaleY@TransformConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixScaleY(__IntPtr __instance, float inValue);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixShearY@TransformConstraint@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixShearY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixShearY@TransformConstraint@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixShearY(__IntPtr __instance, float inValue);
            }

            internal static new TransformConstraint __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TransformConstraint(native.ToPointer(), skipVTables);
            }

            internal static new TransformConstraint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TransformConstraint)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new TransformConstraint __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (TransformConstraint)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static TransformConstraint __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TransformConstraint(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.TransformConstraint.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private TransformConstraint(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TransformConstraint(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public TransformConstraint(global::spine_cpp.Spine.TransformConstraintData data, global::spine_cpp.Spine.Skeleton skeleton)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TransformConstraint.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(data, null))
                    throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = data.__Instance;
                if (ReferenceEquals(skeleton, null))
                    throw new global::System.ArgumentNullException("skeleton", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = skeleton.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TransformConstraint");
            }

            public TransformConstraint(global::spine_cpp.Spine.TransformConstraint _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TransformConstraint.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TransformConstraint");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Update()
            {
                var ___UpdateDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr>(0, 2);
                ___UpdateDelegate(__Instance);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_TransformConstraint_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public virtual int Order
            {
                get
                {
                    var ___GetOrderDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_int___IntPtr>(0, 5);
                    var ___ret = ___GetOrderDelegate(__Instance);
                    return ___ret;
                }
            }

            public global::spine_cpp.Spine.TransformConstraintData Data
            {
                get
                {
                    var ___ret = __Internal.GetData(__Instance);
                    var __result0 = global::spine_cpp.Spine.TransformConstraintData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public global::spine_cpp.Spine.Bone Target
            {
                get
                {
                    var ___ret = __Internal.GetTarget(__Instance);
                    var __result0 = global::spine_cpp.Spine.Bone.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetTarget(__Instance, __arg0);
                }
            }

            public float MixRotate
            {
                get
                {
                    var ___ret = __Internal.GetMixRotate(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixRotate(__Instance, value);
                }
            }

            public float MixX
            {
                get
                {
                    var ___ret = __Internal.GetMixX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixX(__Instance, value);
                }
            }

            public float MixY
            {
                get
                {
                    var ___ret = __Internal.GetMixY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixY(__Instance, value);
                }
            }

            public float MixScaleX
            {
                get
                {
                    var ___ret = __Internal.GetMixScaleX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixScaleX(__Instance, value);
                }
            }

            public float MixScaleY
            {
                get
                {
                    var ___ret = __Internal.GetMixScaleY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixScaleY(__Instance, value);
                }
            }

            public float MixShearY
            {
                get
                {
                    var ___ret = __Internal.GetMixShearY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixShearY(__Instance, value);
                }
            }

            public override bool Active
            {
                get
                {
                    var ___IsActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Func_bool___IntPtr>(0, 3);
                    var ___ret = ___IsActiveDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetActiveDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_bool>(0, 4);
                    ___SetActiveDelegate(__Instance, value);
                }
            }

            #region Virtual table interop

            // TransformConstraint
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.TransformConstraint.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TransformConstraint.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void update()
            private static global::spine_cpp.Delegates.Action___IntPtr _UpdateDelegateInstance;

            private static void _UpdateDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TransformConstraint.__GetInstance(__instance);
                __target.Update();
            }

            // bool isActive()
            private static global::spine_cpp.Delegates.Func_bool___IntPtr _IsActiveDelegateInstance;

            private static bool _IsActiveDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TransformConstraint.__GetInstance(__instance);
                var ___ret = __target.Active;
                return ___ret;
            }

            // void setActive(bool inValue)
            private static global::spine_cpp.Delegates.Action___IntPtr_bool _SetActiveDelegateInstance;

            private static void _SetActiveDelegateHook(__IntPtr __instance, bool inValue)
            {
                var __target = global::spine_cpp.Spine.TransformConstraint.__GetInstance(__instance);
                __target.Active = inValue;
            }

            // int getOrder()
            private static global::spine_cpp.Delegates.Func_int___IntPtr _GetOrderDelegateInstance;

            private static int _GetOrderDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TransformConstraint.__GetInstance(__instance);
                var ___ret = __target.Order;
                return ___ret;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[6];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _UpdateDelegateInstance += _UpdateDelegateHook;
                    _IsActiveDelegateInstance += _IsActiveDelegateHook;
                    _SetActiveDelegateInstance += _SetActiveDelegateHook;
                    _GetOrderDelegateInstance += _GetOrderDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_IsActiveDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetActiveDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetOrderDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                VTables.Methods[0] = new Delegate[6];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class TransformConstraintData : global::spine_cpp.Spine.ConstraintData, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 152)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.String.__Internal _name;
                internal ulong _order;
                internal byte _skinRequired;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal __IntPtr _target;
                internal float _mixRotate;
                internal float _mixX;
                internal float _mixY;
                internal float _mixScaleX;
                internal float _mixScaleY;
                internal float _mixShearY;
                internal float _offsetRotation;
                internal float _offsetX;
                internal float _offsetY;
                internal float _offsetScaleX;
                internal float _offsetScaleY;
                internal float _offsetShearY;
                internal byte _relative;
                internal byte _local;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0TransformConstraintData@spine@@QEAA@AEBVString@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0TransformConstraintData@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getTarget@TransformConstraintData@spine@@QEAAPEAVBoneData@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTarget(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setTarget@TransformConstraintData@spine@@QEAAXPEAVBoneData@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTarget(__IntPtr __instance, __IntPtr target);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixRotate@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixRotate(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixRotate@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixRotate(__IntPtr __instance, float mixRotate);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixX@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixX@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixX(__IntPtr __instance, float mixX);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixY@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixY@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixY(__IntPtr __instance, float mixY);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixScaleX@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixScaleX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixScaleX@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixScaleX(__IntPtr __instance, float mixScaleX);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixScaleY@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixScaleY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixScaleY@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixScaleY(__IntPtr __instance, float mixScaleY);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getMixShearY@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetMixShearY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setMixShearY@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMixShearY(__IntPtr __instance, float mixShearY);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getOffsetRotation@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetOffsetRotation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setOffsetRotation@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetOffsetRotation(__IntPtr __instance, float offsetRotation);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getOffsetX@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetOffsetX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setOffsetX@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetOffsetX(__IntPtr __instance, float offsetX);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getOffsetY@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetOffsetY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setOffsetY@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetOffsetY(__IntPtr __instance, float offsetY);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getOffsetScaleX@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetOffsetScaleX(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setOffsetScaleX@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetOffsetScaleX(__IntPtr __instance, float offsetScaleX);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getOffsetScaleY@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetOffsetScaleY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setOffsetScaleY@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetOffsetScaleY(__IntPtr __instance, float offsetScaleY);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getOffsetShearY@TransformConstraintData@spine@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetOffsetShearY(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setOffsetShearY@TransformConstraintData@spine@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetOffsetShearY(__IntPtr __instance, float offsetShearY);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?isRelative@TransformConstraintData@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsRelative(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setRelative@TransformConstraintData@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRelative(__IntPtr __instance, bool isRelative);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?isLocal@TransformConstraintData@spine@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsLocal(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setLocal@TransformConstraintData@spine@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetLocal(__IntPtr __instance, bool isLocal);
            }

            internal static new TransformConstraintData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TransformConstraintData(native.ToPointer(), skipVTables);
            }

            internal static new TransformConstraintData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TransformConstraintData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new TransformConstraintData __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (TransformConstraintData)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static TransformConstraintData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TransformConstraintData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.TransformConstraintData.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private TransformConstraintData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TransformConstraintData(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public TransformConstraintData(global::spine_cpp.Spine.String name)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TransformConstraintData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(name, null))
                    throw new global::System.ArgumentNullException("name", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = name.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TransformConstraintData");
            }

            public TransformConstraintData(global::spine_cpp.Spine.TransformConstraintData _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TransformConstraintData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TransformConstraintData");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::spine_cpp.Spine.TransformConstraintData(global::spine_cpp.Spine.String name)
            {
                return new global::spine_cpp.Spine.TransformConstraintData(name);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_TransformConstraintData_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public global::spine_cpp.Spine.BoneData Target
            {
                get
                {
                    var ___ret = __Internal.GetTarget(__Instance);
                    var __result0 = global::spine_cpp.Spine.BoneData.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }

                set
                {
                    var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                    __Internal.SetTarget(__Instance, __arg0);
                }
            }

            public float MixRotate
            {
                get
                {
                    var ___ret = __Internal.GetMixRotate(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixRotate(__Instance, value);
                }
            }

            public float MixX
            {
                get
                {
                    var ___ret = __Internal.GetMixX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixX(__Instance, value);
                }
            }

            public float MixY
            {
                get
                {
                    var ___ret = __Internal.GetMixY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixY(__Instance, value);
                }
            }

            public float MixScaleX
            {
                get
                {
                    var ___ret = __Internal.GetMixScaleX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixScaleX(__Instance, value);
                }
            }

            public float MixScaleY
            {
                get
                {
                    var ___ret = __Internal.GetMixScaleY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixScaleY(__Instance, value);
                }
            }

            public float MixShearY
            {
                get
                {
                    var ___ret = __Internal.GetMixShearY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMixShearY(__Instance, value);
                }
            }

            public float OffsetRotation
            {
                get
                {
                    var ___ret = __Internal.GetOffsetRotation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOffsetRotation(__Instance, value);
                }
            }

            public float OffsetX
            {
                get
                {
                    var ___ret = __Internal.GetOffsetX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOffsetX(__Instance, value);
                }
            }

            public float OffsetY
            {
                get
                {
                    var ___ret = __Internal.GetOffsetY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOffsetY(__Instance, value);
                }
            }

            public float OffsetScaleX
            {
                get
                {
                    var ___ret = __Internal.GetOffsetScaleX(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOffsetScaleX(__Instance, value);
                }
            }

            public float OffsetScaleY
            {
                get
                {
                    var ___ret = __Internal.GetOffsetScaleY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOffsetScaleY(__Instance, value);
                }
            }

            public float OffsetShearY
            {
                get
                {
                    var ___ret = __Internal.GetOffsetShearY(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOffsetShearY(__Instance, value);
                }
            }

            public bool Relative
            {
                get
                {
                    var ___ret = __Internal.IsRelative(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetRelative(__Instance, value);
                }
            }

            public bool Local
            {
                get
                {
                    var ___ret = __Internal.IsLocal(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetLocal(__Instance, value);
                }
            }

            #region Virtual table interop

            // TransformConstraintData
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.TransformConstraintData.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TransformConstraintData.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class TransformConstraintTimeline : global::spine_cpp.Spine.CurveTimeline, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _propertyIds;
                internal global::spine_cpp.Spine.Vector.__Internal _frames;
                internal ulong _frameEntries;
                internal global::spine_cpp.Spine.Vector.__Internal _curves;
                internal int _transformConstraintIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0TransformConstraintTimeline@spine@@QEAA@_K0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, ulong frameCount, ulong bezierCount, int transformConstraintIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0TransformConstraintTimeline@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setFrame@TransformConstraintTimeline@spine@@QEAAX_KMMMMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFrame(__IntPtr __instance, ulong frameIndex, float time, float mixRotate, float mixX, float mixY, float mixScaleX, float mixScaleY, float mixShearY);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?getTransformConstraintIndex@TransformConstraintTimeline@spine@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetTransformConstraintIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "?setTransformConstraintIndex@TransformConstraintTimeline@spine@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTransformConstraintIndex(__IntPtr __instance, int inValue);
            }

            internal static new TransformConstraintTimeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TransformConstraintTimeline(native.ToPointer(), skipVTables);
            }

            internal static new TransformConstraintTimeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TransformConstraintTimeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new TransformConstraintTimeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (TransformConstraintTimeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static TransformConstraintTimeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TransformConstraintTimeline(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.TransformConstraintTimeline.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private TransformConstraintTimeline(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TransformConstraintTimeline(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public TransformConstraintTimeline(ulong frameCount, ulong bezierCount, int transformConstraintIndex)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TransformConstraintTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, frameCount, bezierCount, transformConstraintIndex);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TransformConstraintTimeline");
            }

            public TransformConstraintTimeline(global::spine_cpp.Spine.TransformConstraintTimeline _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.TransformConstraintTimeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.TransformConstraintTimeline");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void SetFrame(ulong frameIndex, float time, float mixRotate, float mixX, float mixY, float mixScaleX, float mixScaleY, float mixShearY)
            {
                __Internal.SetFrame(__Instance, frameIndex, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
            }

            public static global::spine_cpp.Spine.RTTI Rtti
            {
                get
                {
                    var __ptr = (global::spine_cpp.Spine.RTTI.__Internal*)global::spine_cpp.__Symbols.DLLPlugin._rtti_TransformConstraintTimeline_spine__2VRTTI_2_B;
                    return global::spine_cpp.Spine.RTTI.__CreateInstance(new __IntPtr(__ptr));
                }
            }

            public override global::spine_cpp.Spine.RTTI RTTI
            {
                get
                {
                    return base.RTTI;
                }
            }

            public int TransformConstraintIndex
            {
                get
                {
                    var ___ret = __Internal.GetTransformConstraintIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetTransformConstraintIndex(__Instance, value);
                }
            }

            #region Virtual table interop

            // TransformConstraintTimeline
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.TransformConstraintTimeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // 
            private static global::spine_cpp.Delegates.Func___IntPtr___IntPtr _GetRTTIDelegateInstance;

            private static __IntPtr _GetRTTIDelegateHook(__IntPtr __instance)
            {
                var __target = global::spine_cpp.Spine.TransformConstraintTimeline.__GetInstance(__instance);
                var ___ret = __target.RTTI;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setBezier(size_t bezier, size_t frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            private static global::spine_cpp.Delegates.Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float _SetBezierDelegateInstance;

            private static void _SetBezierDelegateHook(__IntPtr __instance, ulong bezier, ulong frame, float value, float time1, float value1, float cx1, float cy1, float cx2, float cy2, float time2, float value2)
            {
                var __target = global::spine_cpp.Spine.TransformConstraintTimeline.__GetInstance(__instance);
                __target.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRTTIDelegateInstance += _GetRTTIDelegateHook;
                    _SetBezierDelegateInstance += _SetBezierDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRTTIDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetBezierDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        public unsafe partial class Vertices : global::spine_cpp.Spine.SpineObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 72)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_SpineObject;
                internal global::spine_cpp.Spine.Vector.__Internal _bones;
                internal global::spine_cpp.Spine.Vector.__Internal _vertices;

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Vertices@spine@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("DLLPlugin", EntryPoint = "??0Vertices@spine@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new Vertices __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Vertices(native.ToPointer(), skipVTables);
            }

            internal static new Vertices __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Vertices)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Vertices __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Vertices)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Vertices __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Vertices(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::spine_cpp.Spine.Vertices.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private Vertices(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Vertices(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Vertices(global::spine_cpp.Spine.Vertices _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vertices.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Vertices");
            }

            public Vertices()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::spine_cpp.Spine.Vertices.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "spine_cpp.Spine.Vertices");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::spine_cpp.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // Vertices
            private static global::spine_cpp.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::spine_cpp.Spine.Vertices.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Spine
    {
        /// <summary>
        /// <para>Controls how a timeline is mixed with the setup or current pose.</para>
        /// <para>See also Timeline::apply(Skeleton&amp;, float, float, Vector&amp;, float, Blend, MixDirection)</para>
        /// </summary>
        public enum MixBlend
        {
            MixBlendSetup = 0,
            MixBlendFirst = 1,
            MixBlendReplace = 2,
            MixBlendAdd = 3
        }
    }

    namespace Spine
    {
        /// <summary>
        /// <para>Indicates whether a timeline's alpha is mixing out over time toward 0 (the setup or current pose) or mixing in toward 1 (the timeline's pose).</para>
        /// <para>See also Timeline::apply(Skeleton&amp;, float, float, Vector&amp;, float, MixPose, MixDirection)</para>
        /// </summary>
        public enum MixDirection
        {
            MixDirectionIn = 0,
            MixDirectionOut = 1
        }
    }

    namespace Spine
    {
        [Flags]
        public enum Property
        {
            PropertyRotate = 1,
            PropertyX = 2,
            PropertyY = 4,
            PropertyScaleX = 8,
            PropertyScaleY = 16,
            PropertyShearX = 32,
            PropertyShearY = 64,
            PropertyRgb = 128,
            PropertyAlpha = 256,
            PropertyRgb2 = 512,
            PropertyAttachment = 1024,
            PropertyDeform = 2048,
            PropertyEvent = 4096,
            PropertyDrawOrder = 8192,
            PropertyIkConstraint = 16384,
            PropertyTransformConstraint = 32768,
            PropertyPathConstraintPosition = 65536,
            PropertyPathConstraintSpacing = 131072,
            PropertyPathConstraintMix = 262144,
            PropertySequence = 524288
        }
    }

    namespace Spine
    {
        public enum TransformMode
        {
            TransformModeNormal = 0,
            TransformModeOnlyTranslation = 1,
            TransformModeNoRotationOrReflection = 2,
            TransformModeNoScale = 3,
            TransformModeNoScaleOrReflection = 4
        }
    }

    namespace Spine
    {
        public enum BlendMode
        {
            BlendModeNormal = 0,
            BlendModeAdditive = 1,
            BlendModeMultiply = 2,
            BlendModeScreen = 3
        }
    }

    namespace Spine
    {
        public enum PositionMode
        {
            PositionModeFixed = 0,
            PositionModePercent = 1
        }
    }

    namespace Spine
    {
        public enum SpacingMode
        {
            SpacingModeLength = 0,
            SpacingModeFixed = 1,
            SpacingModePercent = 2,
            SpacingModeProportional = 3
        }
    }

    namespace Spine
    {
        public enum RotateMode
        {
            RotateModeTangent = 0,
            RotateModeChain = 1,
            RotateModeChainScale = 2
        }
    }

    namespace Spine
    {
        public enum AttachmentType
        {
            AttachmentTypeRegion = 0,
            AttachmentTypeBoundingbox = 1,
            AttachmentTypeMesh = 2,
            AttachmentTypeLinkedmesh = 3,
            AttachmentTypePath = 4,
            AttachmentTypePoint = 5,
            AttachmentTypeClipping = 6
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int(__IntPtr __instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_ulong_string8_int(__IntPtr __instance, ulong arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2, int arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr___IntPtr_ulong_string8_int(__IntPtr __instance, __IntPtr arg1, ulong arg2, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg3, int arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_string8_int(__IntPtr __instance, __IntPtr arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2, int arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate sbyte* Func_sbytePtr___IntPtr___IntPtr_intPtr(__IntPtr __instance, __IntPtr arg1, int* arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate int Func_int___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_bool(__IntPtr __instance, [MarshalAs(UnmanagedType.I1)] bool arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_spine_cpp_spine_EventType___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, global::spine_cpp.Spine.EventType arg2, __IntPtr arg3, __IntPtr arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_ulong_ulong_floatPtr_ulong_ulong(__IntPtr __instance, __IntPtr arg1, ulong arg2, ulong arg3, float* arg4, ulong arg5, ulong arg6);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2, __IntPtr arg3, __IntPtr arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ulong_ulong_float_float_float_float_float_float_float_float_float(__IntPtr __instance, ulong arg1, ulong arg2, float arg3, float arg4, float arg5, float arg6, float arg7, float arg8, float arg9, float arg10, float arg11);
    }
}
namespace spine_cpp.__Symbols
{
    internal class DLLPlugin
    {
        public static IntPtr _rtti_AttachmentLoader_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_AtlasAttachmentLoader_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_Attachment_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_Timeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_AttachmentTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_Updatable_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_Bone_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_VertexAttachment_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_BoundingBoxAttachment_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_ClippingAttachment_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_CurveTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_CurveTimeline1_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_CurveTimeline2_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_RGBATimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_RGBTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_AlphaTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_RGBA2Timeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_RGB2Timeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_ConstraintData_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_DeformTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_DrawOrderTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_EventTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_IkConstraint_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_IkConstraintData_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_IkConstraintTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _JSON_FALSE_Json_spine__2HB { get; }
        public static IntPtr _JSON_TRUE_Json_spine__2HB { get; }
        public static IntPtr _JSON_NULL_Json_spine__2HB { get; }
        public static IntPtr _JSON_NUMBER_Json_spine__2HB { get; }
        public static IntPtr _JSON_STRING_Json_spine__2HB { get; }
        public static IntPtr _JSON_ARRAY_Json_spine__2HB { get; }
        public static IntPtr _JSON_OBJECT_Json_spine__2HB { get; }
        public static IntPtr _rtti_MeshAttachment_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_PathAttachment_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_PathConstraint_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_PathConstraintData_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_PathConstraintMixTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_PathConstraintPositionTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_PathConstraintSpacingTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_PointAttachment_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_RegionAttachment_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_RotateTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_TranslateTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_TranslateXTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_TranslateYTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_ScaleTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_ScaleXTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_ScaleYTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_ShearTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_ShearXTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_ShearYTimeline_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_TransformConstraint_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_TransformConstraintData_spine__2VRTTI_2_B { get; }
        public static IntPtr _rtti_TransformConstraintTimeline_spine__2VRTTI_2_B { get; }
        static DLLPlugin()
        {
            var path = "DLLPlugin";
            var image = CppSharp.SymbolResolver.LoadImage(ref path);
            if (image == IntPtr.Zero) throw new global::System.DllNotFoundException(path);
            _rtti_AttachmentLoader_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@AttachmentLoader@spine@@2VRTTI@2@B");
            _rtti_AtlasAttachmentLoader_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@AtlasAttachmentLoader@spine@@2VRTTI@2@B");
            _rtti_Attachment_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@Attachment@spine@@2VRTTI@2@B");
            _rtti_Timeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@Timeline@spine@@2VRTTI@2@B");
            _rtti_AttachmentTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@AttachmentTimeline@spine@@2VRTTI@2@B");
            _rtti_Updatable_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@Updatable@spine@@2VRTTI@2@B");
            _rtti_Bone_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@Bone@spine@@2VRTTI@2@B");
            _rtti_VertexAttachment_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@VertexAttachment@spine@@2VRTTI@2@B");
            _rtti_BoundingBoxAttachment_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@BoundingBoxAttachment@spine@@2VRTTI@2@B");
            _rtti_ClippingAttachment_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@ClippingAttachment@spine@@2VRTTI@2@B");
            _rtti_CurveTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@CurveTimeline@spine@@2VRTTI@2@B");
            _rtti_CurveTimeline1_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@CurveTimeline1@spine@@2VRTTI@2@B");
            _rtti_CurveTimeline2_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@CurveTimeline2@spine@@2VRTTI@2@B");
            _rtti_RGBATimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@RGBATimeline@spine@@2VRTTI@2@B");
            _rtti_RGBTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@RGBTimeline@spine@@2VRTTI@2@B");
            _rtti_AlphaTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@AlphaTimeline@spine@@2VRTTI@2@B");
            _rtti_RGBA2Timeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@RGBA2Timeline@spine@@2VRTTI@2@B");
            _rtti_RGB2Timeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@RGB2Timeline@spine@@2VRTTI@2@B");
            _rtti_ConstraintData_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@ConstraintData@spine@@2VRTTI@2@B");
            _rtti_DeformTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@DeformTimeline@spine@@2VRTTI@2@B");
            _rtti_DrawOrderTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@DrawOrderTimeline@spine@@2VRTTI@2@B");
            _rtti_EventTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@EventTimeline@spine@@2VRTTI@2@B");
            _rtti_IkConstraint_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@IkConstraint@spine@@2VRTTI@2@B");
            _rtti_IkConstraintData_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@IkConstraintData@spine@@2VRTTI@2@B");
            _rtti_IkConstraintTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@IkConstraintTimeline@spine@@2VRTTI@2@B");
            _JSON_FALSE_Json_spine__2HB = CppSharp.SymbolResolver.ResolveSymbol(image, "?JSON_FALSE@Json@spine@@2HB");
            _JSON_TRUE_Json_spine__2HB = CppSharp.SymbolResolver.ResolveSymbol(image, "?JSON_TRUE@Json@spine@@2HB");
            _JSON_NULL_Json_spine__2HB = CppSharp.SymbolResolver.ResolveSymbol(image, "?JSON_NULL@Json@spine@@2HB");
            _JSON_NUMBER_Json_spine__2HB = CppSharp.SymbolResolver.ResolveSymbol(image, "?JSON_NUMBER@Json@spine@@2HB");
            _JSON_STRING_Json_spine__2HB = CppSharp.SymbolResolver.ResolveSymbol(image, "?JSON_STRING@Json@spine@@2HB");
            _JSON_ARRAY_Json_spine__2HB = CppSharp.SymbolResolver.ResolveSymbol(image, "?JSON_ARRAY@Json@spine@@2HB");
            _JSON_OBJECT_Json_spine__2HB = CppSharp.SymbolResolver.ResolveSymbol(image, "?JSON_OBJECT@Json@spine@@2HB");
            _rtti_MeshAttachment_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@MeshAttachment@spine@@2VRTTI@2@B");
            _rtti_PathAttachment_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@PathAttachment@spine@@2VRTTI@2@B");
            _rtti_PathConstraint_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@PathConstraint@spine@@2VRTTI@2@B");
            _rtti_PathConstraintData_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@PathConstraintData@spine@@2VRTTI@2@B");
            _rtti_PathConstraintMixTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@PathConstraintMixTimeline@spine@@2VRTTI@2@B");
            _rtti_PathConstraintPositionTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@PathConstraintPositionTimeline@spine@@2VRTTI@2@B");
            _rtti_PathConstraintSpacingTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@PathConstraintSpacingTimeline@spine@@2VRTTI@2@B");
            _rtti_PointAttachment_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@PointAttachment@spine@@2VRTTI@2@B");
            _rtti_RegionAttachment_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@RegionAttachment@spine@@2VRTTI@2@B");
            _rtti_RotateTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@RotateTimeline@spine@@2VRTTI@2@B");
            _rtti_TranslateTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@TranslateTimeline@spine@@2VRTTI@2@B");
            _rtti_TranslateXTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@TranslateXTimeline@spine@@2VRTTI@2@B");
            _rtti_TranslateYTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@TranslateYTimeline@spine@@2VRTTI@2@B");
            _rtti_ScaleTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@ScaleTimeline@spine@@2VRTTI@2@B");
            _rtti_ScaleXTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@ScaleXTimeline@spine@@2VRTTI@2@B");
            _rtti_ScaleYTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@ScaleYTimeline@spine@@2VRTTI@2@B");
            _rtti_ShearTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@ShearTimeline@spine@@2VRTTI@2@B");
            _rtti_ShearXTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@ShearXTimeline@spine@@2VRTTI@2@B");
            _rtti_ShearYTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@ShearYTimeline@spine@@2VRTTI@2@B");
            _rtti_TransformConstraint_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@TransformConstraint@spine@@2VRTTI@2@B");
            _rtti_TransformConstraintData_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@TransformConstraintData@spine@@2VRTTI@2@B");
            _rtti_TransformConstraintTimeline_spine__2VRTTI_2_B = CppSharp.SymbolResolver.ResolveSymbol(image, "?rtti@TransformConstraintTimeline@spine@@2VRTTI@2@B");
        }
    }
}

namespace spine_cpp.__Symbols
{
    internal class spine_cpp
    {
        public static IntPtr _ENTRIES_PathConstraintPositionTimeline_spine__2HB { get; }
        static spine_cpp()
        {
            var path = "spine_cpp";
            var image = CppSharp.SymbolResolver.LoadImage(ref path);
            if (image == IntPtr.Zero) throw new global::System.DllNotFoundException(path);
            _ENTRIES_PathConstraintPositionTimeline_spine__2HB = CppSharp.SymbolResolver.ResolveSymbol(image, "?ENTRIES@PathConstraintPositionTimeline@spine@@2HB");
        }
    }
}

